// Code generated by entc, DO NOT EDIT.

package ent

import (
	"cattleai/ent/inspection"
	"fmt"
	"strings"

	"github.com/facebook/ent/dialect/sql"
)

// Inspection is the model entity for the Inspection schema.
type Inspection struct {
	config `json:"-"`
	// ID of the ent.
	ID int64 `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// EarNumber holds the value of the "earNumber" field.
	EarNumber string `json:"earNumber,omitempty"`
	// ShedName holds the value of the "shedName" field.
	ShedName string `json:"shedName,omitempty"`
	// Date holds the value of the "date" field.
	Date int64 `json:"date,omitempty"`
	// ItemId holds the value of the "itemId" field.
	ItemId int `json:"itemId,omitempty"`
	// ItemName holds the value of the "itemName" field.
	ItemName string `json:"itemName,omitempty"`
	// MethodId holds the value of the "methodId" field.
	MethodId int `json:"methodId,omitempty"`
	// MethodName holds the value of the "methodName" field.
	MethodName string `json:"methodName,omitempty"`
	// ById holds the value of the "byId" field.
	ById int64 `json:"byId,omitempty"`
	// ByName holds the value of the "byName" field.
	ByName string `json:"byName,omitempty"`
	// ResultId holds the value of the "resultId" field.
	ResultId int64 `json:"resultId,omitempty"`
	// ResultName holds the value of the "resultName" field.
	ResultName string `json:"resultName,omitempty"`
	// HandleId holds the value of the "handleId" field.
	HandleId int `json:"handleId,omitempty"`
	// HandleName holds the value of the "handleName" field.
	HandleName string `json:"handleName,omitempty"`
	// Remarks holds the value of the "remarks" field.
	Remarks string `json:"remarks,omitempty"`
	// CreatedAt holds the value of the "createdAt" field.
	CreatedAt int64 `json:"createdAt,omitempty"`
	// UpdatedAt holds the value of the "updatedAt" field.
	UpdatedAt int64 `json:"updatedAt,omitempty"`
	// Deleted holds the value of the "deleted" field.
	Deleted int `json:"deleted,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Inspection) scanValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{},  // id
		&sql.NullString{}, // name
		&sql.NullString{}, // earNumber
		&sql.NullString{}, // shedName
		&sql.NullInt64{},  // date
		&sql.NullInt64{},  // itemId
		&sql.NullString{}, // itemName
		&sql.NullInt64{},  // methodId
		&sql.NullString{}, // methodName
		&sql.NullInt64{},  // byId
		&sql.NullString{}, // byName
		&sql.NullInt64{},  // resultId
		&sql.NullString{}, // resultName
		&sql.NullInt64{},  // handleId
		&sql.NullString{}, // handleName
		&sql.NullString{}, // remarks
		&sql.NullInt64{},  // createdAt
		&sql.NullInt64{},  // updatedAt
		&sql.NullInt64{},  // deleted
	}
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Inspection fields.
func (i *Inspection) assignValues(values ...interface{}) error {
	if m, n := len(values), len(inspection.Columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	value, ok := values[0].(*sql.NullInt64)
	if !ok {
		return fmt.Errorf("unexpected type %T for field id", value)
	}
	i.ID = int64(value.Int64)
	values = values[1:]
	if value, ok := values[0].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field name", values[0])
	} else if value.Valid {
		i.Name = value.String
	}
	if value, ok := values[1].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field earNumber", values[1])
	} else if value.Valid {
		i.EarNumber = value.String
	}
	if value, ok := values[2].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field shedName", values[2])
	} else if value.Valid {
		i.ShedName = value.String
	}
	if value, ok := values[3].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field date", values[3])
	} else if value.Valid {
		i.Date = value.Int64
	}
	if value, ok := values[4].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field itemId", values[4])
	} else if value.Valid {
		i.ItemId = int(value.Int64)
	}
	if value, ok := values[5].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field itemName", values[5])
	} else if value.Valid {
		i.ItemName = value.String
	}
	if value, ok := values[6].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field methodId", values[6])
	} else if value.Valid {
		i.MethodId = int(value.Int64)
	}
	if value, ok := values[7].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field methodName", values[7])
	} else if value.Valid {
		i.MethodName = value.String
	}
	if value, ok := values[8].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field byId", values[8])
	} else if value.Valid {
		i.ById = value.Int64
	}
	if value, ok := values[9].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field byName", values[9])
	} else if value.Valid {
		i.ByName = value.String
	}
	if value, ok := values[10].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field resultId", values[10])
	} else if value.Valid {
		i.ResultId = value.Int64
	}
	if value, ok := values[11].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field resultName", values[11])
	} else if value.Valid {
		i.ResultName = value.String
	}
	if value, ok := values[12].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field handleId", values[12])
	} else if value.Valid {
		i.HandleId = int(value.Int64)
	}
	if value, ok := values[13].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field handleName", values[13])
	} else if value.Valid {
		i.HandleName = value.String
	}
	if value, ok := values[14].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field remarks", values[14])
	} else if value.Valid {
		i.Remarks = value.String
	}
	if value, ok := values[15].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field createdAt", values[15])
	} else if value.Valid {
		i.CreatedAt = value.Int64
	}
	if value, ok := values[16].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field updatedAt", values[16])
	} else if value.Valid {
		i.UpdatedAt = value.Int64
	}
	if value, ok := values[17].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field deleted", values[17])
	} else if value.Valid {
		i.Deleted = int(value.Int64)
	}
	return nil
}

// Update returns a builder for updating this Inspection.
// Note that, you need to call Inspection.Unwrap() before calling this method, if this Inspection
// was returned from a transaction, and the transaction was committed or rolled back.
func (i *Inspection) Update() *InspectionUpdateOne {
	return (&InspectionClient{config: i.config}).UpdateOne(i)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (i *Inspection) Unwrap() *Inspection {
	tx, ok := i.config.driver.(*txDriver)
	if !ok {
		panic("ent: Inspection is not a transactional entity")
	}
	i.config.driver = tx.drv
	return i
}

// String implements the fmt.Stringer.
func (i *Inspection) String() string {
	var builder strings.Builder
	builder.WriteString("Inspection(")
	builder.WriteString(fmt.Sprintf("id=%v", i.ID))
	builder.WriteString(", name=")
	builder.WriteString(i.Name)
	builder.WriteString(", earNumber=")
	builder.WriteString(i.EarNumber)
	builder.WriteString(", shedName=")
	builder.WriteString(i.ShedName)
	builder.WriteString(", date=")
	builder.WriteString(fmt.Sprintf("%v", i.Date))
	builder.WriteString(", itemId=")
	builder.WriteString(fmt.Sprintf("%v", i.ItemId))
	builder.WriteString(", itemName=")
	builder.WriteString(i.ItemName)
	builder.WriteString(", methodId=")
	builder.WriteString(fmt.Sprintf("%v", i.MethodId))
	builder.WriteString(", methodName=")
	builder.WriteString(i.MethodName)
	builder.WriteString(", byId=")
	builder.WriteString(fmt.Sprintf("%v", i.ById))
	builder.WriteString(", byName=")
	builder.WriteString(i.ByName)
	builder.WriteString(", resultId=")
	builder.WriteString(fmt.Sprintf("%v", i.ResultId))
	builder.WriteString(", resultName=")
	builder.WriteString(i.ResultName)
	builder.WriteString(", handleId=")
	builder.WriteString(fmt.Sprintf("%v", i.HandleId))
	builder.WriteString(", handleName=")
	builder.WriteString(i.HandleName)
	builder.WriteString(", remarks=")
	builder.WriteString(i.Remarks)
	builder.WriteString(", createdAt=")
	builder.WriteString(fmt.Sprintf("%v", i.CreatedAt))
	builder.WriteString(", updatedAt=")
	builder.WriteString(fmt.Sprintf("%v", i.UpdatedAt))
	builder.WriteString(", deleted=")
	builder.WriteString(fmt.Sprintf("%v", i.Deleted))
	builder.WriteByte(')')
	return builder.String()
}

// Inspections is a parsable slice of Inspection.
type Inspections []*Inspection

func (i Inspections) config(cfg config) {
	for _i := range i {
		i[_i].config = cfg
	}
}

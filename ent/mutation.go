// Code generated by entc, DO NOT EDIT.

package ent

import (
	"cattleai/confs"
	"cattleai/ent/abortion"
	"cattleai/ent/abortiontype"
	"cattleai/ent/birthsurrounding"
	"cattleai/ent/breathrate"
	"cattleai/ent/breeding"
	"cattleai/ent/breedingtype"
	"cattleai/ent/calve"
	"cattleai/ent/calvecount"
	"cattleai/ent/calvetype"
	"cattleai/ent/category"
	"cattleai/ent/cattle"
	"cattleai/ent/cattlecate"
	"cattleai/ent/cattlegender"
	"cattleai/ent/cattlegrow"
	"cattleai/ent/cattlegrowsdata"
	"cattleai/ent/cattlegrowsrate"
	"cattleai/ent/cattlehaircolor"
	"cattleai/ent/cattlejoinedtype"
	"cattleai/ent/cattleowner"
	"cattleai/ent/cattletype"
	"cattleai/ent/conf"
	"cattleai/ent/disinfect"
	"cattleai/ent/duty"
	"cattleai/ent/epidemic"
	"cattleai/ent/epidemictype"
	"cattleai/ent/estrus"
	"cattleai/ent/estrustype"
	"cattleai/ent/farm"
	"cattleai/ent/hairstate"
	"cattleai/ent/immunity"
	"cattleai/ent/inspection"
	"cattleai/ent/material"
	"cattleai/ent/materialtest"
	"cattleai/ent/position"
	"cattleai/ent/pregnancytest"
	"cattleai/ent/pregnancytestmethod"
	"cattleai/ent/pregnancytestresult"
	"cattleai/ent/pregnancytesttype"
	"cattleai/ent/reproductivestate"
	"cattleai/ent/semenfrozentype"
	"cattleai/ent/shed"
	"cattleai/ent/shedcategory"
	"cattleai/ent/shedtype"
	"cattleai/ent/treatmentresult"
	"cattleai/ent/treatmentstate"
	"cattleai/ent/user"
	"cattleai/ent/whereabouts"
	"cattleai/ent/winddirection"
	"context"
	"fmt"
	"sync"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbortion            = "Abortion"
	TypeAbortionType        = "AbortionType"
	TypeBirthSurrounding    = "BirthSurrounding"
	TypeBreathRate          = "BreathRate"
	TypeBreeding            = "Breeding"
	TypeBreedingType        = "BreedingType"
	TypeCalve               = "Calve"
	TypeCalveCount          = "CalveCount"
	TypeCalveType           = "CalveType"
	TypeCategory            = "Category"
	TypeCattle              = "Cattle"
	TypeCattleCate          = "CattleCate"
	TypeCattleGender        = "CattleGender"
	TypeCattleGrow          = "CattleGrow"
	TypeCattleGrowsData     = "CattleGrowsData"
	TypeCattleGrowsRate     = "CattleGrowsRate"
	TypeCattleHairColor     = "CattleHairColor"
	TypeCattleJoinedType    = "CattleJoinedType"
	TypeCattleOwner         = "CattleOwner"
	TypeCattleType          = "CattleType"
	TypeConf                = "Conf"
	TypeDisinfect           = "Disinfect"
	TypeDispence            = "Dispence"
	TypeDuty                = "Duty"
	TypeEpidemic            = "Epidemic"
	TypeEpidemicType        = "EpidemicType"
	TypeEstrus              = "Estrus"
	TypeEstrusType          = "EstrusType"
	TypeFarm                = "Farm"
	TypeHairState           = "HairState"
	TypeImmunity            = "Immunity"
	TypeInspection          = "Inspection"
	TypeMaterial            = "Material"
	TypeMaterialTest        = "MaterialTest"
	TypePosition            = "Position"
	TypePregnancyTest       = "PregnancyTest"
	TypePregnancyTestMethod = "PregnancyTestMethod"
	TypePregnancyTestResult = "PregnancyTestResult"
	TypePregnancyTestType   = "PregnancyTestType"
	TypeReproductiveState   = "ReproductiveState"
	TypeSemenFrozenType     = "SemenFrozenType"
	TypeShed                = "Shed"
	TypeShedCategory        = "ShedCategory"
	TypeShedType            = "ShedType"
	TypeTreatmentResult     = "TreatmentResult"
	TypeTreatmentState      = "TreatmentState"
	TypeUser                = "User"
	TypeWhereabouts         = "Whereabouts"
	TypeWindDirection       = "WindDirection"
)

// AbortionMutation represents an operation that mutate the Abortions
// nodes in the graph.
type AbortionMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name              *string
	earNumber         *string
	times             *int
	addtimes          *int
	reproductiveState *string
	shedName          *string
	pregnantAt        *int64
	addpregnantAt     *int64
	abortionAt        *int64
	addabortionAt     *int64
	abortionTypeId    *int
	addabortionTypeId *int
	abortionTypeName  *string
	userName          *string
	remarks           *string
	createdAt         *int64
	addcreatedAt      *int64
	updatedAt         *int64
	addupdatedAt      *int64
	deleted           *int
	adddeleted        *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Abortion, error)
}

var _ ent.Mutation = (*AbortionMutation)(nil)

// abortionOption allows to manage the mutation configuration using functional options.
type abortionOption func(*AbortionMutation)

// newAbortionMutation creates new mutation for $n.Name.
func newAbortionMutation(c config, op Op, opts ...abortionOption) *AbortionMutation {
	m := &AbortionMutation{
		config:        c,
		op:            op,
		typ:           TypeAbortion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbortionID sets the id field of the mutation.
func withAbortionID(id int64) abortionOption {
	return func(m *AbortionMutation) {
		var (
			err   error
			once  sync.Once
			value *Abortion
		)
		m.oldValue = func(ctx context.Context) (*Abortion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Abortion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbortion sets the old Abortion of the mutation.
func withAbortion(node *Abortion) abortionOption {
	return func(m *AbortionMutation) {
		m.oldValue = func(context.Context) (*Abortion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbortionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbortionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AbortionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *AbortionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AbortionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *AbortionMutation) ClearName() {
	m.name = nil
	m.clearedFields[abortion.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *AbortionMutation) NameCleared() bool {
	_, ok := m.clearedFields[abortion.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *AbortionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, abortion.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *AbortionMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *AbortionMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *AbortionMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *AbortionMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *AbortionMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *AbortionMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *AbortionMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *AbortionMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetReproductiveState sets the reproductiveState field.
func (m *AbortionMutation) SetReproductiveState(s string) {
	m.reproductiveState = &s
}

// ReproductiveState returns the reproductiveState value in the mutation.
func (m *AbortionMutation) ReproductiveState() (r string, exists bool) {
	v := m.reproductiveState
	if v == nil {
		return
	}
	return *v, true
}

// OldReproductiveState returns the old reproductiveState value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldReproductiveState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReproductiveState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReproductiveState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReproductiveState: %w", err)
	}
	return oldValue.ReproductiveState, nil
}

// ResetReproductiveState reset all changes of the "reproductiveState" field.
func (m *AbortionMutation) ResetReproductiveState() {
	m.reproductiveState = nil
}

// SetShedName sets the shedName field.
func (m *AbortionMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *AbortionMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *AbortionMutation) ResetShedName() {
	m.shedName = nil
}

// SetPregnantAt sets the pregnantAt field.
func (m *AbortionMutation) SetPregnantAt(i int64) {
	m.pregnantAt = &i
	m.addpregnantAt = nil
}

// PregnantAt returns the pregnantAt value in the mutation.
func (m *AbortionMutation) PregnantAt() (r int64, exists bool) {
	v := m.pregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnantAt returns the old pregnantAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldPregnantAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnantAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnantAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnantAt: %w", err)
	}
	return oldValue.PregnantAt, nil
}

// AddPregnantAt adds i to pregnantAt.
func (m *AbortionMutation) AddPregnantAt(i int64) {
	if m.addpregnantAt != nil {
		*m.addpregnantAt += i
	} else {
		m.addpregnantAt = &i
	}
}

// AddedPregnantAt returns the value that was added to the pregnantAt field in this mutation.
func (m *AbortionMutation) AddedPregnantAt() (r int64, exists bool) {
	v := m.addpregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnantAt reset all changes of the "pregnantAt" field.
func (m *AbortionMutation) ResetPregnantAt() {
	m.pregnantAt = nil
	m.addpregnantAt = nil
}

// SetAbortionAt sets the abortionAt field.
func (m *AbortionMutation) SetAbortionAt(i int64) {
	m.abortionAt = &i
	m.addabortionAt = nil
}

// AbortionAt returns the abortionAt value in the mutation.
func (m *AbortionMutation) AbortionAt() (r int64, exists bool) {
	v := m.abortionAt
	if v == nil {
		return
	}
	return *v, true
}

// OldAbortionAt returns the old abortionAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldAbortionAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbortionAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbortionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbortionAt: %w", err)
	}
	return oldValue.AbortionAt, nil
}

// AddAbortionAt adds i to abortionAt.
func (m *AbortionMutation) AddAbortionAt(i int64) {
	if m.addabortionAt != nil {
		*m.addabortionAt += i
	} else {
		m.addabortionAt = &i
	}
}

// AddedAbortionAt returns the value that was added to the abortionAt field in this mutation.
func (m *AbortionMutation) AddedAbortionAt() (r int64, exists bool) {
	v := m.addabortionAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbortionAt reset all changes of the "abortionAt" field.
func (m *AbortionMutation) ResetAbortionAt() {
	m.abortionAt = nil
	m.addabortionAt = nil
}

// SetAbortionTypeId sets the abortionTypeId field.
func (m *AbortionMutation) SetAbortionTypeId(i int) {
	m.abortionTypeId = &i
	m.addabortionTypeId = nil
}

// AbortionTypeId returns the abortionTypeId value in the mutation.
func (m *AbortionMutation) AbortionTypeId() (r int, exists bool) {
	v := m.abortionTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldAbortionTypeId returns the old abortionTypeId value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldAbortionTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbortionTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbortionTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbortionTypeId: %w", err)
	}
	return oldValue.AbortionTypeId, nil
}

// AddAbortionTypeId adds i to abortionTypeId.
func (m *AbortionMutation) AddAbortionTypeId(i int) {
	if m.addabortionTypeId != nil {
		*m.addabortionTypeId += i
	} else {
		m.addabortionTypeId = &i
	}
}

// AddedAbortionTypeId returns the value that was added to the abortionTypeId field in this mutation.
func (m *AbortionMutation) AddedAbortionTypeId() (r int, exists bool) {
	v := m.addabortionTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbortionTypeId reset all changes of the "abortionTypeId" field.
func (m *AbortionMutation) ResetAbortionTypeId() {
	m.abortionTypeId = nil
	m.addabortionTypeId = nil
}

// SetAbortionTypeName sets the abortionTypeName field.
func (m *AbortionMutation) SetAbortionTypeName(s string) {
	m.abortionTypeName = &s
}

// AbortionTypeName returns the abortionTypeName value in the mutation.
func (m *AbortionMutation) AbortionTypeName() (r string, exists bool) {
	v := m.abortionTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldAbortionTypeName returns the old abortionTypeName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldAbortionTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbortionTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbortionTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbortionTypeName: %w", err)
	}
	return oldValue.AbortionTypeName, nil
}

// ResetAbortionTypeName reset all changes of the "abortionTypeName" field.
func (m *AbortionMutation) ResetAbortionTypeName() {
	m.abortionTypeName = nil
}

// SetUserName sets the userName field.
func (m *AbortionMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *AbortionMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *AbortionMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *AbortionMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *AbortionMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *AbortionMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *AbortionMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *AbortionMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *AbortionMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *AbortionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *AbortionMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *AbortionMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *AbortionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *AbortionMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *AbortionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *AbortionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *AbortionMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *AbortionMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *AbortionMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *AbortionMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *AbortionMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *AbortionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Abortion).
func (m *AbortionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AbortionMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, abortion.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, abortion.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, abortion.FieldTimes)
	}
	if m.reproductiveState != nil {
		fields = append(fields, abortion.FieldReproductiveState)
	}
	if m.shedName != nil {
		fields = append(fields, abortion.FieldShedName)
	}
	if m.pregnantAt != nil {
		fields = append(fields, abortion.FieldPregnantAt)
	}
	if m.abortionAt != nil {
		fields = append(fields, abortion.FieldAbortionAt)
	}
	if m.abortionTypeId != nil {
		fields = append(fields, abortion.FieldAbortionTypeId)
	}
	if m.abortionTypeName != nil {
		fields = append(fields, abortion.FieldAbortionTypeName)
	}
	if m.userName != nil {
		fields = append(fields, abortion.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, abortion.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, abortion.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, abortion.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, abortion.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AbortionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abortion.FieldName:
		return m.Name()
	case abortion.FieldEarNumber:
		return m.EarNumber()
	case abortion.FieldTimes:
		return m.Times()
	case abortion.FieldReproductiveState:
		return m.ReproductiveState()
	case abortion.FieldShedName:
		return m.ShedName()
	case abortion.FieldPregnantAt:
		return m.PregnantAt()
	case abortion.FieldAbortionAt:
		return m.AbortionAt()
	case abortion.FieldAbortionTypeId:
		return m.AbortionTypeId()
	case abortion.FieldAbortionTypeName:
		return m.AbortionTypeName()
	case abortion.FieldUserName:
		return m.UserName()
	case abortion.FieldRemarks:
		return m.Remarks()
	case abortion.FieldCreatedAt:
		return m.CreatedAt()
	case abortion.FieldUpdatedAt:
		return m.UpdatedAt()
	case abortion.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AbortionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abortion.FieldName:
		return m.OldName(ctx)
	case abortion.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case abortion.FieldTimes:
		return m.OldTimes(ctx)
	case abortion.FieldReproductiveState:
		return m.OldReproductiveState(ctx)
	case abortion.FieldShedName:
		return m.OldShedName(ctx)
	case abortion.FieldPregnantAt:
		return m.OldPregnantAt(ctx)
	case abortion.FieldAbortionAt:
		return m.OldAbortionAt(ctx)
	case abortion.FieldAbortionTypeId:
		return m.OldAbortionTypeId(ctx)
	case abortion.FieldAbortionTypeName:
		return m.OldAbortionTypeName(ctx)
	case abortion.FieldUserName:
		return m.OldUserName(ctx)
	case abortion.FieldRemarks:
		return m.OldRemarks(ctx)
	case abortion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case abortion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case abortion.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Abortion field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abortion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abortion.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case abortion.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case abortion.FieldReproductiveState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReproductiveState(v)
		return nil
	case abortion.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case abortion.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnantAt(v)
		return nil
	case abortion.FieldAbortionAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbortionAt(v)
		return nil
	case abortion.FieldAbortionTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbortionTypeId(v)
		return nil
	case abortion.FieldAbortionTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbortionTypeName(v)
		return nil
	case abortion.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case abortion.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case abortion.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case abortion.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case abortion.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Abortion field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AbortionMutation) AddedFields() []string {
	var fields []string
	if m.addtimes != nil {
		fields = append(fields, abortion.FieldTimes)
	}
	if m.addpregnantAt != nil {
		fields = append(fields, abortion.FieldPregnantAt)
	}
	if m.addabortionAt != nil {
		fields = append(fields, abortion.FieldAbortionAt)
	}
	if m.addabortionTypeId != nil {
		fields = append(fields, abortion.FieldAbortionTypeId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, abortion.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, abortion.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, abortion.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AbortionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abortion.FieldTimes:
		return m.AddedTimes()
	case abortion.FieldPregnantAt:
		return m.AddedPregnantAt()
	case abortion.FieldAbortionAt:
		return m.AddedAbortionAt()
	case abortion.FieldAbortionTypeId:
		return m.AddedAbortionTypeId()
	case abortion.FieldCreatedAt:
		return m.AddedCreatedAt()
	case abortion.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case abortion.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abortion.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case abortion.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnantAt(v)
		return nil
	case abortion.FieldAbortionAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbortionAt(v)
		return nil
	case abortion.FieldAbortionTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbortionTypeId(v)
		return nil
	case abortion.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case abortion.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case abortion.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Abortion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AbortionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(abortion.FieldName) {
		fields = append(fields, abortion.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AbortionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbortionMutation) ClearField(name string) error {
	switch name {
	case abortion.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Abortion nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AbortionMutation) ResetField(name string) error {
	switch name {
	case abortion.FieldName:
		m.ResetName()
		return nil
	case abortion.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case abortion.FieldTimes:
		m.ResetTimes()
		return nil
	case abortion.FieldReproductiveState:
		m.ResetReproductiveState()
		return nil
	case abortion.FieldShedName:
		m.ResetShedName()
		return nil
	case abortion.FieldPregnantAt:
		m.ResetPregnantAt()
		return nil
	case abortion.FieldAbortionAt:
		m.ResetAbortionAt()
		return nil
	case abortion.FieldAbortionTypeId:
		m.ResetAbortionTypeId()
		return nil
	case abortion.FieldAbortionTypeName:
		m.ResetAbortionTypeName()
		return nil
	case abortion.FieldUserName:
		m.ResetUserName()
		return nil
	case abortion.FieldRemarks:
		m.ResetRemarks()
		return nil
	case abortion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case abortion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case abortion.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Abortion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AbortionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AbortionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AbortionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AbortionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AbortionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AbortionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AbortionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Abortion unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AbortionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Abortion edge %s", name)
}

// AbortionTypeMutation represents an operation that mutate the AbortionTypes
// nodes in the graph.
type AbortionTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AbortionType, error)
}

var _ ent.Mutation = (*AbortionTypeMutation)(nil)

// abortiontypeOption allows to manage the mutation configuration using functional options.
type abortiontypeOption func(*AbortionTypeMutation)

// newAbortionTypeMutation creates new mutation for $n.Name.
func newAbortionTypeMutation(c config, op Op, opts ...abortiontypeOption) *AbortionTypeMutation {
	m := &AbortionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAbortionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbortionTypeID sets the id field of the mutation.
func withAbortionTypeID(id int64) abortiontypeOption {
	return func(m *AbortionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AbortionType
		)
		m.oldValue = func(ctx context.Context) (*AbortionType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbortionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbortionType sets the old AbortionType of the mutation.
func withAbortionType(node *AbortionType) abortiontypeOption {
	return func(m *AbortionTypeMutation) {
		m.oldValue = func(context.Context) (*AbortionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbortionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbortionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AbortionTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *AbortionTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AbortionTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the AbortionType.
// If the AbortionType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AbortionTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *AbortionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AbortionType).
func (m *AbortionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AbortionTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, abortiontype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AbortionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abortiontype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AbortionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abortiontype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown AbortionType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abortiontype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown AbortionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AbortionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AbortionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AbortionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AbortionTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AbortionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbortionTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AbortionType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AbortionTypeMutation) ResetField(name string) error {
	switch name {
	case abortiontype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown AbortionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AbortionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AbortionTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AbortionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AbortionTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AbortionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AbortionTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AbortionTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AbortionType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AbortionTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AbortionType edge %s", name)
}

// BirthSurroundingMutation represents an operation that mutate the BirthSurroundings
// nodes in the graph.
type BirthSurroundingMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	farmId             *int64
	addfarmId          *int64
	farmName           *string
	recordTime         *int64
	addrecordTime      *int64
	userId             *int64
	adduserId          *int64
	userName           *string
	temperature        *int64
	addtemperature     *int64
	humidity           *int64
	addhumidity        *int64
	breathRateId       *int64
	addbreathRateId    *int64
	breathRateName     *string
	windSpeed          *int64
	addwindSpeed       *int64
	windDirectionId    *int
	addwindDirectionId *int
	windDirection      *string
	locationChanges    *int64
	addlocationChanges *int64
	hairStateId        *int
	addhairStateId     *int
	hairStateName      *string
	soilDepth          *int
	addsoilDepth       *int
	sunExposure        *int
	addsunExposure     *int
	walkDistance       *int
	addwalkDistance    *int
	rained             *int
	addrained          *int
	thIndex            *float32
	addthIndex         *float32
	remarks            *string
	createdAt          *int64
	addcreatedAt       *int64
	updatedAt          *int64
	addupdatedAt       *int64
	deleted            *int
	adddeleted         *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*BirthSurrounding, error)
}

var _ ent.Mutation = (*BirthSurroundingMutation)(nil)

// birthsurroundingOption allows to manage the mutation configuration using functional options.
type birthsurroundingOption func(*BirthSurroundingMutation)

// newBirthSurroundingMutation creates new mutation for $n.Name.
func newBirthSurroundingMutation(c config, op Op, opts ...birthsurroundingOption) *BirthSurroundingMutation {
	m := &BirthSurroundingMutation{
		config:        c,
		op:            op,
		typ:           TypeBirthSurrounding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBirthSurroundingID sets the id field of the mutation.
func withBirthSurroundingID(id int64) birthsurroundingOption {
	return func(m *BirthSurroundingMutation) {
		var (
			err   error
			once  sync.Once
			value *BirthSurrounding
		)
		m.oldValue = func(ctx context.Context) (*BirthSurrounding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BirthSurrounding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBirthSurrounding sets the old BirthSurrounding of the mutation.
func withBirthSurrounding(node *BirthSurrounding) birthsurroundingOption {
	return func(m *BirthSurroundingMutation) {
		m.oldValue = func(context.Context) (*BirthSurrounding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BirthSurroundingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BirthSurroundingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BirthSurroundingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *BirthSurroundingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BirthSurroundingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BirthSurroundingMutation) ResetName() {
	m.name = nil
}

// SetFarmId sets the farmId field.
func (m *BirthSurroundingMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *BirthSurroundingMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *BirthSurroundingMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *BirthSurroundingMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *BirthSurroundingMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *BirthSurroundingMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *BirthSurroundingMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *BirthSurroundingMutation) ResetFarmName() {
	m.farmName = nil
}

// SetRecordTime sets the recordTime field.
func (m *BirthSurroundingMutation) SetRecordTime(i int64) {
	m.recordTime = &i
	m.addrecordTime = nil
}

// RecordTime returns the recordTime value in the mutation.
func (m *BirthSurroundingMutation) RecordTime() (r int64, exists bool) {
	v := m.recordTime
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordTime returns the old recordTime value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldRecordTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecordTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecordTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordTime: %w", err)
	}
	return oldValue.RecordTime, nil
}

// AddRecordTime adds i to recordTime.
func (m *BirthSurroundingMutation) AddRecordTime(i int64) {
	if m.addrecordTime != nil {
		*m.addrecordTime += i
	} else {
		m.addrecordTime = &i
	}
}

// AddedRecordTime returns the value that was added to the recordTime field in this mutation.
func (m *BirthSurroundingMutation) AddedRecordTime() (r int64, exists bool) {
	v := m.addrecordTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecordTime reset all changes of the "recordTime" field.
func (m *BirthSurroundingMutation) ResetRecordTime() {
	m.recordTime = nil
	m.addrecordTime = nil
}

// SetUserId sets the userId field.
func (m *BirthSurroundingMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the userId value in the mutation.
func (m *BirthSurroundingMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old userId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to userId.
func (m *BirthSurroundingMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the userId field in this mutation.
func (m *BirthSurroundingMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId reset all changes of the "userId" field.
func (m *BirthSurroundingMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetUserName sets the userName field.
func (m *BirthSurroundingMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *BirthSurroundingMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *BirthSurroundingMutation) ResetUserName() {
	m.userName = nil
}

// SetTemperature sets the temperature field.
func (m *BirthSurroundingMutation) SetTemperature(i int64) {
	m.temperature = &i
	m.addtemperature = nil
}

// Temperature returns the temperature value in the mutation.
func (m *BirthSurroundingMutation) Temperature() (r int64, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old temperature value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldTemperature(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemperature is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds i to temperature.
func (m *BirthSurroundingMutation) AddTemperature(i int64) {
	if m.addtemperature != nil {
		*m.addtemperature += i
	} else {
		m.addtemperature = &i
	}
}

// AddedTemperature returns the value that was added to the temperature field in this mutation.
func (m *BirthSurroundingMutation) AddedTemperature() (r int64, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemperature reset all changes of the "temperature" field.
func (m *BirthSurroundingMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
}

// SetHumidity sets the humidity field.
func (m *BirthSurroundingMutation) SetHumidity(i int64) {
	m.humidity = &i
	m.addhumidity = nil
}

// Humidity returns the humidity value in the mutation.
func (m *BirthSurroundingMutation) Humidity() (r int64, exists bool) {
	v := m.humidity
	if v == nil {
		return
	}
	return *v, true
}

// OldHumidity returns the old humidity value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldHumidity(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHumidity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHumidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHumidity: %w", err)
	}
	return oldValue.Humidity, nil
}

// AddHumidity adds i to humidity.
func (m *BirthSurroundingMutation) AddHumidity(i int64) {
	if m.addhumidity != nil {
		*m.addhumidity += i
	} else {
		m.addhumidity = &i
	}
}

// AddedHumidity returns the value that was added to the humidity field in this mutation.
func (m *BirthSurroundingMutation) AddedHumidity() (r int64, exists bool) {
	v := m.addhumidity
	if v == nil {
		return
	}
	return *v, true
}

// ResetHumidity reset all changes of the "humidity" field.
func (m *BirthSurroundingMutation) ResetHumidity() {
	m.humidity = nil
	m.addhumidity = nil
}

// SetBreathRateId sets the breathRateId field.
func (m *BirthSurroundingMutation) SetBreathRateId(i int64) {
	m.breathRateId = &i
	m.addbreathRateId = nil
}

// BreathRateId returns the breathRateId value in the mutation.
func (m *BirthSurroundingMutation) BreathRateId() (r int64, exists bool) {
	v := m.breathRateId
	if v == nil {
		return
	}
	return *v, true
}

// OldBreathRateId returns the old breathRateId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldBreathRateId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreathRateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreathRateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreathRateId: %w", err)
	}
	return oldValue.BreathRateId, nil
}

// AddBreathRateId adds i to breathRateId.
func (m *BirthSurroundingMutation) AddBreathRateId(i int64) {
	if m.addbreathRateId != nil {
		*m.addbreathRateId += i
	} else {
		m.addbreathRateId = &i
	}
}

// AddedBreathRateId returns the value that was added to the breathRateId field in this mutation.
func (m *BirthSurroundingMutation) AddedBreathRateId() (r int64, exists bool) {
	v := m.addbreathRateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreathRateId reset all changes of the "breathRateId" field.
func (m *BirthSurroundingMutation) ResetBreathRateId() {
	m.breathRateId = nil
	m.addbreathRateId = nil
}

// SetBreathRateName sets the breathRateName field.
func (m *BirthSurroundingMutation) SetBreathRateName(s string) {
	m.breathRateName = &s
}

// BreathRateName returns the breathRateName value in the mutation.
func (m *BirthSurroundingMutation) BreathRateName() (r string, exists bool) {
	v := m.breathRateName
	if v == nil {
		return
	}
	return *v, true
}

// OldBreathRateName returns the old breathRateName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldBreathRateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreathRateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreathRateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreathRateName: %w", err)
	}
	return oldValue.BreathRateName, nil
}

// ResetBreathRateName reset all changes of the "breathRateName" field.
func (m *BirthSurroundingMutation) ResetBreathRateName() {
	m.breathRateName = nil
}

// SetWindSpeed sets the windSpeed field.
func (m *BirthSurroundingMutation) SetWindSpeed(i int64) {
	m.windSpeed = &i
	m.addwindSpeed = nil
}

// WindSpeed returns the windSpeed value in the mutation.
func (m *BirthSurroundingMutation) WindSpeed() (r int64, exists bool) {
	v := m.windSpeed
	if v == nil {
		return
	}
	return *v, true
}

// OldWindSpeed returns the old windSpeed value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWindSpeed(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWindSpeed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWindSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindSpeed: %w", err)
	}
	return oldValue.WindSpeed, nil
}

// AddWindSpeed adds i to windSpeed.
func (m *BirthSurroundingMutation) AddWindSpeed(i int64) {
	if m.addwindSpeed != nil {
		*m.addwindSpeed += i
	} else {
		m.addwindSpeed = &i
	}
}

// AddedWindSpeed returns the value that was added to the windSpeed field in this mutation.
func (m *BirthSurroundingMutation) AddedWindSpeed() (r int64, exists bool) {
	v := m.addwindSpeed
	if v == nil {
		return
	}
	return *v, true
}

// ResetWindSpeed reset all changes of the "windSpeed" field.
func (m *BirthSurroundingMutation) ResetWindSpeed() {
	m.windSpeed = nil
	m.addwindSpeed = nil
}

// SetWindDirectionId sets the windDirectionId field.
func (m *BirthSurroundingMutation) SetWindDirectionId(i int) {
	m.windDirectionId = &i
	m.addwindDirectionId = nil
}

// WindDirectionId returns the windDirectionId value in the mutation.
func (m *BirthSurroundingMutation) WindDirectionId() (r int, exists bool) {
	v := m.windDirectionId
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirectionId returns the old windDirectionId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWindDirectionId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWindDirectionId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWindDirectionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirectionId: %w", err)
	}
	return oldValue.WindDirectionId, nil
}

// AddWindDirectionId adds i to windDirectionId.
func (m *BirthSurroundingMutation) AddWindDirectionId(i int) {
	if m.addwindDirectionId != nil {
		*m.addwindDirectionId += i
	} else {
		m.addwindDirectionId = &i
	}
}

// AddedWindDirectionId returns the value that was added to the windDirectionId field in this mutation.
func (m *BirthSurroundingMutation) AddedWindDirectionId() (r int, exists bool) {
	v := m.addwindDirectionId
	if v == nil {
		return
	}
	return *v, true
}

// ResetWindDirectionId reset all changes of the "windDirectionId" field.
func (m *BirthSurroundingMutation) ResetWindDirectionId() {
	m.windDirectionId = nil
	m.addwindDirectionId = nil
}

// SetWindDirection sets the windDirection field.
func (m *BirthSurroundingMutation) SetWindDirection(s string) {
	m.windDirection = &s
}

// WindDirection returns the windDirection value in the mutation.
func (m *BirthSurroundingMutation) WindDirection() (r string, exists bool) {
	v := m.windDirection
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirection returns the old windDirection value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWindDirection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWindDirection is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWindDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirection: %w", err)
	}
	return oldValue.WindDirection, nil
}

// ResetWindDirection reset all changes of the "windDirection" field.
func (m *BirthSurroundingMutation) ResetWindDirection() {
	m.windDirection = nil
}

// SetLocationChanges sets the locationChanges field.
func (m *BirthSurroundingMutation) SetLocationChanges(i int64) {
	m.locationChanges = &i
	m.addlocationChanges = nil
}

// LocationChanges returns the locationChanges value in the mutation.
func (m *BirthSurroundingMutation) LocationChanges() (r int64, exists bool) {
	v := m.locationChanges
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationChanges returns the old locationChanges value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldLocationChanges(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocationChanges is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocationChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationChanges: %w", err)
	}
	return oldValue.LocationChanges, nil
}

// AddLocationChanges adds i to locationChanges.
func (m *BirthSurroundingMutation) AddLocationChanges(i int64) {
	if m.addlocationChanges != nil {
		*m.addlocationChanges += i
	} else {
		m.addlocationChanges = &i
	}
}

// AddedLocationChanges returns the value that was added to the locationChanges field in this mutation.
func (m *BirthSurroundingMutation) AddedLocationChanges() (r int64, exists bool) {
	v := m.addlocationChanges
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationChanges reset all changes of the "locationChanges" field.
func (m *BirthSurroundingMutation) ResetLocationChanges() {
	m.locationChanges = nil
	m.addlocationChanges = nil
}

// SetHairStateId sets the hairStateId field.
func (m *BirthSurroundingMutation) SetHairStateId(i int) {
	m.hairStateId = &i
	m.addhairStateId = nil
}

// HairStateId returns the hairStateId value in the mutation.
func (m *BirthSurroundingMutation) HairStateId() (r int, exists bool) {
	v := m.hairStateId
	if v == nil {
		return
	}
	return *v, true
}

// OldHairStateId returns the old hairStateId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldHairStateId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairStateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairStateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairStateId: %w", err)
	}
	return oldValue.HairStateId, nil
}

// AddHairStateId adds i to hairStateId.
func (m *BirthSurroundingMutation) AddHairStateId(i int) {
	if m.addhairStateId != nil {
		*m.addhairStateId += i
	} else {
		m.addhairStateId = &i
	}
}

// AddedHairStateId returns the value that was added to the hairStateId field in this mutation.
func (m *BirthSurroundingMutation) AddedHairStateId() (r int, exists bool) {
	v := m.addhairStateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetHairStateId reset all changes of the "hairStateId" field.
func (m *BirthSurroundingMutation) ResetHairStateId() {
	m.hairStateId = nil
	m.addhairStateId = nil
}

// SetHairStateName sets the hairStateName field.
func (m *BirthSurroundingMutation) SetHairStateName(s string) {
	m.hairStateName = &s
}

// HairStateName returns the hairStateName value in the mutation.
func (m *BirthSurroundingMutation) HairStateName() (r string, exists bool) {
	v := m.hairStateName
	if v == nil {
		return
	}
	return *v, true
}

// OldHairStateName returns the old hairStateName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldHairStateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairStateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairStateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairStateName: %w", err)
	}
	return oldValue.HairStateName, nil
}

// ResetHairStateName reset all changes of the "hairStateName" field.
func (m *BirthSurroundingMutation) ResetHairStateName() {
	m.hairStateName = nil
}

// SetSoilDepth sets the soilDepth field.
func (m *BirthSurroundingMutation) SetSoilDepth(i int) {
	m.soilDepth = &i
	m.addsoilDepth = nil
}

// SoilDepth returns the soilDepth value in the mutation.
func (m *BirthSurroundingMutation) SoilDepth() (r int, exists bool) {
	v := m.soilDepth
	if v == nil {
		return
	}
	return *v, true
}

// OldSoilDepth returns the old soilDepth value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldSoilDepth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSoilDepth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSoilDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoilDepth: %w", err)
	}
	return oldValue.SoilDepth, nil
}

// AddSoilDepth adds i to soilDepth.
func (m *BirthSurroundingMutation) AddSoilDepth(i int) {
	if m.addsoilDepth != nil {
		*m.addsoilDepth += i
	} else {
		m.addsoilDepth = &i
	}
}

// AddedSoilDepth returns the value that was added to the soilDepth field in this mutation.
func (m *BirthSurroundingMutation) AddedSoilDepth() (r int, exists bool) {
	v := m.addsoilDepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoilDepth reset all changes of the "soilDepth" field.
func (m *BirthSurroundingMutation) ResetSoilDepth() {
	m.soilDepth = nil
	m.addsoilDepth = nil
}

// SetSunExposure sets the sunExposure field.
func (m *BirthSurroundingMutation) SetSunExposure(i int) {
	m.sunExposure = &i
	m.addsunExposure = nil
}

// SunExposure returns the sunExposure value in the mutation.
func (m *BirthSurroundingMutation) SunExposure() (r int, exists bool) {
	v := m.sunExposure
	if v == nil {
		return
	}
	return *v, true
}

// OldSunExposure returns the old sunExposure value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldSunExposure(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSunExposure is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSunExposure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSunExposure: %w", err)
	}
	return oldValue.SunExposure, nil
}

// AddSunExposure adds i to sunExposure.
func (m *BirthSurroundingMutation) AddSunExposure(i int) {
	if m.addsunExposure != nil {
		*m.addsunExposure += i
	} else {
		m.addsunExposure = &i
	}
}

// AddedSunExposure returns the value that was added to the sunExposure field in this mutation.
func (m *BirthSurroundingMutation) AddedSunExposure() (r int, exists bool) {
	v := m.addsunExposure
	if v == nil {
		return
	}
	return *v, true
}

// ResetSunExposure reset all changes of the "sunExposure" field.
func (m *BirthSurroundingMutation) ResetSunExposure() {
	m.sunExposure = nil
	m.addsunExposure = nil
}

// SetWalkDistance sets the walkDistance field.
func (m *BirthSurroundingMutation) SetWalkDistance(i int) {
	m.walkDistance = &i
	m.addwalkDistance = nil
}

// WalkDistance returns the walkDistance value in the mutation.
func (m *BirthSurroundingMutation) WalkDistance() (r int, exists bool) {
	v := m.walkDistance
	if v == nil {
		return
	}
	return *v, true
}

// OldWalkDistance returns the old walkDistance value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWalkDistance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalkDistance is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalkDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalkDistance: %w", err)
	}
	return oldValue.WalkDistance, nil
}

// AddWalkDistance adds i to walkDistance.
func (m *BirthSurroundingMutation) AddWalkDistance(i int) {
	if m.addwalkDistance != nil {
		*m.addwalkDistance += i
	} else {
		m.addwalkDistance = &i
	}
}

// AddedWalkDistance returns the value that was added to the walkDistance field in this mutation.
func (m *BirthSurroundingMutation) AddedWalkDistance() (r int, exists bool) {
	v := m.addwalkDistance
	if v == nil {
		return
	}
	return *v, true
}

// ResetWalkDistance reset all changes of the "walkDistance" field.
func (m *BirthSurroundingMutation) ResetWalkDistance() {
	m.walkDistance = nil
	m.addwalkDistance = nil
}

// SetRained sets the rained field.
func (m *BirthSurroundingMutation) SetRained(i int) {
	m.rained = &i
	m.addrained = nil
}

// Rained returns the rained value in the mutation.
func (m *BirthSurroundingMutation) Rained() (r int, exists bool) {
	v := m.rained
	if v == nil {
		return
	}
	return *v, true
}

// OldRained returns the old rained value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldRained(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRained is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRained requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRained: %w", err)
	}
	return oldValue.Rained, nil
}

// AddRained adds i to rained.
func (m *BirthSurroundingMutation) AddRained(i int) {
	if m.addrained != nil {
		*m.addrained += i
	} else {
		m.addrained = &i
	}
}

// AddedRained returns the value that was added to the rained field in this mutation.
func (m *BirthSurroundingMutation) AddedRained() (r int, exists bool) {
	v := m.addrained
	if v == nil {
		return
	}
	return *v, true
}

// ResetRained reset all changes of the "rained" field.
func (m *BirthSurroundingMutation) ResetRained() {
	m.rained = nil
	m.addrained = nil
}

// SetThIndex sets the thIndex field.
func (m *BirthSurroundingMutation) SetThIndex(f float32) {
	m.thIndex = &f
	m.addthIndex = nil
}

// ThIndex returns the thIndex value in the mutation.
func (m *BirthSurroundingMutation) ThIndex() (r float32, exists bool) {
	v := m.thIndex
	if v == nil {
		return
	}
	return *v, true
}

// OldThIndex returns the old thIndex value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldThIndex(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThIndex: %w", err)
	}
	return oldValue.ThIndex, nil
}

// AddThIndex adds f to thIndex.
func (m *BirthSurroundingMutation) AddThIndex(f float32) {
	if m.addthIndex != nil {
		*m.addthIndex += f
	} else {
		m.addthIndex = &f
	}
}

// AddedThIndex returns the value that was added to the thIndex field in this mutation.
func (m *BirthSurroundingMutation) AddedThIndex() (r float32, exists bool) {
	v := m.addthIndex
	if v == nil {
		return
	}
	return *v, true
}

// ResetThIndex reset all changes of the "thIndex" field.
func (m *BirthSurroundingMutation) ResetThIndex() {
	m.thIndex = nil
	m.addthIndex = nil
}

// SetRemarks sets the remarks field.
func (m *BirthSurroundingMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *BirthSurroundingMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *BirthSurroundingMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *BirthSurroundingMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *BirthSurroundingMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *BirthSurroundingMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *BirthSurroundingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *BirthSurroundingMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *BirthSurroundingMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *BirthSurroundingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *BirthSurroundingMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *BirthSurroundingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *BirthSurroundingMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *BirthSurroundingMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *BirthSurroundingMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *BirthSurroundingMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *BirthSurroundingMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *BirthSurroundingMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *BirthSurroundingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BirthSurrounding).
func (m *BirthSurroundingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BirthSurroundingMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.name != nil {
		fields = append(fields, birthsurrounding.FieldName)
	}
	if m.farmId != nil {
		fields = append(fields, birthsurrounding.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, birthsurrounding.FieldFarmName)
	}
	if m.recordTime != nil {
		fields = append(fields, birthsurrounding.FieldRecordTime)
	}
	if m.userId != nil {
		fields = append(fields, birthsurrounding.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, birthsurrounding.FieldUserName)
	}
	if m.temperature != nil {
		fields = append(fields, birthsurrounding.FieldTemperature)
	}
	if m.humidity != nil {
		fields = append(fields, birthsurrounding.FieldHumidity)
	}
	if m.breathRateId != nil {
		fields = append(fields, birthsurrounding.FieldBreathRateId)
	}
	if m.breathRateName != nil {
		fields = append(fields, birthsurrounding.FieldBreathRateName)
	}
	if m.windSpeed != nil {
		fields = append(fields, birthsurrounding.FieldWindSpeed)
	}
	if m.windDirectionId != nil {
		fields = append(fields, birthsurrounding.FieldWindDirectionId)
	}
	if m.windDirection != nil {
		fields = append(fields, birthsurrounding.FieldWindDirection)
	}
	if m.locationChanges != nil {
		fields = append(fields, birthsurrounding.FieldLocationChanges)
	}
	if m.hairStateId != nil {
		fields = append(fields, birthsurrounding.FieldHairStateId)
	}
	if m.hairStateName != nil {
		fields = append(fields, birthsurrounding.FieldHairStateName)
	}
	if m.soilDepth != nil {
		fields = append(fields, birthsurrounding.FieldSoilDepth)
	}
	if m.sunExposure != nil {
		fields = append(fields, birthsurrounding.FieldSunExposure)
	}
	if m.walkDistance != nil {
		fields = append(fields, birthsurrounding.FieldWalkDistance)
	}
	if m.rained != nil {
		fields = append(fields, birthsurrounding.FieldRained)
	}
	if m.thIndex != nil {
		fields = append(fields, birthsurrounding.FieldThIndex)
	}
	if m.remarks != nil {
		fields = append(fields, birthsurrounding.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, birthsurrounding.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, birthsurrounding.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, birthsurrounding.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BirthSurroundingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case birthsurrounding.FieldName:
		return m.Name()
	case birthsurrounding.FieldFarmId:
		return m.FarmId()
	case birthsurrounding.FieldFarmName:
		return m.FarmName()
	case birthsurrounding.FieldRecordTime:
		return m.RecordTime()
	case birthsurrounding.FieldUserId:
		return m.UserId()
	case birthsurrounding.FieldUserName:
		return m.UserName()
	case birthsurrounding.FieldTemperature:
		return m.Temperature()
	case birthsurrounding.FieldHumidity:
		return m.Humidity()
	case birthsurrounding.FieldBreathRateId:
		return m.BreathRateId()
	case birthsurrounding.FieldBreathRateName:
		return m.BreathRateName()
	case birthsurrounding.FieldWindSpeed:
		return m.WindSpeed()
	case birthsurrounding.FieldWindDirectionId:
		return m.WindDirectionId()
	case birthsurrounding.FieldWindDirection:
		return m.WindDirection()
	case birthsurrounding.FieldLocationChanges:
		return m.LocationChanges()
	case birthsurrounding.FieldHairStateId:
		return m.HairStateId()
	case birthsurrounding.FieldHairStateName:
		return m.HairStateName()
	case birthsurrounding.FieldSoilDepth:
		return m.SoilDepth()
	case birthsurrounding.FieldSunExposure:
		return m.SunExposure()
	case birthsurrounding.FieldWalkDistance:
		return m.WalkDistance()
	case birthsurrounding.FieldRained:
		return m.Rained()
	case birthsurrounding.FieldThIndex:
		return m.ThIndex()
	case birthsurrounding.FieldRemarks:
		return m.Remarks()
	case birthsurrounding.FieldCreatedAt:
		return m.CreatedAt()
	case birthsurrounding.FieldUpdatedAt:
		return m.UpdatedAt()
	case birthsurrounding.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BirthSurroundingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case birthsurrounding.FieldName:
		return m.OldName(ctx)
	case birthsurrounding.FieldFarmId:
		return m.OldFarmId(ctx)
	case birthsurrounding.FieldFarmName:
		return m.OldFarmName(ctx)
	case birthsurrounding.FieldRecordTime:
		return m.OldRecordTime(ctx)
	case birthsurrounding.FieldUserId:
		return m.OldUserId(ctx)
	case birthsurrounding.FieldUserName:
		return m.OldUserName(ctx)
	case birthsurrounding.FieldTemperature:
		return m.OldTemperature(ctx)
	case birthsurrounding.FieldHumidity:
		return m.OldHumidity(ctx)
	case birthsurrounding.FieldBreathRateId:
		return m.OldBreathRateId(ctx)
	case birthsurrounding.FieldBreathRateName:
		return m.OldBreathRateName(ctx)
	case birthsurrounding.FieldWindSpeed:
		return m.OldWindSpeed(ctx)
	case birthsurrounding.FieldWindDirectionId:
		return m.OldWindDirectionId(ctx)
	case birthsurrounding.FieldWindDirection:
		return m.OldWindDirection(ctx)
	case birthsurrounding.FieldLocationChanges:
		return m.OldLocationChanges(ctx)
	case birthsurrounding.FieldHairStateId:
		return m.OldHairStateId(ctx)
	case birthsurrounding.FieldHairStateName:
		return m.OldHairStateName(ctx)
	case birthsurrounding.FieldSoilDepth:
		return m.OldSoilDepth(ctx)
	case birthsurrounding.FieldSunExposure:
		return m.OldSunExposure(ctx)
	case birthsurrounding.FieldWalkDistance:
		return m.OldWalkDistance(ctx)
	case birthsurrounding.FieldRained:
		return m.OldRained(ctx)
	case birthsurrounding.FieldThIndex:
		return m.OldThIndex(ctx)
	case birthsurrounding.FieldRemarks:
		return m.OldRemarks(ctx)
	case birthsurrounding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case birthsurrounding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case birthsurrounding.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown BirthSurrounding field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BirthSurroundingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case birthsurrounding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case birthsurrounding.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case birthsurrounding.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case birthsurrounding.FieldRecordTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordTime(v)
		return nil
	case birthsurrounding.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case birthsurrounding.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case birthsurrounding.FieldTemperature:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case birthsurrounding.FieldHumidity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHumidity(v)
		return nil
	case birthsurrounding.FieldBreathRateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreathRateId(v)
		return nil
	case birthsurrounding.FieldBreathRateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreathRateName(v)
		return nil
	case birthsurrounding.FieldWindSpeed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindSpeed(v)
		return nil
	case birthsurrounding.FieldWindDirectionId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirectionId(v)
		return nil
	case birthsurrounding.FieldWindDirection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirection(v)
		return nil
	case birthsurrounding.FieldLocationChanges:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationChanges(v)
		return nil
	case birthsurrounding.FieldHairStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairStateId(v)
		return nil
	case birthsurrounding.FieldHairStateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairStateName(v)
		return nil
	case birthsurrounding.FieldSoilDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoilDepth(v)
		return nil
	case birthsurrounding.FieldSunExposure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSunExposure(v)
		return nil
	case birthsurrounding.FieldWalkDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalkDistance(v)
		return nil
	case birthsurrounding.FieldRained:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRained(v)
		return nil
	case birthsurrounding.FieldThIndex:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThIndex(v)
		return nil
	case birthsurrounding.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case birthsurrounding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case birthsurrounding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case birthsurrounding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown BirthSurrounding field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BirthSurroundingMutation) AddedFields() []string {
	var fields []string
	if m.addfarmId != nil {
		fields = append(fields, birthsurrounding.FieldFarmId)
	}
	if m.addrecordTime != nil {
		fields = append(fields, birthsurrounding.FieldRecordTime)
	}
	if m.adduserId != nil {
		fields = append(fields, birthsurrounding.FieldUserId)
	}
	if m.addtemperature != nil {
		fields = append(fields, birthsurrounding.FieldTemperature)
	}
	if m.addhumidity != nil {
		fields = append(fields, birthsurrounding.FieldHumidity)
	}
	if m.addbreathRateId != nil {
		fields = append(fields, birthsurrounding.FieldBreathRateId)
	}
	if m.addwindSpeed != nil {
		fields = append(fields, birthsurrounding.FieldWindSpeed)
	}
	if m.addwindDirectionId != nil {
		fields = append(fields, birthsurrounding.FieldWindDirectionId)
	}
	if m.addlocationChanges != nil {
		fields = append(fields, birthsurrounding.FieldLocationChanges)
	}
	if m.addhairStateId != nil {
		fields = append(fields, birthsurrounding.FieldHairStateId)
	}
	if m.addsoilDepth != nil {
		fields = append(fields, birthsurrounding.FieldSoilDepth)
	}
	if m.addsunExposure != nil {
		fields = append(fields, birthsurrounding.FieldSunExposure)
	}
	if m.addwalkDistance != nil {
		fields = append(fields, birthsurrounding.FieldWalkDistance)
	}
	if m.addrained != nil {
		fields = append(fields, birthsurrounding.FieldRained)
	}
	if m.addthIndex != nil {
		fields = append(fields, birthsurrounding.FieldThIndex)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, birthsurrounding.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, birthsurrounding.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, birthsurrounding.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BirthSurroundingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case birthsurrounding.FieldFarmId:
		return m.AddedFarmId()
	case birthsurrounding.FieldRecordTime:
		return m.AddedRecordTime()
	case birthsurrounding.FieldUserId:
		return m.AddedUserId()
	case birthsurrounding.FieldTemperature:
		return m.AddedTemperature()
	case birthsurrounding.FieldHumidity:
		return m.AddedHumidity()
	case birthsurrounding.FieldBreathRateId:
		return m.AddedBreathRateId()
	case birthsurrounding.FieldWindSpeed:
		return m.AddedWindSpeed()
	case birthsurrounding.FieldWindDirectionId:
		return m.AddedWindDirectionId()
	case birthsurrounding.FieldLocationChanges:
		return m.AddedLocationChanges()
	case birthsurrounding.FieldHairStateId:
		return m.AddedHairStateId()
	case birthsurrounding.FieldSoilDepth:
		return m.AddedSoilDepth()
	case birthsurrounding.FieldSunExposure:
		return m.AddedSunExposure()
	case birthsurrounding.FieldWalkDistance:
		return m.AddedWalkDistance()
	case birthsurrounding.FieldRained:
		return m.AddedRained()
	case birthsurrounding.FieldThIndex:
		return m.AddedThIndex()
	case birthsurrounding.FieldCreatedAt:
		return m.AddedCreatedAt()
	case birthsurrounding.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case birthsurrounding.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BirthSurroundingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case birthsurrounding.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case birthsurrounding.FieldRecordTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecordTime(v)
		return nil
	case birthsurrounding.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case birthsurrounding.FieldTemperature:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case birthsurrounding.FieldHumidity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHumidity(v)
		return nil
	case birthsurrounding.FieldBreathRateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreathRateId(v)
		return nil
	case birthsurrounding.FieldWindSpeed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindSpeed(v)
		return nil
	case birthsurrounding.FieldWindDirectionId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindDirectionId(v)
		return nil
	case birthsurrounding.FieldLocationChanges:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationChanges(v)
		return nil
	case birthsurrounding.FieldHairStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHairStateId(v)
		return nil
	case birthsurrounding.FieldSoilDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoilDepth(v)
		return nil
	case birthsurrounding.FieldSunExposure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSunExposure(v)
		return nil
	case birthsurrounding.FieldWalkDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalkDistance(v)
		return nil
	case birthsurrounding.FieldRained:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRained(v)
		return nil
	case birthsurrounding.FieldThIndex:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThIndex(v)
		return nil
	case birthsurrounding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case birthsurrounding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case birthsurrounding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown BirthSurrounding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BirthSurroundingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BirthSurroundingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BirthSurroundingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BirthSurrounding nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BirthSurroundingMutation) ResetField(name string) error {
	switch name {
	case birthsurrounding.FieldName:
		m.ResetName()
		return nil
	case birthsurrounding.FieldFarmId:
		m.ResetFarmId()
		return nil
	case birthsurrounding.FieldFarmName:
		m.ResetFarmName()
		return nil
	case birthsurrounding.FieldRecordTime:
		m.ResetRecordTime()
		return nil
	case birthsurrounding.FieldUserId:
		m.ResetUserId()
		return nil
	case birthsurrounding.FieldUserName:
		m.ResetUserName()
		return nil
	case birthsurrounding.FieldTemperature:
		m.ResetTemperature()
		return nil
	case birthsurrounding.FieldHumidity:
		m.ResetHumidity()
		return nil
	case birthsurrounding.FieldBreathRateId:
		m.ResetBreathRateId()
		return nil
	case birthsurrounding.FieldBreathRateName:
		m.ResetBreathRateName()
		return nil
	case birthsurrounding.FieldWindSpeed:
		m.ResetWindSpeed()
		return nil
	case birthsurrounding.FieldWindDirectionId:
		m.ResetWindDirectionId()
		return nil
	case birthsurrounding.FieldWindDirection:
		m.ResetWindDirection()
		return nil
	case birthsurrounding.FieldLocationChanges:
		m.ResetLocationChanges()
		return nil
	case birthsurrounding.FieldHairStateId:
		m.ResetHairStateId()
		return nil
	case birthsurrounding.FieldHairStateName:
		m.ResetHairStateName()
		return nil
	case birthsurrounding.FieldSoilDepth:
		m.ResetSoilDepth()
		return nil
	case birthsurrounding.FieldSunExposure:
		m.ResetSunExposure()
		return nil
	case birthsurrounding.FieldWalkDistance:
		m.ResetWalkDistance()
		return nil
	case birthsurrounding.FieldRained:
		m.ResetRained()
		return nil
	case birthsurrounding.FieldThIndex:
		m.ResetThIndex()
		return nil
	case birthsurrounding.FieldRemarks:
		m.ResetRemarks()
		return nil
	case birthsurrounding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case birthsurrounding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case birthsurrounding.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown BirthSurrounding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BirthSurroundingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BirthSurroundingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BirthSurroundingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BirthSurroundingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BirthSurroundingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BirthSurroundingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BirthSurroundingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BirthSurrounding unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BirthSurroundingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BirthSurrounding edge %s", name)
}

// BreathRateMutation represents an operation that mutate the BreathRates
// nodes in the graph.
type BreathRateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BreathRate, error)
}

var _ ent.Mutation = (*BreathRateMutation)(nil)

// breathrateOption allows to manage the mutation configuration using functional options.
type breathrateOption func(*BreathRateMutation)

// newBreathRateMutation creates new mutation for $n.Name.
func newBreathRateMutation(c config, op Op, opts ...breathrateOption) *BreathRateMutation {
	m := &BreathRateMutation{
		config:        c,
		op:            op,
		typ:           TypeBreathRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBreathRateID sets the id field of the mutation.
func withBreathRateID(id int64) breathrateOption {
	return func(m *BreathRateMutation) {
		var (
			err   error
			once  sync.Once
			value *BreathRate
		)
		m.oldValue = func(ctx context.Context) (*BreathRate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BreathRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBreathRate sets the old BreathRate of the mutation.
func withBreathRate(node *BreathRate) breathrateOption {
	return func(m *BreathRateMutation) {
		m.oldValue = func(context.Context) (*BreathRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BreathRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BreathRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BreathRateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *BreathRateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BreathRateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the BreathRate.
// If the BreathRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreathRateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BreathRateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *BreathRateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BreathRate).
func (m *BreathRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BreathRateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, breathrate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BreathRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case breathrate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BreathRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case breathrate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown BreathRate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreathRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case breathrate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown BreathRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BreathRateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BreathRateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreathRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BreathRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BreathRateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BreathRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BreathRateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BreathRate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BreathRateMutation) ResetField(name string) error {
	switch name {
	case breathrate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown BreathRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BreathRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BreathRateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BreathRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BreathRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BreathRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BreathRateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BreathRateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BreathRate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BreathRateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BreathRate edge %s", name)
}

// BreedingMutation represents an operation that mutate the Breedings
// nodes in the graph.
type BreedingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	name                 *string
	earNumber            *string
	times                *int
	addtimes             *int
	breedingAt           *int64
	addbreedingAt        *int64
	breedingTypeId       *int
	addbreedingTypeId    *int
	breedingTypeName     *string
	semenFrozenTypeId    *int64
	addsemenFrozenTypeId *int64
	semenFrozenTypeName  *string
	bullId               *string
	shedName             *string
	count                *int
	addcount             *int
	userName             *string
	remarks              *string
	createdAt            *int64
	addcreatedAt         *int64
	updatedAt            *int64
	addupdatedAt         *int64
	deleted              *int
	adddeleted           *int
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Breeding, error)
}

var _ ent.Mutation = (*BreedingMutation)(nil)

// breedingOption allows to manage the mutation configuration using functional options.
type breedingOption func(*BreedingMutation)

// newBreedingMutation creates new mutation for $n.Name.
func newBreedingMutation(c config, op Op, opts ...breedingOption) *BreedingMutation {
	m := &BreedingMutation{
		config:        c,
		op:            op,
		typ:           TypeBreeding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBreedingID sets the id field of the mutation.
func withBreedingID(id int64) breedingOption {
	return func(m *BreedingMutation) {
		var (
			err   error
			once  sync.Once
			value *Breeding
		)
		m.oldValue = func(ctx context.Context) (*Breeding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Breeding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBreeding sets the old Breeding of the mutation.
func withBreeding(node *Breeding) breedingOption {
	return func(m *BreedingMutation) {
		m.oldValue = func(context.Context) (*Breeding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BreedingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BreedingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BreedingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *BreedingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BreedingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *BreedingMutation) ClearName() {
	m.name = nil
	m.clearedFields[breeding.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *BreedingMutation) NameCleared() bool {
	_, ok := m.clearedFields[breeding.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *BreedingMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, breeding.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *BreedingMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *BreedingMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *BreedingMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *BreedingMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *BreedingMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *BreedingMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *BreedingMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *BreedingMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetBreedingAt sets the breedingAt field.
func (m *BreedingMutation) SetBreedingAt(i int64) {
	m.breedingAt = &i
	m.addbreedingAt = nil
}

// BreedingAt returns the breedingAt value in the mutation.
func (m *BreedingMutation) BreedingAt() (r int64, exists bool) {
	v := m.breedingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingAt returns the old breedingAt value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBreedingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingAt: %w", err)
	}
	return oldValue.BreedingAt, nil
}

// AddBreedingAt adds i to breedingAt.
func (m *BreedingMutation) AddBreedingAt(i int64) {
	if m.addbreedingAt != nil {
		*m.addbreedingAt += i
	} else {
		m.addbreedingAt = &i
	}
}

// AddedBreedingAt returns the value that was added to the breedingAt field in this mutation.
func (m *BreedingMutation) AddedBreedingAt() (r int64, exists bool) {
	v := m.addbreedingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingAt reset all changes of the "breedingAt" field.
func (m *BreedingMutation) ResetBreedingAt() {
	m.breedingAt = nil
	m.addbreedingAt = nil
}

// SetBreedingTypeId sets the breedingTypeId field.
func (m *BreedingMutation) SetBreedingTypeId(i int) {
	m.breedingTypeId = &i
	m.addbreedingTypeId = nil
}

// BreedingTypeId returns the breedingTypeId value in the mutation.
func (m *BreedingMutation) BreedingTypeId() (r int, exists bool) {
	v := m.breedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeId returns the old breedingTypeId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBreedingTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeId: %w", err)
	}
	return oldValue.BreedingTypeId, nil
}

// AddBreedingTypeId adds i to breedingTypeId.
func (m *BreedingMutation) AddBreedingTypeId(i int) {
	if m.addbreedingTypeId != nil {
		*m.addbreedingTypeId += i
	} else {
		m.addbreedingTypeId = &i
	}
}

// AddedBreedingTypeId returns the value that was added to the breedingTypeId field in this mutation.
func (m *BreedingMutation) AddedBreedingTypeId() (r int, exists bool) {
	v := m.addbreedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingTypeId reset all changes of the "breedingTypeId" field.
func (m *BreedingMutation) ResetBreedingTypeId() {
	m.breedingTypeId = nil
	m.addbreedingTypeId = nil
}

// SetBreedingTypeName sets the breedingTypeName field.
func (m *BreedingMutation) SetBreedingTypeName(s string) {
	m.breedingTypeName = &s
}

// BreedingTypeName returns the breedingTypeName value in the mutation.
func (m *BreedingMutation) BreedingTypeName() (r string, exists bool) {
	v := m.breedingTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeName returns the old breedingTypeName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBreedingTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeName: %w", err)
	}
	return oldValue.BreedingTypeName, nil
}

// ResetBreedingTypeName reset all changes of the "breedingTypeName" field.
func (m *BreedingMutation) ResetBreedingTypeName() {
	m.breedingTypeName = nil
}

// SetSemenFrozenTypeId sets the semenFrozenTypeId field.
func (m *BreedingMutation) SetSemenFrozenTypeId(i int64) {
	m.semenFrozenTypeId = &i
	m.addsemenFrozenTypeId = nil
}

// SemenFrozenTypeId returns the semenFrozenTypeId value in the mutation.
func (m *BreedingMutation) SemenFrozenTypeId() (r int64, exists bool) {
	v := m.semenFrozenTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldSemenFrozenTypeId returns the old semenFrozenTypeId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldSemenFrozenTypeId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemenFrozenTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemenFrozenTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemenFrozenTypeId: %w", err)
	}
	return oldValue.SemenFrozenTypeId, nil
}

// AddSemenFrozenTypeId adds i to semenFrozenTypeId.
func (m *BreedingMutation) AddSemenFrozenTypeId(i int64) {
	if m.addsemenFrozenTypeId != nil {
		*m.addsemenFrozenTypeId += i
	} else {
		m.addsemenFrozenTypeId = &i
	}
}

// AddedSemenFrozenTypeId returns the value that was added to the semenFrozenTypeId field in this mutation.
func (m *BreedingMutation) AddedSemenFrozenTypeId() (r int64, exists bool) {
	v := m.addsemenFrozenTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetSemenFrozenTypeId reset all changes of the "semenFrozenTypeId" field.
func (m *BreedingMutation) ResetSemenFrozenTypeId() {
	m.semenFrozenTypeId = nil
	m.addsemenFrozenTypeId = nil
}

// SetSemenFrozenTypeName sets the semenFrozenTypeName field.
func (m *BreedingMutation) SetSemenFrozenTypeName(s string) {
	m.semenFrozenTypeName = &s
}

// SemenFrozenTypeName returns the semenFrozenTypeName value in the mutation.
func (m *BreedingMutation) SemenFrozenTypeName() (r string, exists bool) {
	v := m.semenFrozenTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldSemenFrozenTypeName returns the old semenFrozenTypeName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldSemenFrozenTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemenFrozenTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemenFrozenTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemenFrozenTypeName: %w", err)
	}
	return oldValue.SemenFrozenTypeName, nil
}

// ResetSemenFrozenTypeName reset all changes of the "semenFrozenTypeName" field.
func (m *BreedingMutation) ResetSemenFrozenTypeName() {
	m.semenFrozenTypeName = nil
}

// SetBullId sets the bullId field.
func (m *BreedingMutation) SetBullId(s string) {
	m.bullId = &s
}

// BullId returns the bullId value in the mutation.
func (m *BreedingMutation) BullId() (r string, exists bool) {
	v := m.bullId
	if v == nil {
		return
	}
	return *v, true
}

// OldBullId returns the old bullId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBullId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBullId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBullId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBullId: %w", err)
	}
	return oldValue.BullId, nil
}

// ResetBullId reset all changes of the "bullId" field.
func (m *BreedingMutation) ResetBullId() {
	m.bullId = nil
}

// SetShedName sets the shedName field.
func (m *BreedingMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *BreedingMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *BreedingMutation) ResetShedName() {
	m.shedName = nil
}

// SetCount sets the count field.
func (m *BreedingMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *BreedingMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to count.
func (m *BreedingMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *BreedingMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *BreedingMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetUserName sets the userName field.
func (m *BreedingMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *BreedingMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *BreedingMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *BreedingMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *BreedingMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *BreedingMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *BreedingMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *BreedingMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *BreedingMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *BreedingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *BreedingMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *BreedingMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *BreedingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *BreedingMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *BreedingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *BreedingMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *BreedingMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *BreedingMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *BreedingMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *BreedingMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *BreedingMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *BreedingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Breeding).
func (m *BreedingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BreedingMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.name != nil {
		fields = append(fields, breeding.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, breeding.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, breeding.FieldTimes)
	}
	if m.breedingAt != nil {
		fields = append(fields, breeding.FieldBreedingAt)
	}
	if m.breedingTypeId != nil {
		fields = append(fields, breeding.FieldBreedingTypeId)
	}
	if m.breedingTypeName != nil {
		fields = append(fields, breeding.FieldBreedingTypeName)
	}
	if m.semenFrozenTypeId != nil {
		fields = append(fields, breeding.FieldSemenFrozenTypeId)
	}
	if m.semenFrozenTypeName != nil {
		fields = append(fields, breeding.FieldSemenFrozenTypeName)
	}
	if m.bullId != nil {
		fields = append(fields, breeding.FieldBullId)
	}
	if m.shedName != nil {
		fields = append(fields, breeding.FieldShedName)
	}
	if m.count != nil {
		fields = append(fields, breeding.FieldCount)
	}
	if m.userName != nil {
		fields = append(fields, breeding.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, breeding.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, breeding.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, breeding.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, breeding.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BreedingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case breeding.FieldName:
		return m.Name()
	case breeding.FieldEarNumber:
		return m.EarNumber()
	case breeding.FieldTimes:
		return m.Times()
	case breeding.FieldBreedingAt:
		return m.BreedingAt()
	case breeding.FieldBreedingTypeId:
		return m.BreedingTypeId()
	case breeding.FieldBreedingTypeName:
		return m.BreedingTypeName()
	case breeding.FieldSemenFrozenTypeId:
		return m.SemenFrozenTypeId()
	case breeding.FieldSemenFrozenTypeName:
		return m.SemenFrozenTypeName()
	case breeding.FieldBullId:
		return m.BullId()
	case breeding.FieldShedName:
		return m.ShedName()
	case breeding.FieldCount:
		return m.Count()
	case breeding.FieldUserName:
		return m.UserName()
	case breeding.FieldRemarks:
		return m.Remarks()
	case breeding.FieldCreatedAt:
		return m.CreatedAt()
	case breeding.FieldUpdatedAt:
		return m.UpdatedAt()
	case breeding.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BreedingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case breeding.FieldName:
		return m.OldName(ctx)
	case breeding.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case breeding.FieldTimes:
		return m.OldTimes(ctx)
	case breeding.FieldBreedingAt:
		return m.OldBreedingAt(ctx)
	case breeding.FieldBreedingTypeId:
		return m.OldBreedingTypeId(ctx)
	case breeding.FieldBreedingTypeName:
		return m.OldBreedingTypeName(ctx)
	case breeding.FieldSemenFrozenTypeId:
		return m.OldSemenFrozenTypeId(ctx)
	case breeding.FieldSemenFrozenTypeName:
		return m.OldSemenFrozenTypeName(ctx)
	case breeding.FieldBullId:
		return m.OldBullId(ctx)
	case breeding.FieldShedName:
		return m.OldShedName(ctx)
	case breeding.FieldCount:
		return m.OldCount(ctx)
	case breeding.FieldUserName:
		return m.OldUserName(ctx)
	case breeding.FieldRemarks:
		return m.OldRemarks(ctx)
	case breeding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case breeding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case breeding.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Breeding field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case breeding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case breeding.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case breeding.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case breeding.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingAt(v)
		return nil
	case breeding.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeId(v)
		return nil
	case breeding.FieldBreedingTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeName(v)
		return nil
	case breeding.FieldSemenFrozenTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemenFrozenTypeId(v)
		return nil
	case breeding.FieldSemenFrozenTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemenFrozenTypeName(v)
		return nil
	case breeding.FieldBullId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBullId(v)
		return nil
	case breeding.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case breeding.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case breeding.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case breeding.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case breeding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case breeding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case breeding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Breeding field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BreedingMutation) AddedFields() []string {
	var fields []string
	if m.addtimes != nil {
		fields = append(fields, breeding.FieldTimes)
	}
	if m.addbreedingAt != nil {
		fields = append(fields, breeding.FieldBreedingAt)
	}
	if m.addbreedingTypeId != nil {
		fields = append(fields, breeding.FieldBreedingTypeId)
	}
	if m.addsemenFrozenTypeId != nil {
		fields = append(fields, breeding.FieldSemenFrozenTypeId)
	}
	if m.addcount != nil {
		fields = append(fields, breeding.FieldCount)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, breeding.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, breeding.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, breeding.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BreedingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case breeding.FieldTimes:
		return m.AddedTimes()
	case breeding.FieldBreedingAt:
		return m.AddedBreedingAt()
	case breeding.FieldBreedingTypeId:
		return m.AddedBreedingTypeId()
	case breeding.FieldSemenFrozenTypeId:
		return m.AddedSemenFrozenTypeId()
	case breeding.FieldCount:
		return m.AddedCount()
	case breeding.FieldCreatedAt:
		return m.AddedCreatedAt()
	case breeding.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case breeding.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case breeding.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case breeding.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingAt(v)
		return nil
	case breeding.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingTypeId(v)
		return nil
	case breeding.FieldSemenFrozenTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSemenFrozenTypeId(v)
		return nil
	case breeding.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case breeding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case breeding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case breeding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Breeding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BreedingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(breeding.FieldName) {
		fields = append(fields, breeding.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BreedingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BreedingMutation) ClearField(name string) error {
	switch name {
	case breeding.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Breeding nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BreedingMutation) ResetField(name string) error {
	switch name {
	case breeding.FieldName:
		m.ResetName()
		return nil
	case breeding.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case breeding.FieldTimes:
		m.ResetTimes()
		return nil
	case breeding.FieldBreedingAt:
		m.ResetBreedingAt()
		return nil
	case breeding.FieldBreedingTypeId:
		m.ResetBreedingTypeId()
		return nil
	case breeding.FieldBreedingTypeName:
		m.ResetBreedingTypeName()
		return nil
	case breeding.FieldSemenFrozenTypeId:
		m.ResetSemenFrozenTypeId()
		return nil
	case breeding.FieldSemenFrozenTypeName:
		m.ResetSemenFrozenTypeName()
		return nil
	case breeding.FieldBullId:
		m.ResetBullId()
		return nil
	case breeding.FieldShedName:
		m.ResetShedName()
		return nil
	case breeding.FieldCount:
		m.ResetCount()
		return nil
	case breeding.FieldUserName:
		m.ResetUserName()
		return nil
	case breeding.FieldRemarks:
		m.ResetRemarks()
		return nil
	case breeding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case breeding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case breeding.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Breeding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BreedingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BreedingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BreedingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BreedingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BreedingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BreedingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BreedingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Breeding unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BreedingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Breeding edge %s", name)
}

// BreedingTypeMutation represents an operation that mutate the BreedingTypes
// nodes in the graph.
type BreedingTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BreedingType, error)
}

var _ ent.Mutation = (*BreedingTypeMutation)(nil)

// breedingtypeOption allows to manage the mutation configuration using functional options.
type breedingtypeOption func(*BreedingTypeMutation)

// newBreedingTypeMutation creates new mutation for $n.Name.
func newBreedingTypeMutation(c config, op Op, opts ...breedingtypeOption) *BreedingTypeMutation {
	m := &BreedingTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBreedingType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBreedingTypeID sets the id field of the mutation.
func withBreedingTypeID(id int64) breedingtypeOption {
	return func(m *BreedingTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *BreedingType
		)
		m.oldValue = func(ctx context.Context) (*BreedingType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BreedingType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBreedingType sets the old BreedingType of the mutation.
func withBreedingType(node *BreedingType) breedingtypeOption {
	return func(m *BreedingTypeMutation) {
		m.oldValue = func(context.Context) (*BreedingType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BreedingTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BreedingTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BreedingTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *BreedingTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BreedingTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the BreedingType.
// If the BreedingType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BreedingTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *BreedingTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BreedingType).
func (m *BreedingTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BreedingTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, breedingtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BreedingTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case breedingtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BreedingTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case breedingtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown BreedingType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case breedingtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown BreedingType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BreedingTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BreedingTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BreedingType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BreedingTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BreedingTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BreedingTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BreedingType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BreedingTypeMutation) ResetField(name string) error {
	switch name {
	case breedingtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown BreedingType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BreedingTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BreedingTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BreedingTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BreedingTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BreedingTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BreedingTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BreedingTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BreedingType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BreedingTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BreedingType edge %s", name)
}

// CalveMutation represents an operation that mutate the Calves
// nodes in the graph.
type CalveMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	earNumber          *string
	times              *int
	addtimes           *int
	pregnantAt         *int64
	addpregnantAt      *int64
	calveAt            *int64
	addcalveAt         *int64
	calveTypeId        *int
	addcalveTypeId     *int
	calveTypeName      *string
	calveCate          *int
	addcalveCate       *int
	calveCountId       *int
	addcalveCountId    *int
	calveCountName     *string
	complexity         *int
	addcomplexity      *int
	userName           *string
	babyStatus         *int
	addbabyStatus      *int
	babyGender         *int
	addbabyGender      *int
	babyEarNumber      *int
	addbabyEarNumber   *int
	babyBreedId        *int
	addbabyBreedId     *int
	babyBreedName      *string
	babyHairColorId    *int
	addbabyHairColorId *int
	babyHairColorName  *string
	babyWeight         *float32
	addbabyWeight      *float32
	babyShedId         *int
	addbabyShedId      *int
	babyShedName       *string
	remarks            *string
	createdAt          *int64
	addcreatedAt       *int64
	updatedAt          *int64
	addupdatedAt       *int64
	deleted            *int
	adddeleted         *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Calve, error)
}

var _ ent.Mutation = (*CalveMutation)(nil)

// calveOption allows to manage the mutation configuration using functional options.
type calveOption func(*CalveMutation)

// newCalveMutation creates new mutation for $n.Name.
func newCalveMutation(c config, op Op, opts ...calveOption) *CalveMutation {
	m := &CalveMutation{
		config:        c,
		op:            op,
		typ:           TypeCalve,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalveID sets the id field of the mutation.
func withCalveID(id int64) calveOption {
	return func(m *CalveMutation) {
		var (
			err   error
			once  sync.Once
			value *Calve
		)
		m.oldValue = func(ctx context.Context) (*Calve, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Calve.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalve sets the old Calve of the mutation.
func withCalve(node *Calve) calveOption {
	return func(m *CalveMutation) {
		m.oldValue = func(context.Context) (*Calve, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CalveMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CalveMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CalveMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CalveMutation) ClearName() {
	m.name = nil
	m.clearedFields[calve.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CalveMutation) NameCleared() bool {
	_, ok := m.clearedFields[calve.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CalveMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, calve.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CalveMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CalveMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CalveMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *CalveMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *CalveMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *CalveMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *CalveMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *CalveMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetPregnantAt sets the pregnantAt field.
func (m *CalveMutation) SetPregnantAt(i int64) {
	m.pregnantAt = &i
	m.addpregnantAt = nil
}

// PregnantAt returns the pregnantAt value in the mutation.
func (m *CalveMutation) PregnantAt() (r int64, exists bool) {
	v := m.pregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnantAt returns the old pregnantAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldPregnantAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnantAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnantAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnantAt: %w", err)
	}
	return oldValue.PregnantAt, nil
}

// AddPregnantAt adds i to pregnantAt.
func (m *CalveMutation) AddPregnantAt(i int64) {
	if m.addpregnantAt != nil {
		*m.addpregnantAt += i
	} else {
		m.addpregnantAt = &i
	}
}

// AddedPregnantAt returns the value that was added to the pregnantAt field in this mutation.
func (m *CalveMutation) AddedPregnantAt() (r int64, exists bool) {
	v := m.addpregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnantAt reset all changes of the "pregnantAt" field.
func (m *CalveMutation) ResetPregnantAt() {
	m.pregnantAt = nil
	m.addpregnantAt = nil
}

// SetCalveAt sets the calveAt field.
func (m *CalveMutation) SetCalveAt(i int64) {
	m.calveAt = &i
	m.addcalveAt = nil
}

// CalveAt returns the calveAt value in the mutation.
func (m *CalveMutation) CalveAt() (r int64, exists bool) {
	v := m.calveAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveAt returns the old calveAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveAt: %w", err)
	}
	return oldValue.CalveAt, nil
}

// AddCalveAt adds i to calveAt.
func (m *CalveMutation) AddCalveAt(i int64) {
	if m.addcalveAt != nil {
		*m.addcalveAt += i
	} else {
		m.addcalveAt = &i
	}
}

// AddedCalveAt returns the value that was added to the calveAt field in this mutation.
func (m *CalveMutation) AddedCalveAt() (r int64, exists bool) {
	v := m.addcalveAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveAt reset all changes of the "calveAt" field.
func (m *CalveMutation) ResetCalveAt() {
	m.calveAt = nil
	m.addcalveAt = nil
}

// SetCalveTypeId sets the calveTypeId field.
func (m *CalveMutation) SetCalveTypeId(i int) {
	m.calveTypeId = &i
	m.addcalveTypeId = nil
}

// CalveTypeId returns the calveTypeId value in the mutation.
func (m *CalveMutation) CalveTypeId() (r int, exists bool) {
	v := m.calveTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveTypeId returns the old calveTypeId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveTypeId: %w", err)
	}
	return oldValue.CalveTypeId, nil
}

// AddCalveTypeId adds i to calveTypeId.
func (m *CalveMutation) AddCalveTypeId(i int) {
	if m.addcalveTypeId != nil {
		*m.addcalveTypeId += i
	} else {
		m.addcalveTypeId = &i
	}
}

// AddedCalveTypeId returns the value that was added to the calveTypeId field in this mutation.
func (m *CalveMutation) AddedCalveTypeId() (r int, exists bool) {
	v := m.addcalveTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveTypeId reset all changes of the "calveTypeId" field.
func (m *CalveMutation) ResetCalveTypeId() {
	m.calveTypeId = nil
	m.addcalveTypeId = nil
}

// SetCalveTypeName sets the calveTypeName field.
func (m *CalveMutation) SetCalveTypeName(s string) {
	m.calveTypeName = &s
}

// CalveTypeName returns the calveTypeName value in the mutation.
func (m *CalveMutation) CalveTypeName() (r string, exists bool) {
	v := m.calveTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveTypeName returns the old calveTypeName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveTypeName: %w", err)
	}
	return oldValue.CalveTypeName, nil
}

// ResetCalveTypeName reset all changes of the "calveTypeName" field.
func (m *CalveMutation) ResetCalveTypeName() {
	m.calveTypeName = nil
}

// SetCalveCate sets the calveCate field.
func (m *CalveMutation) SetCalveCate(i int) {
	m.calveCate = &i
	m.addcalveCate = nil
}

// CalveCate returns the calveCate value in the mutation.
func (m *CalveMutation) CalveCate() (r int, exists bool) {
	v := m.calveCate
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveCate returns the old calveCate value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveCate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveCate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveCate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveCate: %w", err)
	}
	return oldValue.CalveCate, nil
}

// AddCalveCate adds i to calveCate.
func (m *CalveMutation) AddCalveCate(i int) {
	if m.addcalveCate != nil {
		*m.addcalveCate += i
	} else {
		m.addcalveCate = &i
	}
}

// AddedCalveCate returns the value that was added to the calveCate field in this mutation.
func (m *CalveMutation) AddedCalveCate() (r int, exists bool) {
	v := m.addcalveCate
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveCate reset all changes of the "calveCate" field.
func (m *CalveMutation) ResetCalveCate() {
	m.calveCate = nil
	m.addcalveCate = nil
}

// SetCalveCountId sets the calveCountId field.
func (m *CalveMutation) SetCalveCountId(i int) {
	m.calveCountId = &i
	m.addcalveCountId = nil
}

// CalveCountId returns the calveCountId value in the mutation.
func (m *CalveMutation) CalveCountId() (r int, exists bool) {
	v := m.calveCountId
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveCountId returns the old calveCountId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveCountId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveCountId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveCountId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveCountId: %w", err)
	}
	return oldValue.CalveCountId, nil
}

// AddCalveCountId adds i to calveCountId.
func (m *CalveMutation) AddCalveCountId(i int) {
	if m.addcalveCountId != nil {
		*m.addcalveCountId += i
	} else {
		m.addcalveCountId = &i
	}
}

// AddedCalveCountId returns the value that was added to the calveCountId field in this mutation.
func (m *CalveMutation) AddedCalveCountId() (r int, exists bool) {
	v := m.addcalveCountId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveCountId reset all changes of the "calveCountId" field.
func (m *CalveMutation) ResetCalveCountId() {
	m.calveCountId = nil
	m.addcalveCountId = nil
}

// SetCalveCountName sets the calveCountName field.
func (m *CalveMutation) SetCalveCountName(s string) {
	m.calveCountName = &s
}

// CalveCountName returns the calveCountName value in the mutation.
func (m *CalveMutation) CalveCountName() (r string, exists bool) {
	v := m.calveCountName
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveCountName returns the old calveCountName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveCountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveCountName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveCountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveCountName: %w", err)
	}
	return oldValue.CalveCountName, nil
}

// ResetCalveCountName reset all changes of the "calveCountName" field.
func (m *CalveMutation) ResetCalveCountName() {
	m.calveCountName = nil
}

// SetComplexity sets the complexity field.
func (m *CalveMutation) SetComplexity(i int) {
	m.complexity = &i
	m.addcomplexity = nil
}

// Complexity returns the complexity value in the mutation.
func (m *CalveMutation) Complexity() (r int, exists bool) {
	v := m.complexity
	if v == nil {
		return
	}
	return *v, true
}

// OldComplexity returns the old complexity value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldComplexity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComplexity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComplexity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplexity: %w", err)
	}
	return oldValue.Complexity, nil
}

// AddComplexity adds i to complexity.
func (m *CalveMutation) AddComplexity(i int) {
	if m.addcomplexity != nil {
		*m.addcomplexity += i
	} else {
		m.addcomplexity = &i
	}
}

// AddedComplexity returns the value that was added to the complexity field in this mutation.
func (m *CalveMutation) AddedComplexity() (r int, exists bool) {
	v := m.addcomplexity
	if v == nil {
		return
	}
	return *v, true
}

// ResetComplexity reset all changes of the "complexity" field.
func (m *CalveMutation) ResetComplexity() {
	m.complexity = nil
	m.addcomplexity = nil
}

// SetUserName sets the userName field.
func (m *CalveMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CalveMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CalveMutation) ResetUserName() {
	m.userName = nil
}

// SetBabyStatus sets the babyStatus field.
func (m *CalveMutation) SetBabyStatus(i int) {
	m.babyStatus = &i
	m.addbabyStatus = nil
}

// BabyStatus returns the babyStatus value in the mutation.
func (m *CalveMutation) BabyStatus() (r int, exists bool) {
	v := m.babyStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyStatus returns the old babyStatus value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyStatus: %w", err)
	}
	return oldValue.BabyStatus, nil
}

// AddBabyStatus adds i to babyStatus.
func (m *CalveMutation) AddBabyStatus(i int) {
	if m.addbabyStatus != nil {
		*m.addbabyStatus += i
	} else {
		m.addbabyStatus = &i
	}
}

// AddedBabyStatus returns the value that was added to the babyStatus field in this mutation.
func (m *CalveMutation) AddedBabyStatus() (r int, exists bool) {
	v := m.addbabyStatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyStatus reset all changes of the "babyStatus" field.
func (m *CalveMutation) ResetBabyStatus() {
	m.babyStatus = nil
	m.addbabyStatus = nil
}

// SetBabyGender sets the babyGender field.
func (m *CalveMutation) SetBabyGender(i int) {
	m.babyGender = &i
	m.addbabyGender = nil
}

// BabyGender returns the babyGender value in the mutation.
func (m *CalveMutation) BabyGender() (r int, exists bool) {
	v := m.babyGender
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyGender returns the old babyGender value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyGender(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyGender: %w", err)
	}
	return oldValue.BabyGender, nil
}

// AddBabyGender adds i to babyGender.
func (m *CalveMutation) AddBabyGender(i int) {
	if m.addbabyGender != nil {
		*m.addbabyGender += i
	} else {
		m.addbabyGender = &i
	}
}

// AddedBabyGender returns the value that was added to the babyGender field in this mutation.
func (m *CalveMutation) AddedBabyGender() (r int, exists bool) {
	v := m.addbabyGender
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyGender reset all changes of the "babyGender" field.
func (m *CalveMutation) ResetBabyGender() {
	m.babyGender = nil
	m.addbabyGender = nil
}

// SetBabyEarNumber sets the babyEarNumber field.
func (m *CalveMutation) SetBabyEarNumber(i int) {
	m.babyEarNumber = &i
	m.addbabyEarNumber = nil
}

// BabyEarNumber returns the babyEarNumber value in the mutation.
func (m *CalveMutation) BabyEarNumber() (r int, exists bool) {
	v := m.babyEarNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyEarNumber returns the old babyEarNumber value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyEarNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyEarNumber: %w", err)
	}
	return oldValue.BabyEarNumber, nil
}

// AddBabyEarNumber adds i to babyEarNumber.
func (m *CalveMutation) AddBabyEarNumber(i int) {
	if m.addbabyEarNumber != nil {
		*m.addbabyEarNumber += i
	} else {
		m.addbabyEarNumber = &i
	}
}

// AddedBabyEarNumber returns the value that was added to the babyEarNumber field in this mutation.
func (m *CalveMutation) AddedBabyEarNumber() (r int, exists bool) {
	v := m.addbabyEarNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyEarNumber reset all changes of the "babyEarNumber" field.
func (m *CalveMutation) ResetBabyEarNumber() {
	m.babyEarNumber = nil
	m.addbabyEarNumber = nil
}

// SetBabyBreedId sets the babyBreedId field.
func (m *CalveMutation) SetBabyBreedId(i int) {
	m.babyBreedId = &i
	m.addbabyBreedId = nil
}

// BabyBreedId returns the babyBreedId value in the mutation.
func (m *CalveMutation) BabyBreedId() (r int, exists bool) {
	v := m.babyBreedId
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyBreedId returns the old babyBreedId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyBreedId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyBreedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyBreedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyBreedId: %w", err)
	}
	return oldValue.BabyBreedId, nil
}

// AddBabyBreedId adds i to babyBreedId.
func (m *CalveMutation) AddBabyBreedId(i int) {
	if m.addbabyBreedId != nil {
		*m.addbabyBreedId += i
	} else {
		m.addbabyBreedId = &i
	}
}

// AddedBabyBreedId returns the value that was added to the babyBreedId field in this mutation.
func (m *CalveMutation) AddedBabyBreedId() (r int, exists bool) {
	v := m.addbabyBreedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyBreedId reset all changes of the "babyBreedId" field.
func (m *CalveMutation) ResetBabyBreedId() {
	m.babyBreedId = nil
	m.addbabyBreedId = nil
}

// SetBabyBreedName sets the babyBreedName field.
func (m *CalveMutation) SetBabyBreedName(s string) {
	m.babyBreedName = &s
}

// BabyBreedName returns the babyBreedName value in the mutation.
func (m *CalveMutation) BabyBreedName() (r string, exists bool) {
	v := m.babyBreedName
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyBreedName returns the old babyBreedName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyBreedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyBreedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyBreedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyBreedName: %w", err)
	}
	return oldValue.BabyBreedName, nil
}

// ResetBabyBreedName reset all changes of the "babyBreedName" field.
func (m *CalveMutation) ResetBabyBreedName() {
	m.babyBreedName = nil
}

// SetBabyHairColorId sets the babyHairColorId field.
func (m *CalveMutation) SetBabyHairColorId(i int) {
	m.babyHairColorId = &i
	m.addbabyHairColorId = nil
}

// BabyHairColorId returns the babyHairColorId value in the mutation.
func (m *CalveMutation) BabyHairColorId() (r int, exists bool) {
	v := m.babyHairColorId
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyHairColorId returns the old babyHairColorId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyHairColorId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyHairColorId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyHairColorId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyHairColorId: %w", err)
	}
	return oldValue.BabyHairColorId, nil
}

// AddBabyHairColorId adds i to babyHairColorId.
func (m *CalveMutation) AddBabyHairColorId(i int) {
	if m.addbabyHairColorId != nil {
		*m.addbabyHairColorId += i
	} else {
		m.addbabyHairColorId = &i
	}
}

// AddedBabyHairColorId returns the value that was added to the babyHairColorId field in this mutation.
func (m *CalveMutation) AddedBabyHairColorId() (r int, exists bool) {
	v := m.addbabyHairColorId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyHairColorId reset all changes of the "babyHairColorId" field.
func (m *CalveMutation) ResetBabyHairColorId() {
	m.babyHairColorId = nil
	m.addbabyHairColorId = nil
}

// SetBabyHairColorName sets the babyHairColorName field.
func (m *CalveMutation) SetBabyHairColorName(s string) {
	m.babyHairColorName = &s
}

// BabyHairColorName returns the babyHairColorName value in the mutation.
func (m *CalveMutation) BabyHairColorName() (r string, exists bool) {
	v := m.babyHairColorName
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyHairColorName returns the old babyHairColorName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyHairColorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyHairColorName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyHairColorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyHairColorName: %w", err)
	}
	return oldValue.BabyHairColorName, nil
}

// ResetBabyHairColorName reset all changes of the "babyHairColorName" field.
func (m *CalveMutation) ResetBabyHairColorName() {
	m.babyHairColorName = nil
}

// SetBabyWeight sets the babyWeight field.
func (m *CalveMutation) SetBabyWeight(f float32) {
	m.babyWeight = &f
	m.addbabyWeight = nil
}

// BabyWeight returns the babyWeight value in the mutation.
func (m *CalveMutation) BabyWeight() (r float32, exists bool) {
	v := m.babyWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyWeight returns the old babyWeight value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyWeight: %w", err)
	}
	return oldValue.BabyWeight, nil
}

// AddBabyWeight adds f to babyWeight.
func (m *CalveMutation) AddBabyWeight(f float32) {
	if m.addbabyWeight != nil {
		*m.addbabyWeight += f
	} else {
		m.addbabyWeight = &f
	}
}

// AddedBabyWeight returns the value that was added to the babyWeight field in this mutation.
func (m *CalveMutation) AddedBabyWeight() (r float32, exists bool) {
	v := m.addbabyWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyWeight reset all changes of the "babyWeight" field.
func (m *CalveMutation) ResetBabyWeight() {
	m.babyWeight = nil
	m.addbabyWeight = nil
}

// SetBabyShedId sets the babyShedId field.
func (m *CalveMutation) SetBabyShedId(i int) {
	m.babyShedId = &i
	m.addbabyShedId = nil
}

// BabyShedId returns the babyShedId value in the mutation.
func (m *CalveMutation) BabyShedId() (r int, exists bool) {
	v := m.babyShedId
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyShedId returns the old babyShedId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyShedId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyShedId: %w", err)
	}
	return oldValue.BabyShedId, nil
}

// AddBabyShedId adds i to babyShedId.
func (m *CalveMutation) AddBabyShedId(i int) {
	if m.addbabyShedId != nil {
		*m.addbabyShedId += i
	} else {
		m.addbabyShedId = &i
	}
}

// AddedBabyShedId returns the value that was added to the babyShedId field in this mutation.
func (m *CalveMutation) AddedBabyShedId() (r int, exists bool) {
	v := m.addbabyShedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyShedId reset all changes of the "babyShedId" field.
func (m *CalveMutation) ResetBabyShedId() {
	m.babyShedId = nil
	m.addbabyShedId = nil
}

// SetBabyShedName sets the babyShedName field.
func (m *CalveMutation) SetBabyShedName(s string) {
	m.babyShedName = &s
}

// BabyShedName returns the babyShedName value in the mutation.
func (m *CalveMutation) BabyShedName() (r string, exists bool) {
	v := m.babyShedName
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyShedName returns the old babyShedName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyShedName: %w", err)
	}
	return oldValue.BabyShedName, nil
}

// ResetBabyShedName reset all changes of the "babyShedName" field.
func (m *CalveMutation) ResetBabyShedName() {
	m.babyShedName = nil
}

// SetRemarks sets the remarks field.
func (m *CalveMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CalveMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CalveMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CalveMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CalveMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CalveMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CalveMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CalveMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CalveMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CalveMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CalveMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CalveMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CalveMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CalveMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CalveMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CalveMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CalveMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CalveMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CalveMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Calve).
func (m *CalveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CalveMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.name != nil {
		fields = append(fields, calve.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, calve.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, calve.FieldTimes)
	}
	if m.pregnantAt != nil {
		fields = append(fields, calve.FieldPregnantAt)
	}
	if m.calveAt != nil {
		fields = append(fields, calve.FieldCalveAt)
	}
	if m.calveTypeId != nil {
		fields = append(fields, calve.FieldCalveTypeId)
	}
	if m.calveTypeName != nil {
		fields = append(fields, calve.FieldCalveTypeName)
	}
	if m.calveCate != nil {
		fields = append(fields, calve.FieldCalveCate)
	}
	if m.calveCountId != nil {
		fields = append(fields, calve.FieldCalveCountId)
	}
	if m.calveCountName != nil {
		fields = append(fields, calve.FieldCalveCountName)
	}
	if m.complexity != nil {
		fields = append(fields, calve.FieldComplexity)
	}
	if m.userName != nil {
		fields = append(fields, calve.FieldUserName)
	}
	if m.babyStatus != nil {
		fields = append(fields, calve.FieldBabyStatus)
	}
	if m.babyGender != nil {
		fields = append(fields, calve.FieldBabyGender)
	}
	if m.babyEarNumber != nil {
		fields = append(fields, calve.FieldBabyEarNumber)
	}
	if m.babyBreedId != nil {
		fields = append(fields, calve.FieldBabyBreedId)
	}
	if m.babyBreedName != nil {
		fields = append(fields, calve.FieldBabyBreedName)
	}
	if m.babyHairColorId != nil {
		fields = append(fields, calve.FieldBabyHairColorId)
	}
	if m.babyHairColorName != nil {
		fields = append(fields, calve.FieldBabyHairColorName)
	}
	if m.babyWeight != nil {
		fields = append(fields, calve.FieldBabyWeight)
	}
	if m.babyShedId != nil {
		fields = append(fields, calve.FieldBabyShedId)
	}
	if m.babyShedName != nil {
		fields = append(fields, calve.FieldBabyShedName)
	}
	if m.remarks != nil {
		fields = append(fields, calve.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, calve.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, calve.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, calve.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CalveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calve.FieldName:
		return m.Name()
	case calve.FieldEarNumber:
		return m.EarNumber()
	case calve.FieldTimes:
		return m.Times()
	case calve.FieldPregnantAt:
		return m.PregnantAt()
	case calve.FieldCalveAt:
		return m.CalveAt()
	case calve.FieldCalveTypeId:
		return m.CalveTypeId()
	case calve.FieldCalveTypeName:
		return m.CalveTypeName()
	case calve.FieldCalveCate:
		return m.CalveCate()
	case calve.FieldCalveCountId:
		return m.CalveCountId()
	case calve.FieldCalveCountName:
		return m.CalveCountName()
	case calve.FieldComplexity:
		return m.Complexity()
	case calve.FieldUserName:
		return m.UserName()
	case calve.FieldBabyStatus:
		return m.BabyStatus()
	case calve.FieldBabyGender:
		return m.BabyGender()
	case calve.FieldBabyEarNumber:
		return m.BabyEarNumber()
	case calve.FieldBabyBreedId:
		return m.BabyBreedId()
	case calve.FieldBabyBreedName:
		return m.BabyBreedName()
	case calve.FieldBabyHairColorId:
		return m.BabyHairColorId()
	case calve.FieldBabyHairColorName:
		return m.BabyHairColorName()
	case calve.FieldBabyWeight:
		return m.BabyWeight()
	case calve.FieldBabyShedId:
		return m.BabyShedId()
	case calve.FieldBabyShedName:
		return m.BabyShedName()
	case calve.FieldRemarks:
		return m.Remarks()
	case calve.FieldCreatedAt:
		return m.CreatedAt()
	case calve.FieldUpdatedAt:
		return m.UpdatedAt()
	case calve.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CalveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calve.FieldName:
		return m.OldName(ctx)
	case calve.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case calve.FieldTimes:
		return m.OldTimes(ctx)
	case calve.FieldPregnantAt:
		return m.OldPregnantAt(ctx)
	case calve.FieldCalveAt:
		return m.OldCalveAt(ctx)
	case calve.FieldCalveTypeId:
		return m.OldCalveTypeId(ctx)
	case calve.FieldCalveTypeName:
		return m.OldCalveTypeName(ctx)
	case calve.FieldCalveCate:
		return m.OldCalveCate(ctx)
	case calve.FieldCalveCountId:
		return m.OldCalveCountId(ctx)
	case calve.FieldCalveCountName:
		return m.OldCalveCountName(ctx)
	case calve.FieldComplexity:
		return m.OldComplexity(ctx)
	case calve.FieldUserName:
		return m.OldUserName(ctx)
	case calve.FieldBabyStatus:
		return m.OldBabyStatus(ctx)
	case calve.FieldBabyGender:
		return m.OldBabyGender(ctx)
	case calve.FieldBabyEarNumber:
		return m.OldBabyEarNumber(ctx)
	case calve.FieldBabyBreedId:
		return m.OldBabyBreedId(ctx)
	case calve.FieldBabyBreedName:
		return m.OldBabyBreedName(ctx)
	case calve.FieldBabyHairColorId:
		return m.OldBabyHairColorId(ctx)
	case calve.FieldBabyHairColorName:
		return m.OldBabyHairColorName(ctx)
	case calve.FieldBabyWeight:
		return m.OldBabyWeight(ctx)
	case calve.FieldBabyShedId:
		return m.OldBabyShedId(ctx)
	case calve.FieldBabyShedName:
		return m.OldBabyShedName(ctx)
	case calve.FieldRemarks:
		return m.OldRemarks(ctx)
	case calve.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case calve.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case calve.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Calve field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calve.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case calve.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case calve.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case calve.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnantAt(v)
		return nil
	case calve.FieldCalveAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveAt(v)
		return nil
	case calve.FieldCalveTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveTypeId(v)
		return nil
	case calve.FieldCalveTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveTypeName(v)
		return nil
	case calve.FieldCalveCate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveCate(v)
		return nil
	case calve.FieldCalveCountId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveCountId(v)
		return nil
	case calve.FieldCalveCountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveCountName(v)
		return nil
	case calve.FieldComplexity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplexity(v)
		return nil
	case calve.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case calve.FieldBabyStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyStatus(v)
		return nil
	case calve.FieldBabyGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyGender(v)
		return nil
	case calve.FieldBabyEarNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyEarNumber(v)
		return nil
	case calve.FieldBabyBreedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyBreedId(v)
		return nil
	case calve.FieldBabyBreedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyBreedName(v)
		return nil
	case calve.FieldBabyHairColorId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyHairColorId(v)
		return nil
	case calve.FieldBabyHairColorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyHairColorName(v)
		return nil
	case calve.FieldBabyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyWeight(v)
		return nil
	case calve.FieldBabyShedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyShedId(v)
		return nil
	case calve.FieldBabyShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyShedName(v)
		return nil
	case calve.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case calve.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case calve.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case calve.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Calve field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CalveMutation) AddedFields() []string {
	var fields []string
	if m.addtimes != nil {
		fields = append(fields, calve.FieldTimes)
	}
	if m.addpregnantAt != nil {
		fields = append(fields, calve.FieldPregnantAt)
	}
	if m.addcalveAt != nil {
		fields = append(fields, calve.FieldCalveAt)
	}
	if m.addcalveTypeId != nil {
		fields = append(fields, calve.FieldCalveTypeId)
	}
	if m.addcalveCate != nil {
		fields = append(fields, calve.FieldCalveCate)
	}
	if m.addcalveCountId != nil {
		fields = append(fields, calve.FieldCalveCountId)
	}
	if m.addcomplexity != nil {
		fields = append(fields, calve.FieldComplexity)
	}
	if m.addbabyStatus != nil {
		fields = append(fields, calve.FieldBabyStatus)
	}
	if m.addbabyGender != nil {
		fields = append(fields, calve.FieldBabyGender)
	}
	if m.addbabyEarNumber != nil {
		fields = append(fields, calve.FieldBabyEarNumber)
	}
	if m.addbabyBreedId != nil {
		fields = append(fields, calve.FieldBabyBreedId)
	}
	if m.addbabyHairColorId != nil {
		fields = append(fields, calve.FieldBabyHairColorId)
	}
	if m.addbabyWeight != nil {
		fields = append(fields, calve.FieldBabyWeight)
	}
	if m.addbabyShedId != nil {
		fields = append(fields, calve.FieldBabyShedId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, calve.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, calve.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, calve.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CalveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case calve.FieldTimes:
		return m.AddedTimes()
	case calve.FieldPregnantAt:
		return m.AddedPregnantAt()
	case calve.FieldCalveAt:
		return m.AddedCalveAt()
	case calve.FieldCalveTypeId:
		return m.AddedCalveTypeId()
	case calve.FieldCalveCate:
		return m.AddedCalveCate()
	case calve.FieldCalveCountId:
		return m.AddedCalveCountId()
	case calve.FieldComplexity:
		return m.AddedComplexity()
	case calve.FieldBabyStatus:
		return m.AddedBabyStatus()
	case calve.FieldBabyGender:
		return m.AddedBabyGender()
	case calve.FieldBabyEarNumber:
		return m.AddedBabyEarNumber()
	case calve.FieldBabyBreedId:
		return m.AddedBabyBreedId()
	case calve.FieldBabyHairColorId:
		return m.AddedBabyHairColorId()
	case calve.FieldBabyWeight:
		return m.AddedBabyWeight()
	case calve.FieldBabyShedId:
		return m.AddedBabyShedId()
	case calve.FieldCreatedAt:
		return m.AddedCreatedAt()
	case calve.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case calve.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveMutation) AddField(name string, value ent.Value) error {
	switch name {
	case calve.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case calve.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnantAt(v)
		return nil
	case calve.FieldCalveAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveAt(v)
		return nil
	case calve.FieldCalveTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveTypeId(v)
		return nil
	case calve.FieldCalveCate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveCate(v)
		return nil
	case calve.FieldCalveCountId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveCountId(v)
		return nil
	case calve.FieldComplexity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComplexity(v)
		return nil
	case calve.FieldBabyStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyStatus(v)
		return nil
	case calve.FieldBabyGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyGender(v)
		return nil
	case calve.FieldBabyEarNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyEarNumber(v)
		return nil
	case calve.FieldBabyBreedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyBreedId(v)
		return nil
	case calve.FieldBabyHairColorId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyHairColorId(v)
		return nil
	case calve.FieldBabyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyWeight(v)
		return nil
	case calve.FieldBabyShedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyShedId(v)
		return nil
	case calve.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case calve.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case calve.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Calve numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CalveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(calve.FieldName) {
		fields = append(fields, calve.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CalveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalveMutation) ClearField(name string) error {
	switch name {
	case calve.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Calve nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CalveMutation) ResetField(name string) error {
	switch name {
	case calve.FieldName:
		m.ResetName()
		return nil
	case calve.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case calve.FieldTimes:
		m.ResetTimes()
		return nil
	case calve.FieldPregnantAt:
		m.ResetPregnantAt()
		return nil
	case calve.FieldCalveAt:
		m.ResetCalveAt()
		return nil
	case calve.FieldCalveTypeId:
		m.ResetCalveTypeId()
		return nil
	case calve.FieldCalveTypeName:
		m.ResetCalveTypeName()
		return nil
	case calve.FieldCalveCate:
		m.ResetCalveCate()
		return nil
	case calve.FieldCalveCountId:
		m.ResetCalveCountId()
		return nil
	case calve.FieldCalveCountName:
		m.ResetCalveCountName()
		return nil
	case calve.FieldComplexity:
		m.ResetComplexity()
		return nil
	case calve.FieldUserName:
		m.ResetUserName()
		return nil
	case calve.FieldBabyStatus:
		m.ResetBabyStatus()
		return nil
	case calve.FieldBabyGender:
		m.ResetBabyGender()
		return nil
	case calve.FieldBabyEarNumber:
		m.ResetBabyEarNumber()
		return nil
	case calve.FieldBabyBreedId:
		m.ResetBabyBreedId()
		return nil
	case calve.FieldBabyBreedName:
		m.ResetBabyBreedName()
		return nil
	case calve.FieldBabyHairColorId:
		m.ResetBabyHairColorId()
		return nil
	case calve.FieldBabyHairColorName:
		m.ResetBabyHairColorName()
		return nil
	case calve.FieldBabyWeight:
		m.ResetBabyWeight()
		return nil
	case calve.FieldBabyShedId:
		m.ResetBabyShedId()
		return nil
	case calve.FieldBabyShedName:
		m.ResetBabyShedName()
		return nil
	case calve.FieldRemarks:
		m.ResetRemarks()
		return nil
	case calve.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case calve.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case calve.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Calve field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CalveMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CalveMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CalveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CalveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CalveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CalveMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CalveMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Calve unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CalveMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Calve edge %s", name)
}

// CalveCountMutation represents an operation that mutate the CalveCounts
// nodes in the graph.
type CalveCountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CalveCount, error)
}

var _ ent.Mutation = (*CalveCountMutation)(nil)

// calvecountOption allows to manage the mutation configuration using functional options.
type calvecountOption func(*CalveCountMutation)

// newCalveCountMutation creates new mutation for $n.Name.
func newCalveCountMutation(c config, op Op, opts ...calvecountOption) *CalveCountMutation {
	m := &CalveCountMutation{
		config:        c,
		op:            op,
		typ:           TypeCalveCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalveCountID sets the id field of the mutation.
func withCalveCountID(id int64) calvecountOption {
	return func(m *CalveCountMutation) {
		var (
			err   error
			once  sync.Once
			value *CalveCount
		)
		m.oldValue = func(ctx context.Context) (*CalveCount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CalveCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalveCount sets the old CalveCount of the mutation.
func withCalveCount(node *CalveCount) calvecountOption {
	return func(m *CalveCountMutation) {
		m.oldValue = func(context.Context) (*CalveCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalveCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalveCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CalveCountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CalveCountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CalveCountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CalveCount.
// If the CalveCount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveCountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CalveCountMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CalveCountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CalveCount).
func (m *CalveCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CalveCountMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, calvecount.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CalveCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calvecount.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CalveCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calvecount.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CalveCount field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calvecount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CalveCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CalveCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CalveCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CalveCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CalveCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CalveCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalveCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CalveCount nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CalveCountMutation) ResetField(name string) error {
	switch name {
	case calvecount.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CalveCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CalveCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CalveCountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CalveCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CalveCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CalveCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CalveCountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CalveCountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CalveCount unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CalveCountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CalveCount edge %s", name)
}

// CalveTypeMutation represents an operation that mutate the CalveTypes
// nodes in the graph.
type CalveTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CalveType, error)
}

var _ ent.Mutation = (*CalveTypeMutation)(nil)

// calvetypeOption allows to manage the mutation configuration using functional options.
type calvetypeOption func(*CalveTypeMutation)

// newCalveTypeMutation creates new mutation for $n.Name.
func newCalveTypeMutation(c config, op Op, opts ...calvetypeOption) *CalveTypeMutation {
	m := &CalveTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCalveType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalveTypeID sets the id field of the mutation.
func withCalveTypeID(id int64) calvetypeOption {
	return func(m *CalveTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CalveType
		)
		m.oldValue = func(ctx context.Context) (*CalveType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CalveType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalveType sets the old CalveType of the mutation.
func withCalveType(node *CalveType) calvetypeOption {
	return func(m *CalveTypeMutation) {
		m.oldValue = func(context.Context) (*CalveType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalveTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalveTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CalveTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CalveTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CalveTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CalveType.
// If the CalveType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CalveTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CalveTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CalveType).
func (m *CalveTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CalveTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, calvetype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CalveTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calvetype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CalveTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calvetype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CalveType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calvetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CalveType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CalveTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CalveTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CalveType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CalveTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CalveTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalveTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CalveType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CalveTypeMutation) ResetField(name string) error {
	switch name {
	case calvetype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CalveType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CalveTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CalveTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CalveTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CalveTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CalveTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CalveTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CalveTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CalveType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CalveTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CalveType edge %s", name)
}

// CategoryMutation represents an operation that mutate the Categories
// nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Category, error)
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows to manage the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for $n.Name.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the id field of the mutation.
func withCategoryID(id int64) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Category.
// If the Category object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Category edge %s", name)
}

// CattleMutation represents an operation that mutate the Cattles
// nodes in the graph.
type CattleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	name                   *string
	farmId                 *int64
	addfarmId              *int64
	farmName               *string
	shedId                 *int64
	addshedId              *int64
	shedName               *string
	shedTypeId             *int64
	addshedTypeId          *int64
	shedTypeName           *string
	earNumber              *string
	electronicEarNumber    *string
	pedometer              *string
	genderId               *int
	addgenderId            *int
	genderName             *string
	birthday               *int64
	addbirthday            *int64
	joinedAt               *int64
	addjoinedAt            *int64
	cateId                 *int
	addcateId              *int
	cateName               *string
	_type                  *int
	add_type               *int
	typeName               *string
	weight                 *int32
	addweight              *int32
	from                   *string
	breed                  *string
	joinedTypeId           *int
	addjoinedTypeId        *int
	joinedTypeName         *string
	mother                 *string
	father                 *string
	grandfather            *string
	ownerId                *int64
	addownerId             *int64
	ownerName              *string
	hairColorId            *int64
	addhairColorId         *int64
	hairColorName          *string
	reproductiveStateId    *int
	addreproductiveStateId *int
	reproductiveStateName  *string
	pregnantTimes          *int
	addpregnantTimes       *int
	lastCalvingAt          *int64
	addlastCalvingAt       *int64
	breedingAt             *int64
	addbreedingAt          *int64
	breedingTypeId         *int
	addbreedingTypeId      *int
	breedingTypeName       *string
	bullId                 *int64
	addbullId              *int64
	pregnancyCheckAt       *int64
	addpregnancyCheckAt    *int64
	createdAt              *int64
	addcreatedAt           *int64
	updatedAt              *int64
	addupdatedAt           *int64
	deleted                *int
	adddeleted             *int
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*Cattle, error)
}

var _ ent.Mutation = (*CattleMutation)(nil)

// cattleOption allows to manage the mutation configuration using functional options.
type cattleOption func(*CattleMutation)

// newCattleMutation creates new mutation for $n.Name.
func newCattleMutation(c config, op Op, opts ...cattleOption) *CattleMutation {
	m := &CattleMutation{
		config:        c,
		op:            op,
		typ:           TypeCattle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleID sets the id field of the mutation.
func withCattleID(id int64) cattleOption {
	return func(m *CattleMutation) {
		var (
			err   error
			once  sync.Once
			value *Cattle
		)
		m.oldValue = func(ctx context.Context) (*Cattle, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cattle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattle sets the old Cattle of the mutation.
func withCattle(node *Cattle) cattleOption {
	return func(m *CattleMutation) {
		m.oldValue = func(context.Context) (*Cattle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattle.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattle.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattle.FieldName)
}

// SetFarmId sets the farmId field.
func (m *CattleMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *CattleMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *CattleMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *CattleMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *CattleMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *CattleMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *CattleMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *CattleMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *CattleMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *CattleMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *CattleMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *CattleMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *CattleMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *CattleMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleMutation) ResetShedName() {
	m.shedName = nil
}

// SetShedTypeId sets the shedTypeId field.
func (m *CattleMutation) SetShedTypeId(i int64) {
	m.shedTypeId = &i
	m.addshedTypeId = nil
}

// ShedTypeId returns the shedTypeId value in the mutation.
func (m *CattleMutation) ShedTypeId() (r int64, exists bool) {
	v := m.shedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeId returns the old shedTypeId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedTypeId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeId: %w", err)
	}
	return oldValue.ShedTypeId, nil
}

// AddShedTypeId adds i to shedTypeId.
func (m *CattleMutation) AddShedTypeId(i int64) {
	if m.addshedTypeId != nil {
		*m.addshedTypeId += i
	} else {
		m.addshedTypeId = &i
	}
}

// AddedShedTypeId returns the value that was added to the shedTypeId field in this mutation.
func (m *CattleMutation) AddedShedTypeId() (r int64, exists bool) {
	v := m.addshedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedTypeId reset all changes of the "shedTypeId" field.
func (m *CattleMutation) ResetShedTypeId() {
	m.shedTypeId = nil
	m.addshedTypeId = nil
}

// SetShedTypeName sets the shedTypeName field.
func (m *CattleMutation) SetShedTypeName(s string) {
	m.shedTypeName = &s
}

// ShedTypeName returns the shedTypeName value in the mutation.
func (m *CattleMutation) ShedTypeName() (r string, exists bool) {
	v := m.shedTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeName returns the old shedTypeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeName: %w", err)
	}
	return oldValue.ShedTypeName, nil
}

// ResetShedTypeName reset all changes of the "shedTypeName" field.
func (m *CattleMutation) ResetShedTypeName() {
	m.shedTypeName = nil
}

// SetEarNumber sets the earNumber field.
func (m *CattleMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetElectronicEarNumber sets the electronicEarNumber field.
func (m *CattleMutation) SetElectronicEarNumber(s string) {
	m.electronicEarNumber = &s
}

// ElectronicEarNumber returns the electronicEarNumber value in the mutation.
func (m *CattleMutation) ElectronicEarNumber() (r string, exists bool) {
	v := m.electronicEarNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldElectronicEarNumber returns the old electronicEarNumber value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldElectronicEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldElectronicEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldElectronicEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectronicEarNumber: %w", err)
	}
	return oldValue.ElectronicEarNumber, nil
}

// ResetElectronicEarNumber reset all changes of the "electronicEarNumber" field.
func (m *CattleMutation) ResetElectronicEarNumber() {
	m.electronicEarNumber = nil
}

// SetPedometer sets the pedometer field.
func (m *CattleMutation) SetPedometer(s string) {
	m.pedometer = &s
}

// Pedometer returns the pedometer value in the mutation.
func (m *CattleMutation) Pedometer() (r string, exists bool) {
	v := m.pedometer
	if v == nil {
		return
	}
	return *v, true
}

// OldPedometer returns the old pedometer value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldPedometer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPedometer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPedometer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPedometer: %w", err)
	}
	return oldValue.Pedometer, nil
}

// ResetPedometer reset all changes of the "pedometer" field.
func (m *CattleMutation) ResetPedometer() {
	m.pedometer = nil
}

// SetGenderId sets the genderId field.
func (m *CattleMutation) SetGenderId(i int) {
	m.genderId = &i
	m.addgenderId = nil
}

// GenderId returns the genderId value in the mutation.
func (m *CattleMutation) GenderId() (r int, exists bool) {
	v := m.genderId
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderId returns the old genderId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldGenderId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderId: %w", err)
	}
	return oldValue.GenderId, nil
}

// AddGenderId adds i to genderId.
func (m *CattleMutation) AddGenderId(i int) {
	if m.addgenderId != nil {
		*m.addgenderId += i
	} else {
		m.addgenderId = &i
	}
}

// AddedGenderId returns the value that was added to the genderId field in this mutation.
func (m *CattleMutation) AddedGenderId() (r int, exists bool) {
	v := m.addgenderId
	if v == nil {
		return
	}
	return *v, true
}

// ResetGenderId reset all changes of the "genderId" field.
func (m *CattleMutation) ResetGenderId() {
	m.genderId = nil
	m.addgenderId = nil
}

// SetGenderName sets the genderName field.
func (m *CattleMutation) SetGenderName(s string) {
	m.genderName = &s
}

// GenderName returns the genderName value in the mutation.
func (m *CattleMutation) GenderName() (r string, exists bool) {
	v := m.genderName
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderName returns the old genderName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldGenderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderName: %w", err)
	}
	return oldValue.GenderName, nil
}

// ResetGenderName reset all changes of the "genderName" field.
func (m *CattleMutation) ResetGenderName() {
	m.genderName = nil
}

// SetBirthday sets the birthday field.
func (m *CattleMutation) SetBirthday(i int64) {
	m.birthday = &i
	m.addbirthday = nil
}

// Birthday returns the birthday value in the mutation.
func (m *CattleMutation) Birthday() (r int64, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old birthday value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBirthday(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds i to birthday.
func (m *CattleMutation) AddBirthday(i int64) {
	if m.addbirthday != nil {
		*m.addbirthday += i
	} else {
		m.addbirthday = &i
	}
}

// AddedBirthday returns the value that was added to the birthday field in this mutation.
func (m *CattleMutation) AddedBirthday() (r int64, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday reset all changes of the "birthday" field.
func (m *CattleMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetJoinedAt sets the joinedAt field.
func (m *CattleMutation) SetJoinedAt(i int64) {
	m.joinedAt = &i
	m.addjoinedAt = nil
}

// JoinedAt returns the joinedAt value in the mutation.
func (m *CattleMutation) JoinedAt() (r int64, exists bool) {
	v := m.joinedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old joinedAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldJoinedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// AddJoinedAt adds i to joinedAt.
func (m *CattleMutation) AddJoinedAt(i int64) {
	if m.addjoinedAt != nil {
		*m.addjoinedAt += i
	} else {
		m.addjoinedAt = &i
	}
}

// AddedJoinedAt returns the value that was added to the joinedAt field in this mutation.
func (m *CattleMutation) AddedJoinedAt() (r int64, exists bool) {
	v := m.addjoinedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetJoinedAt reset all changes of the "joinedAt" field.
func (m *CattleMutation) ResetJoinedAt() {
	m.joinedAt = nil
	m.addjoinedAt = nil
}

// SetCateId sets the cateId field.
func (m *CattleMutation) SetCateId(i int) {
	m.cateId = &i
	m.addcateId = nil
}

// CateId returns the cateId value in the mutation.
func (m *CattleMutation) CateId() (r int, exists bool) {
	v := m.cateId
	if v == nil {
		return
	}
	return *v, true
}

// OldCateId returns the old cateId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldCateId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCateId: %w", err)
	}
	return oldValue.CateId, nil
}

// AddCateId adds i to cateId.
func (m *CattleMutation) AddCateId(i int) {
	if m.addcateId != nil {
		*m.addcateId += i
	} else {
		m.addcateId = &i
	}
}

// AddedCateId returns the value that was added to the cateId field in this mutation.
func (m *CattleMutation) AddedCateId() (r int, exists bool) {
	v := m.addcateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCateId reset all changes of the "cateId" field.
func (m *CattleMutation) ResetCateId() {
	m.cateId = nil
	m.addcateId = nil
}

// SetCateName sets the cateName field.
func (m *CattleMutation) SetCateName(s string) {
	m.cateName = &s
}

// CateName returns the cateName value in the mutation.
func (m *CattleMutation) CateName() (r string, exists bool) {
	v := m.cateName
	if v == nil {
		return
	}
	return *v, true
}

// OldCateName returns the old cateName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldCateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCateName: %w", err)
	}
	return oldValue.CateName, nil
}

// ResetCateName reset all changes of the "cateName" field.
func (m *CattleMutation) ResetCateName() {
	m.cateName = nil
}

// SetType sets the type field.
func (m *CattleMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *CattleMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *CattleMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *CattleMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *CattleMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetTypeName sets the typeName field.
func (m *CattleMutation) SetTypeName(s string) {
	m.typeName = &s
}

// TypeName returns the typeName value in the mutation.
func (m *CattleMutation) TypeName() (r string, exists bool) {
	v := m.typeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old typeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName reset all changes of the "typeName" field.
func (m *CattleMutation) ResetTypeName() {
	m.typeName = nil
}

// SetWeight sets the weight field.
func (m *CattleMutation) SetWeight(i int32) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *CattleMutation) Weight() (r int32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldWeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *CattleMutation) AddWeight(i int32) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *CattleMutation) AddedWeight() (r int32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *CattleMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetFrom sets the from field.
func (m *CattleMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the from value in the mutation.
func (m *CattleMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old from value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFrom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom reset all changes of the "from" field.
func (m *CattleMutation) ResetFrom() {
	m.from = nil
}

// SetBreed sets the breed field.
func (m *CattleMutation) SetBreed(s string) {
	m.breed = &s
}

// Breed returns the breed value in the mutation.
func (m *CattleMutation) Breed() (r string, exists bool) {
	v := m.breed
	if v == nil {
		return
	}
	return *v, true
}

// OldBreed returns the old breed value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreed: %w", err)
	}
	return oldValue.Breed, nil
}

// ResetBreed reset all changes of the "breed" field.
func (m *CattleMutation) ResetBreed() {
	m.breed = nil
}

// SetJoinedTypeId sets the joinedTypeId field.
func (m *CattleMutation) SetJoinedTypeId(i int) {
	m.joinedTypeId = &i
	m.addjoinedTypeId = nil
}

// JoinedTypeId returns the joinedTypeId value in the mutation.
func (m *CattleMutation) JoinedTypeId() (r int, exists bool) {
	v := m.joinedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedTypeId returns the old joinedTypeId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldJoinedTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedTypeId: %w", err)
	}
	return oldValue.JoinedTypeId, nil
}

// AddJoinedTypeId adds i to joinedTypeId.
func (m *CattleMutation) AddJoinedTypeId(i int) {
	if m.addjoinedTypeId != nil {
		*m.addjoinedTypeId += i
	} else {
		m.addjoinedTypeId = &i
	}
}

// AddedJoinedTypeId returns the value that was added to the joinedTypeId field in this mutation.
func (m *CattleMutation) AddedJoinedTypeId() (r int, exists bool) {
	v := m.addjoinedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetJoinedTypeId reset all changes of the "joinedTypeId" field.
func (m *CattleMutation) ResetJoinedTypeId() {
	m.joinedTypeId = nil
	m.addjoinedTypeId = nil
}

// SetJoinedTypeName sets the joinedTypeName field.
func (m *CattleMutation) SetJoinedTypeName(s string) {
	m.joinedTypeName = &s
}

// JoinedTypeName returns the joinedTypeName value in the mutation.
func (m *CattleMutation) JoinedTypeName() (r string, exists bool) {
	v := m.joinedTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedTypeName returns the old joinedTypeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldJoinedTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedTypeName: %w", err)
	}
	return oldValue.JoinedTypeName, nil
}

// ResetJoinedTypeName reset all changes of the "joinedTypeName" field.
func (m *CattleMutation) ResetJoinedTypeName() {
	m.joinedTypeName = nil
}

// SetMother sets the mother field.
func (m *CattleMutation) SetMother(s string) {
	m.mother = &s
}

// Mother returns the mother value in the mutation.
func (m *CattleMutation) Mother() (r string, exists bool) {
	v := m.mother
	if v == nil {
		return
	}
	return *v, true
}

// OldMother returns the old mother value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldMother(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMother is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMother requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMother: %w", err)
	}
	return oldValue.Mother, nil
}

// ResetMother reset all changes of the "mother" field.
func (m *CattleMutation) ResetMother() {
	m.mother = nil
}

// SetFather sets the father field.
func (m *CattleMutation) SetFather(s string) {
	m.father = &s
}

// Father returns the father value in the mutation.
func (m *CattleMutation) Father() (r string, exists bool) {
	v := m.father
	if v == nil {
		return
	}
	return *v, true
}

// OldFather returns the old father value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFather(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFather is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFather: %w", err)
	}
	return oldValue.Father, nil
}

// ResetFather reset all changes of the "father" field.
func (m *CattleMutation) ResetFather() {
	m.father = nil
}

// SetGrandfather sets the grandfather field.
func (m *CattleMutation) SetGrandfather(s string) {
	m.grandfather = &s
}

// Grandfather returns the grandfather value in the mutation.
func (m *CattleMutation) Grandfather() (r string, exists bool) {
	v := m.grandfather
	if v == nil {
		return
	}
	return *v, true
}

// OldGrandfather returns the old grandfather value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldGrandfather(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGrandfather is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGrandfather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrandfather: %w", err)
	}
	return oldValue.Grandfather, nil
}

// ResetGrandfather reset all changes of the "grandfather" field.
func (m *CattleMutation) ResetGrandfather() {
	m.grandfather = nil
}

// SetOwnerId sets the ownerId field.
func (m *CattleMutation) SetOwnerId(i int64) {
	m.ownerId = &i
	m.addownerId = nil
}

// OwnerId returns the ownerId value in the mutation.
func (m *CattleMutation) OwnerId() (r int64, exists bool) {
	v := m.ownerId
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerId returns the old ownerId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldOwnerId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerId: %w", err)
	}
	return oldValue.OwnerId, nil
}

// AddOwnerId adds i to ownerId.
func (m *CattleMutation) AddOwnerId(i int64) {
	if m.addownerId != nil {
		*m.addownerId += i
	} else {
		m.addownerId = &i
	}
}

// AddedOwnerId returns the value that was added to the ownerId field in this mutation.
func (m *CattleMutation) AddedOwnerId() (r int64, exists bool) {
	v := m.addownerId
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerId reset all changes of the "ownerId" field.
func (m *CattleMutation) ResetOwnerId() {
	m.ownerId = nil
	m.addownerId = nil
}

// SetOwnerName sets the ownerName field.
func (m *CattleMutation) SetOwnerName(s string) {
	m.ownerName = &s
}

// OwnerName returns the ownerName value in the mutation.
func (m *CattleMutation) OwnerName() (r string, exists bool) {
	v := m.ownerName
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerName returns the old ownerName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldOwnerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerName: %w", err)
	}
	return oldValue.OwnerName, nil
}

// ResetOwnerName reset all changes of the "ownerName" field.
func (m *CattleMutation) ResetOwnerName() {
	m.ownerName = nil
}

// SetHairColorId sets the hairColorId field.
func (m *CattleMutation) SetHairColorId(i int64) {
	m.hairColorId = &i
	m.addhairColorId = nil
}

// HairColorId returns the hairColorId value in the mutation.
func (m *CattleMutation) HairColorId() (r int64, exists bool) {
	v := m.hairColorId
	if v == nil {
		return
	}
	return *v, true
}

// OldHairColorId returns the old hairColorId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldHairColorId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairColorId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairColorId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairColorId: %w", err)
	}
	return oldValue.HairColorId, nil
}

// AddHairColorId adds i to hairColorId.
func (m *CattleMutation) AddHairColorId(i int64) {
	if m.addhairColorId != nil {
		*m.addhairColorId += i
	} else {
		m.addhairColorId = &i
	}
}

// AddedHairColorId returns the value that was added to the hairColorId field in this mutation.
func (m *CattleMutation) AddedHairColorId() (r int64, exists bool) {
	v := m.addhairColorId
	if v == nil {
		return
	}
	return *v, true
}

// ResetHairColorId reset all changes of the "hairColorId" field.
func (m *CattleMutation) ResetHairColorId() {
	m.hairColorId = nil
	m.addhairColorId = nil
}

// SetHairColorName sets the hairColorName field.
func (m *CattleMutation) SetHairColorName(s string) {
	m.hairColorName = &s
}

// HairColorName returns the hairColorName value in the mutation.
func (m *CattleMutation) HairColorName() (r string, exists bool) {
	v := m.hairColorName
	if v == nil {
		return
	}
	return *v, true
}

// OldHairColorName returns the old hairColorName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldHairColorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairColorName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairColorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairColorName: %w", err)
	}
	return oldValue.HairColorName, nil
}

// ResetHairColorName reset all changes of the "hairColorName" field.
func (m *CattleMutation) ResetHairColorName() {
	m.hairColorName = nil
}

// SetReproductiveStateId sets the reproductiveStateId field.
func (m *CattleMutation) SetReproductiveStateId(i int) {
	m.reproductiveStateId = &i
	m.addreproductiveStateId = nil
}

// ReproductiveStateId returns the reproductiveStateId value in the mutation.
func (m *CattleMutation) ReproductiveStateId() (r int, exists bool) {
	v := m.reproductiveStateId
	if v == nil {
		return
	}
	return *v, true
}

// OldReproductiveStateId returns the old reproductiveStateId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldReproductiveStateId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReproductiveStateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReproductiveStateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReproductiveStateId: %w", err)
	}
	return oldValue.ReproductiveStateId, nil
}

// AddReproductiveStateId adds i to reproductiveStateId.
func (m *CattleMutation) AddReproductiveStateId(i int) {
	if m.addreproductiveStateId != nil {
		*m.addreproductiveStateId += i
	} else {
		m.addreproductiveStateId = &i
	}
}

// AddedReproductiveStateId returns the value that was added to the reproductiveStateId field in this mutation.
func (m *CattleMutation) AddedReproductiveStateId() (r int, exists bool) {
	v := m.addreproductiveStateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetReproductiveStateId reset all changes of the "reproductiveStateId" field.
func (m *CattleMutation) ResetReproductiveStateId() {
	m.reproductiveStateId = nil
	m.addreproductiveStateId = nil
}

// SetReproductiveStateName sets the reproductiveStateName field.
func (m *CattleMutation) SetReproductiveStateName(s string) {
	m.reproductiveStateName = &s
}

// ReproductiveStateName returns the reproductiveStateName value in the mutation.
func (m *CattleMutation) ReproductiveStateName() (r string, exists bool) {
	v := m.reproductiveStateName
	if v == nil {
		return
	}
	return *v, true
}

// OldReproductiveStateName returns the old reproductiveStateName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldReproductiveStateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReproductiveStateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReproductiveStateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReproductiveStateName: %w", err)
	}
	return oldValue.ReproductiveStateName, nil
}

// ResetReproductiveStateName reset all changes of the "reproductiveStateName" field.
func (m *CattleMutation) ResetReproductiveStateName() {
	m.reproductiveStateName = nil
}

// SetPregnantTimes sets the pregnantTimes field.
func (m *CattleMutation) SetPregnantTimes(i int) {
	m.pregnantTimes = &i
	m.addpregnantTimes = nil
}

// PregnantTimes returns the pregnantTimes value in the mutation.
func (m *CattleMutation) PregnantTimes() (r int, exists bool) {
	v := m.pregnantTimes
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnantTimes returns the old pregnantTimes value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldPregnantTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnantTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnantTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnantTimes: %w", err)
	}
	return oldValue.PregnantTimes, nil
}

// AddPregnantTimes adds i to pregnantTimes.
func (m *CattleMutation) AddPregnantTimes(i int) {
	if m.addpregnantTimes != nil {
		*m.addpregnantTimes += i
	} else {
		m.addpregnantTimes = &i
	}
}

// AddedPregnantTimes returns the value that was added to the pregnantTimes field in this mutation.
func (m *CattleMutation) AddedPregnantTimes() (r int, exists bool) {
	v := m.addpregnantTimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnantTimes reset all changes of the "pregnantTimes" field.
func (m *CattleMutation) ResetPregnantTimes() {
	m.pregnantTimes = nil
	m.addpregnantTimes = nil
}

// SetLastCalvingAt sets the lastCalvingAt field.
func (m *CattleMutation) SetLastCalvingAt(i int64) {
	m.lastCalvingAt = &i
	m.addlastCalvingAt = nil
}

// LastCalvingAt returns the lastCalvingAt value in the mutation.
func (m *CattleMutation) LastCalvingAt() (r int64, exists bool) {
	v := m.lastCalvingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCalvingAt returns the old lastCalvingAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldLastCalvingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastCalvingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastCalvingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCalvingAt: %w", err)
	}
	return oldValue.LastCalvingAt, nil
}

// AddLastCalvingAt adds i to lastCalvingAt.
func (m *CattleMutation) AddLastCalvingAt(i int64) {
	if m.addlastCalvingAt != nil {
		*m.addlastCalvingAt += i
	} else {
		m.addlastCalvingAt = &i
	}
}

// AddedLastCalvingAt returns the value that was added to the lastCalvingAt field in this mutation.
func (m *CattleMutation) AddedLastCalvingAt() (r int64, exists bool) {
	v := m.addlastCalvingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastCalvingAt reset all changes of the "lastCalvingAt" field.
func (m *CattleMutation) ResetLastCalvingAt() {
	m.lastCalvingAt = nil
	m.addlastCalvingAt = nil
}

// SetBreedingAt sets the breedingAt field.
func (m *CattleMutation) SetBreedingAt(i int64) {
	m.breedingAt = &i
	m.addbreedingAt = nil
}

// BreedingAt returns the breedingAt value in the mutation.
func (m *CattleMutation) BreedingAt() (r int64, exists bool) {
	v := m.breedingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingAt returns the old breedingAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreedingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingAt: %w", err)
	}
	return oldValue.BreedingAt, nil
}

// AddBreedingAt adds i to breedingAt.
func (m *CattleMutation) AddBreedingAt(i int64) {
	if m.addbreedingAt != nil {
		*m.addbreedingAt += i
	} else {
		m.addbreedingAt = &i
	}
}

// AddedBreedingAt returns the value that was added to the breedingAt field in this mutation.
func (m *CattleMutation) AddedBreedingAt() (r int64, exists bool) {
	v := m.addbreedingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingAt reset all changes of the "breedingAt" field.
func (m *CattleMutation) ResetBreedingAt() {
	m.breedingAt = nil
	m.addbreedingAt = nil
}

// SetBreedingTypeId sets the breedingTypeId field.
func (m *CattleMutation) SetBreedingTypeId(i int) {
	m.breedingTypeId = &i
	m.addbreedingTypeId = nil
}

// BreedingTypeId returns the breedingTypeId value in the mutation.
func (m *CattleMutation) BreedingTypeId() (r int, exists bool) {
	v := m.breedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeId returns the old breedingTypeId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreedingTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeId: %w", err)
	}
	return oldValue.BreedingTypeId, nil
}

// AddBreedingTypeId adds i to breedingTypeId.
func (m *CattleMutation) AddBreedingTypeId(i int) {
	if m.addbreedingTypeId != nil {
		*m.addbreedingTypeId += i
	} else {
		m.addbreedingTypeId = &i
	}
}

// AddedBreedingTypeId returns the value that was added to the breedingTypeId field in this mutation.
func (m *CattleMutation) AddedBreedingTypeId() (r int, exists bool) {
	v := m.addbreedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingTypeId reset all changes of the "breedingTypeId" field.
func (m *CattleMutation) ResetBreedingTypeId() {
	m.breedingTypeId = nil
	m.addbreedingTypeId = nil
}

// SetBreedingTypeName sets the breedingTypeName field.
func (m *CattleMutation) SetBreedingTypeName(s string) {
	m.breedingTypeName = &s
}

// BreedingTypeName returns the breedingTypeName value in the mutation.
func (m *CattleMutation) BreedingTypeName() (r string, exists bool) {
	v := m.breedingTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeName returns the old breedingTypeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreedingTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeName: %w", err)
	}
	return oldValue.BreedingTypeName, nil
}

// ResetBreedingTypeName reset all changes of the "breedingTypeName" field.
func (m *CattleMutation) ResetBreedingTypeName() {
	m.breedingTypeName = nil
}

// SetBullId sets the bullId field.
func (m *CattleMutation) SetBullId(i int64) {
	m.bullId = &i
	m.addbullId = nil
}

// BullId returns the bullId value in the mutation.
func (m *CattleMutation) BullId() (r int64, exists bool) {
	v := m.bullId
	if v == nil {
		return
	}
	return *v, true
}

// OldBullId returns the old bullId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBullId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBullId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBullId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBullId: %w", err)
	}
	return oldValue.BullId, nil
}

// AddBullId adds i to bullId.
func (m *CattleMutation) AddBullId(i int64) {
	if m.addbullId != nil {
		*m.addbullId += i
	} else {
		m.addbullId = &i
	}
}

// AddedBullId returns the value that was added to the bullId field in this mutation.
func (m *CattleMutation) AddedBullId() (r int64, exists bool) {
	v := m.addbullId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBullId reset all changes of the "bullId" field.
func (m *CattleMutation) ResetBullId() {
	m.bullId = nil
	m.addbullId = nil
}

// SetPregnancyCheckAt sets the pregnancyCheckAt field.
func (m *CattleMutation) SetPregnancyCheckAt(i int64) {
	m.pregnancyCheckAt = &i
	m.addpregnancyCheckAt = nil
}

// PregnancyCheckAt returns the pregnancyCheckAt value in the mutation.
func (m *CattleMutation) PregnancyCheckAt() (r int64, exists bool) {
	v := m.pregnancyCheckAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyCheckAt returns the old pregnancyCheckAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldPregnancyCheckAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyCheckAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyCheckAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyCheckAt: %w", err)
	}
	return oldValue.PregnancyCheckAt, nil
}

// AddPregnancyCheckAt adds i to pregnancyCheckAt.
func (m *CattleMutation) AddPregnancyCheckAt(i int64) {
	if m.addpregnancyCheckAt != nil {
		*m.addpregnancyCheckAt += i
	} else {
		m.addpregnancyCheckAt = &i
	}
}

// AddedPregnancyCheckAt returns the value that was added to the pregnancyCheckAt field in this mutation.
func (m *CattleMutation) AddedPregnancyCheckAt() (r int64, exists bool) {
	v := m.addpregnancyCheckAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyCheckAt reset all changes of the "pregnancyCheckAt" field.
func (m *CattleMutation) ResetPregnancyCheckAt() {
	m.pregnancyCheckAt = nil
	m.addpregnancyCheckAt = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cattle).
func (m *CattleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleMutation) Fields() []string {
	fields := make([]string, 0, 42)
	if m.name != nil {
		fields = append(fields, cattle.FieldName)
	}
	if m.farmId != nil {
		fields = append(fields, cattle.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, cattle.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, cattle.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, cattle.FieldShedName)
	}
	if m.shedTypeId != nil {
		fields = append(fields, cattle.FieldShedTypeId)
	}
	if m.shedTypeName != nil {
		fields = append(fields, cattle.FieldShedTypeName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattle.FieldEarNumber)
	}
	if m.electronicEarNumber != nil {
		fields = append(fields, cattle.FieldElectronicEarNumber)
	}
	if m.pedometer != nil {
		fields = append(fields, cattle.FieldPedometer)
	}
	if m.genderId != nil {
		fields = append(fields, cattle.FieldGenderId)
	}
	if m.genderName != nil {
		fields = append(fields, cattle.FieldGenderName)
	}
	if m.birthday != nil {
		fields = append(fields, cattle.FieldBirthday)
	}
	if m.joinedAt != nil {
		fields = append(fields, cattle.FieldJoinedAt)
	}
	if m.cateId != nil {
		fields = append(fields, cattle.FieldCateId)
	}
	if m.cateName != nil {
		fields = append(fields, cattle.FieldCateName)
	}
	if m._type != nil {
		fields = append(fields, cattle.FieldType)
	}
	if m.typeName != nil {
		fields = append(fields, cattle.FieldTypeName)
	}
	if m.weight != nil {
		fields = append(fields, cattle.FieldWeight)
	}
	if m.from != nil {
		fields = append(fields, cattle.FieldFrom)
	}
	if m.breed != nil {
		fields = append(fields, cattle.FieldBreed)
	}
	if m.joinedTypeId != nil {
		fields = append(fields, cattle.FieldJoinedTypeId)
	}
	if m.joinedTypeName != nil {
		fields = append(fields, cattle.FieldJoinedTypeName)
	}
	if m.mother != nil {
		fields = append(fields, cattle.FieldMother)
	}
	if m.father != nil {
		fields = append(fields, cattle.FieldFather)
	}
	if m.grandfather != nil {
		fields = append(fields, cattle.FieldGrandfather)
	}
	if m.ownerId != nil {
		fields = append(fields, cattle.FieldOwnerId)
	}
	if m.ownerName != nil {
		fields = append(fields, cattle.FieldOwnerName)
	}
	if m.hairColorId != nil {
		fields = append(fields, cattle.FieldHairColorId)
	}
	if m.hairColorName != nil {
		fields = append(fields, cattle.FieldHairColorName)
	}
	if m.reproductiveStateId != nil {
		fields = append(fields, cattle.FieldReproductiveStateId)
	}
	if m.reproductiveStateName != nil {
		fields = append(fields, cattle.FieldReproductiveStateName)
	}
	if m.pregnantTimes != nil {
		fields = append(fields, cattle.FieldPregnantTimes)
	}
	if m.lastCalvingAt != nil {
		fields = append(fields, cattle.FieldLastCalvingAt)
	}
	if m.breedingAt != nil {
		fields = append(fields, cattle.FieldBreedingAt)
	}
	if m.breedingTypeId != nil {
		fields = append(fields, cattle.FieldBreedingTypeId)
	}
	if m.breedingTypeName != nil {
		fields = append(fields, cattle.FieldBreedingTypeName)
	}
	if m.bullId != nil {
		fields = append(fields, cattle.FieldBullId)
	}
	if m.pregnancyCheckAt != nil {
		fields = append(fields, cattle.FieldPregnancyCheckAt)
	}
	if m.createdAt != nil {
		fields = append(fields, cattle.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattle.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattle.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattle.FieldName:
		return m.Name()
	case cattle.FieldFarmId:
		return m.FarmId()
	case cattle.FieldFarmName:
		return m.FarmName()
	case cattle.FieldShedId:
		return m.ShedId()
	case cattle.FieldShedName:
		return m.ShedName()
	case cattle.FieldShedTypeId:
		return m.ShedTypeId()
	case cattle.FieldShedTypeName:
		return m.ShedTypeName()
	case cattle.FieldEarNumber:
		return m.EarNumber()
	case cattle.FieldElectronicEarNumber:
		return m.ElectronicEarNumber()
	case cattle.FieldPedometer:
		return m.Pedometer()
	case cattle.FieldGenderId:
		return m.GenderId()
	case cattle.FieldGenderName:
		return m.GenderName()
	case cattle.FieldBirthday:
		return m.Birthday()
	case cattle.FieldJoinedAt:
		return m.JoinedAt()
	case cattle.FieldCateId:
		return m.CateId()
	case cattle.FieldCateName:
		return m.CateName()
	case cattle.FieldType:
		return m.GetType()
	case cattle.FieldTypeName:
		return m.TypeName()
	case cattle.FieldWeight:
		return m.Weight()
	case cattle.FieldFrom:
		return m.From()
	case cattle.FieldBreed:
		return m.Breed()
	case cattle.FieldJoinedTypeId:
		return m.JoinedTypeId()
	case cattle.FieldJoinedTypeName:
		return m.JoinedTypeName()
	case cattle.FieldMother:
		return m.Mother()
	case cattle.FieldFather:
		return m.Father()
	case cattle.FieldGrandfather:
		return m.Grandfather()
	case cattle.FieldOwnerId:
		return m.OwnerId()
	case cattle.FieldOwnerName:
		return m.OwnerName()
	case cattle.FieldHairColorId:
		return m.HairColorId()
	case cattle.FieldHairColorName:
		return m.HairColorName()
	case cattle.FieldReproductiveStateId:
		return m.ReproductiveStateId()
	case cattle.FieldReproductiveStateName:
		return m.ReproductiveStateName()
	case cattle.FieldPregnantTimes:
		return m.PregnantTimes()
	case cattle.FieldLastCalvingAt:
		return m.LastCalvingAt()
	case cattle.FieldBreedingAt:
		return m.BreedingAt()
	case cattle.FieldBreedingTypeId:
		return m.BreedingTypeId()
	case cattle.FieldBreedingTypeName:
		return m.BreedingTypeName()
	case cattle.FieldBullId:
		return m.BullId()
	case cattle.FieldPregnancyCheckAt:
		return m.PregnancyCheckAt()
	case cattle.FieldCreatedAt:
		return m.CreatedAt()
	case cattle.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattle.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattle.FieldName:
		return m.OldName(ctx)
	case cattle.FieldFarmId:
		return m.OldFarmId(ctx)
	case cattle.FieldFarmName:
		return m.OldFarmName(ctx)
	case cattle.FieldShedId:
		return m.OldShedId(ctx)
	case cattle.FieldShedName:
		return m.OldShedName(ctx)
	case cattle.FieldShedTypeId:
		return m.OldShedTypeId(ctx)
	case cattle.FieldShedTypeName:
		return m.OldShedTypeName(ctx)
	case cattle.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattle.FieldElectronicEarNumber:
		return m.OldElectronicEarNumber(ctx)
	case cattle.FieldPedometer:
		return m.OldPedometer(ctx)
	case cattle.FieldGenderId:
		return m.OldGenderId(ctx)
	case cattle.FieldGenderName:
		return m.OldGenderName(ctx)
	case cattle.FieldBirthday:
		return m.OldBirthday(ctx)
	case cattle.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case cattle.FieldCateId:
		return m.OldCateId(ctx)
	case cattle.FieldCateName:
		return m.OldCateName(ctx)
	case cattle.FieldType:
		return m.OldType(ctx)
	case cattle.FieldTypeName:
		return m.OldTypeName(ctx)
	case cattle.FieldWeight:
		return m.OldWeight(ctx)
	case cattle.FieldFrom:
		return m.OldFrom(ctx)
	case cattle.FieldBreed:
		return m.OldBreed(ctx)
	case cattle.FieldJoinedTypeId:
		return m.OldJoinedTypeId(ctx)
	case cattle.FieldJoinedTypeName:
		return m.OldJoinedTypeName(ctx)
	case cattle.FieldMother:
		return m.OldMother(ctx)
	case cattle.FieldFather:
		return m.OldFather(ctx)
	case cattle.FieldGrandfather:
		return m.OldGrandfather(ctx)
	case cattle.FieldOwnerId:
		return m.OldOwnerId(ctx)
	case cattle.FieldOwnerName:
		return m.OldOwnerName(ctx)
	case cattle.FieldHairColorId:
		return m.OldHairColorId(ctx)
	case cattle.FieldHairColorName:
		return m.OldHairColorName(ctx)
	case cattle.FieldReproductiveStateId:
		return m.OldReproductiveStateId(ctx)
	case cattle.FieldReproductiveStateName:
		return m.OldReproductiveStateName(ctx)
	case cattle.FieldPregnantTimes:
		return m.OldPregnantTimes(ctx)
	case cattle.FieldLastCalvingAt:
		return m.OldLastCalvingAt(ctx)
	case cattle.FieldBreedingAt:
		return m.OldBreedingAt(ctx)
	case cattle.FieldBreedingTypeId:
		return m.OldBreedingTypeId(ctx)
	case cattle.FieldBreedingTypeName:
		return m.OldBreedingTypeName(ctx)
	case cattle.FieldBullId:
		return m.OldBullId(ctx)
	case cattle.FieldPregnancyCheckAt:
		return m.OldPregnancyCheckAt(ctx)
	case cattle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattle.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Cattle field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattle.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattle.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case cattle.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case cattle.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case cattle.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattle.FieldShedTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeId(v)
		return nil
	case cattle.FieldShedTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeName(v)
		return nil
	case cattle.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattle.FieldElectronicEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectronicEarNumber(v)
		return nil
	case cattle.FieldPedometer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPedometer(v)
		return nil
	case cattle.FieldGenderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderId(v)
		return nil
	case cattle.FieldGenderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderName(v)
		return nil
	case cattle.FieldBirthday:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case cattle.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case cattle.FieldCateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCateId(v)
		return nil
	case cattle.FieldCateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCateName(v)
		return nil
	case cattle.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case cattle.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case cattle.FieldWeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case cattle.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case cattle.FieldBreed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreed(v)
		return nil
	case cattle.FieldJoinedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedTypeId(v)
		return nil
	case cattle.FieldJoinedTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedTypeName(v)
		return nil
	case cattle.FieldMother:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMother(v)
		return nil
	case cattle.FieldFather:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFather(v)
		return nil
	case cattle.FieldGrandfather:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrandfather(v)
		return nil
	case cattle.FieldOwnerId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerId(v)
		return nil
	case cattle.FieldOwnerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerName(v)
		return nil
	case cattle.FieldHairColorId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairColorId(v)
		return nil
	case cattle.FieldHairColorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairColorName(v)
		return nil
	case cattle.FieldReproductiveStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReproductiveStateId(v)
		return nil
	case cattle.FieldReproductiveStateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReproductiveStateName(v)
		return nil
	case cattle.FieldPregnantTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnantTimes(v)
		return nil
	case cattle.FieldLastCalvingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCalvingAt(v)
		return nil
	case cattle.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingAt(v)
		return nil
	case cattle.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeId(v)
		return nil
	case cattle.FieldBreedingTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeName(v)
		return nil
	case cattle.FieldBullId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBullId(v)
		return nil
	case cattle.FieldPregnancyCheckAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyCheckAt(v)
		return nil
	case cattle.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattle.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattle.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Cattle field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleMutation) AddedFields() []string {
	var fields []string
	if m.addfarmId != nil {
		fields = append(fields, cattle.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, cattle.FieldShedId)
	}
	if m.addshedTypeId != nil {
		fields = append(fields, cattle.FieldShedTypeId)
	}
	if m.addgenderId != nil {
		fields = append(fields, cattle.FieldGenderId)
	}
	if m.addbirthday != nil {
		fields = append(fields, cattle.FieldBirthday)
	}
	if m.addjoinedAt != nil {
		fields = append(fields, cattle.FieldJoinedAt)
	}
	if m.addcateId != nil {
		fields = append(fields, cattle.FieldCateId)
	}
	if m.add_type != nil {
		fields = append(fields, cattle.FieldType)
	}
	if m.addweight != nil {
		fields = append(fields, cattle.FieldWeight)
	}
	if m.addjoinedTypeId != nil {
		fields = append(fields, cattle.FieldJoinedTypeId)
	}
	if m.addownerId != nil {
		fields = append(fields, cattle.FieldOwnerId)
	}
	if m.addhairColorId != nil {
		fields = append(fields, cattle.FieldHairColorId)
	}
	if m.addreproductiveStateId != nil {
		fields = append(fields, cattle.FieldReproductiveStateId)
	}
	if m.addpregnantTimes != nil {
		fields = append(fields, cattle.FieldPregnantTimes)
	}
	if m.addlastCalvingAt != nil {
		fields = append(fields, cattle.FieldLastCalvingAt)
	}
	if m.addbreedingAt != nil {
		fields = append(fields, cattle.FieldBreedingAt)
	}
	if m.addbreedingTypeId != nil {
		fields = append(fields, cattle.FieldBreedingTypeId)
	}
	if m.addbullId != nil {
		fields = append(fields, cattle.FieldBullId)
	}
	if m.addpregnancyCheckAt != nil {
		fields = append(fields, cattle.FieldPregnancyCheckAt)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattle.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattle.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattle.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattle.FieldFarmId:
		return m.AddedFarmId()
	case cattle.FieldShedId:
		return m.AddedShedId()
	case cattle.FieldShedTypeId:
		return m.AddedShedTypeId()
	case cattle.FieldGenderId:
		return m.AddedGenderId()
	case cattle.FieldBirthday:
		return m.AddedBirthday()
	case cattle.FieldJoinedAt:
		return m.AddedJoinedAt()
	case cattle.FieldCateId:
		return m.AddedCateId()
	case cattle.FieldType:
		return m.AddedType()
	case cattle.FieldWeight:
		return m.AddedWeight()
	case cattle.FieldJoinedTypeId:
		return m.AddedJoinedTypeId()
	case cattle.FieldOwnerId:
		return m.AddedOwnerId()
	case cattle.FieldHairColorId:
		return m.AddedHairColorId()
	case cattle.FieldReproductiveStateId:
		return m.AddedReproductiveStateId()
	case cattle.FieldPregnantTimes:
		return m.AddedPregnantTimes()
	case cattle.FieldLastCalvingAt:
		return m.AddedLastCalvingAt()
	case cattle.FieldBreedingAt:
		return m.AddedBreedingAt()
	case cattle.FieldBreedingTypeId:
		return m.AddedBreedingTypeId()
	case cattle.FieldBullId:
		return m.AddedBullId()
	case cattle.FieldPregnancyCheckAt:
		return m.AddedPregnancyCheckAt()
	case cattle.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattle.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattle.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattle.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case cattle.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case cattle.FieldShedTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedTypeId(v)
		return nil
	case cattle.FieldGenderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGenderId(v)
		return nil
	case cattle.FieldBirthday:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	case cattle.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinedAt(v)
		return nil
	case cattle.FieldCateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCateId(v)
		return nil
	case cattle.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case cattle.FieldWeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case cattle.FieldJoinedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinedTypeId(v)
		return nil
	case cattle.FieldOwnerId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerId(v)
		return nil
	case cattle.FieldHairColorId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHairColorId(v)
		return nil
	case cattle.FieldReproductiveStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReproductiveStateId(v)
		return nil
	case cattle.FieldPregnantTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnantTimes(v)
		return nil
	case cattle.FieldLastCalvingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastCalvingAt(v)
		return nil
	case cattle.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingAt(v)
		return nil
	case cattle.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingTypeId(v)
		return nil
	case cattle.FieldBullId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBullId(v)
		return nil
	case cattle.FieldPregnancyCheckAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyCheckAt(v)
		return nil
	case cattle.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattle.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattle.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Cattle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattle.FieldName) {
		fields = append(fields, cattle.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleMutation) ClearField(name string) error {
	switch name {
	case cattle.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Cattle nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleMutation) ResetField(name string) error {
	switch name {
	case cattle.FieldName:
		m.ResetName()
		return nil
	case cattle.FieldFarmId:
		m.ResetFarmId()
		return nil
	case cattle.FieldFarmName:
		m.ResetFarmName()
		return nil
	case cattle.FieldShedId:
		m.ResetShedId()
		return nil
	case cattle.FieldShedName:
		m.ResetShedName()
		return nil
	case cattle.FieldShedTypeId:
		m.ResetShedTypeId()
		return nil
	case cattle.FieldShedTypeName:
		m.ResetShedTypeName()
		return nil
	case cattle.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattle.FieldElectronicEarNumber:
		m.ResetElectronicEarNumber()
		return nil
	case cattle.FieldPedometer:
		m.ResetPedometer()
		return nil
	case cattle.FieldGenderId:
		m.ResetGenderId()
		return nil
	case cattle.FieldGenderName:
		m.ResetGenderName()
		return nil
	case cattle.FieldBirthday:
		m.ResetBirthday()
		return nil
	case cattle.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case cattle.FieldCateId:
		m.ResetCateId()
		return nil
	case cattle.FieldCateName:
		m.ResetCateName()
		return nil
	case cattle.FieldType:
		m.ResetType()
		return nil
	case cattle.FieldTypeName:
		m.ResetTypeName()
		return nil
	case cattle.FieldWeight:
		m.ResetWeight()
		return nil
	case cattle.FieldFrom:
		m.ResetFrom()
		return nil
	case cattle.FieldBreed:
		m.ResetBreed()
		return nil
	case cattle.FieldJoinedTypeId:
		m.ResetJoinedTypeId()
		return nil
	case cattle.FieldJoinedTypeName:
		m.ResetJoinedTypeName()
		return nil
	case cattle.FieldMother:
		m.ResetMother()
		return nil
	case cattle.FieldFather:
		m.ResetFather()
		return nil
	case cattle.FieldGrandfather:
		m.ResetGrandfather()
		return nil
	case cattle.FieldOwnerId:
		m.ResetOwnerId()
		return nil
	case cattle.FieldOwnerName:
		m.ResetOwnerName()
		return nil
	case cattle.FieldHairColorId:
		m.ResetHairColorId()
		return nil
	case cattle.FieldHairColorName:
		m.ResetHairColorName()
		return nil
	case cattle.FieldReproductiveStateId:
		m.ResetReproductiveStateId()
		return nil
	case cattle.FieldReproductiveStateName:
		m.ResetReproductiveStateName()
		return nil
	case cattle.FieldPregnantTimes:
		m.ResetPregnantTimes()
		return nil
	case cattle.FieldLastCalvingAt:
		m.ResetLastCalvingAt()
		return nil
	case cattle.FieldBreedingAt:
		m.ResetBreedingAt()
		return nil
	case cattle.FieldBreedingTypeId:
		m.ResetBreedingTypeId()
		return nil
	case cattle.FieldBreedingTypeName:
		m.ResetBreedingTypeName()
		return nil
	case cattle.FieldBullId:
		m.ResetBullId()
		return nil
	case cattle.FieldPregnancyCheckAt:
		m.ResetPregnancyCheckAt()
		return nil
	case cattle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattle.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Cattle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cattle unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cattle edge %s", name)
}

// CattleCateMutation represents an operation that mutate the CattleCates
// nodes in the graph.
type CattleCateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	genderIds     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleCate, error)
}

var _ ent.Mutation = (*CattleCateMutation)(nil)

// cattlecateOption allows to manage the mutation configuration using functional options.
type cattlecateOption func(*CattleCateMutation)

// newCattleCateMutation creates new mutation for $n.Name.
func newCattleCateMutation(c config, op Op, opts ...cattlecateOption) *CattleCateMutation {
	m := &CattleCateMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleCate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleCateID sets the id field of the mutation.
func withCattleCateID(id int64) cattlecateOption {
	return func(m *CattleCateMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleCate
		)
		m.oldValue = func(ctx context.Context) (*CattleCate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleCate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleCate sets the old CattleCate of the mutation.
func withCattleCate(node *CattleCate) cattlecateOption {
	return func(m *CattleCateMutation) {
		m.oldValue = func(context.Context) (*CattleCate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleCateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleCateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleCateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleCateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleCateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleCate.
// If the CattleCate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleCateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleCateMutation) ResetName() {
	m.name = nil
}

// SetGenderIds sets the genderIds field.
func (m *CattleCateMutation) SetGenderIds(s string) {
	m.genderIds = &s
}

// GenderIds returns the genderIds value in the mutation.
func (m *CattleCateMutation) GenderIds() (r string, exists bool) {
	v := m.genderIds
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderIds returns the old genderIds value of the CattleCate.
// If the CattleCate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleCateMutation) OldGenderIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderIds is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderIds: %w", err)
	}
	return oldValue.GenderIds, nil
}

// ResetGenderIds reset all changes of the "genderIds" field.
func (m *CattleCateMutation) ResetGenderIds() {
	m.genderIds = nil
}

// Op returns the operation name.
func (m *CattleCateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleCate).
func (m *CattleCateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleCateMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, cattlecate.FieldName)
	}
	if m.genderIds != nil {
		fields = append(fields, cattlecate.FieldGenderIds)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleCateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlecate.FieldName:
		return m.Name()
	case cattlecate.FieldGenderIds:
		return m.GenderIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleCateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlecate.FieldName:
		return m.OldName(ctx)
	case cattlecate.FieldGenderIds:
		return m.OldGenderIds(ctx)
	}
	return nil, fmt.Errorf("unknown CattleCate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleCateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlecate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlecate.FieldGenderIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderIds(v)
		return nil
	}
	return fmt.Errorf("unknown CattleCate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleCateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleCateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleCateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleCate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleCateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleCateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleCateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleCate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleCateMutation) ResetField(name string) error {
	switch name {
	case cattlecate.FieldName:
		m.ResetName()
		return nil
	case cattlecate.FieldGenderIds:
		m.ResetGenderIds()
		return nil
	}
	return fmt.Errorf("unknown CattleCate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleCateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleCateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleCateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleCateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleCateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleCateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleCateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleCate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleCateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleCate edge %s", name)
}

// CattleGenderMutation represents an operation that mutate the CattleGenders
// nodes in the graph.
type CattleGenderMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleGender, error)
}

var _ ent.Mutation = (*CattleGenderMutation)(nil)

// cattlegenderOption allows to manage the mutation configuration using functional options.
type cattlegenderOption func(*CattleGenderMutation)

// newCattleGenderMutation creates new mutation for $n.Name.
func newCattleGenderMutation(c config, op Op, opts ...cattlegenderOption) *CattleGenderMutation {
	m := &CattleGenderMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGenderID sets the id field of the mutation.
func withCattleGenderID(id int64) cattlegenderOption {
	return func(m *CattleGenderMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGender
		)
		m.oldValue = func(ctx context.Context) (*CattleGender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGender sets the old CattleGender of the mutation.
func withCattleGender(node *CattleGender) cattlegenderOption {
	return func(m *CattleGenderMutation) {
		m.oldValue = func(context.Context) (*CattleGender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGenderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleGenderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGenderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGender.
// If the CattleGender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGenderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleGenderMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleGenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGender).
func (m *CattleGenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattlegender.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegender.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegender.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegender.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleGender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleGender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGenderMutation) ResetField(name string) error {
	switch name {
	case cattlegender.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleGender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGenderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGenderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGenderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGenderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGenderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGender edge %s", name)
}

// CattleGrowMutation represents an operation that mutate the CattleGrows
// nodes in the graph.
type CattleGrowMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	earNumber          *string
	stage              *string
	dateStart          *int64
	adddateStart       *int64
	dateEnd            *int64
	adddateEnd         *int64
	weightStart        *float32
	addweightStart     *float32
	weightEnd          *float32
	addweightEnd       *float32
	dailyWeight        *float32
	adddailyWeight     *float32
	feedWeight         *float32
	addfeedWeight      *float32
	dailyFeedWeight    *float32
	adddailyFeedWeight *float32
	conversionRate     *float32
	addconversionRate  *float32
	userName           *string
	remarks            *string
	createdAt          *int64
	addcreatedAt       *int64
	updatedAt          *int64
	addupdatedAt       *int64
	deleted            *int
	adddeleted         *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*CattleGrow, error)
}

var _ ent.Mutation = (*CattleGrowMutation)(nil)

// cattlegrowOption allows to manage the mutation configuration using functional options.
type cattlegrowOption func(*CattleGrowMutation)

// newCattleGrowMutation creates new mutation for $n.Name.
func newCattleGrowMutation(c config, op Op, opts ...cattlegrowOption) *CattleGrowMutation {
	m := &CattleGrowMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGrow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGrowID sets the id field of the mutation.
func withCattleGrowID(id int64) cattlegrowOption {
	return func(m *CattleGrowMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGrow
		)
		m.oldValue = func(ctx context.Context) (*CattleGrow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGrow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGrow sets the old CattleGrow of the mutation.
func withCattleGrow(node *CattleGrow) cattlegrowOption {
	return func(m *CattleGrowMutation) {
		m.oldValue = func(context.Context) (*CattleGrow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGrowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGrowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGrowMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleGrowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGrowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleGrowMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattlegrow.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleGrowMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattlegrow.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleGrowMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattlegrow.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CattleGrowMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleGrowMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleGrowMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetStage sets the stage field.
func (m *CattleGrowMutation) SetStage(s string) {
	m.stage = &s
}

// Stage returns the stage value in the mutation.
func (m *CattleGrowMutation) Stage() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStage returns the old stage value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldStage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStage: %w", err)
	}
	return oldValue.Stage, nil
}

// ResetStage reset all changes of the "stage" field.
func (m *CattleGrowMutation) ResetStage() {
	m.stage = nil
}

// SetDateStart sets the dateStart field.
func (m *CattleGrowMutation) SetDateStart(i int64) {
	m.dateStart = &i
	m.adddateStart = nil
}

// DateStart returns the dateStart value in the mutation.
func (m *CattleGrowMutation) DateStart() (r int64, exists bool) {
	v := m.dateStart
	if v == nil {
		return
	}
	return *v, true
}

// OldDateStart returns the old dateStart value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDateStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateStart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateStart: %w", err)
	}
	return oldValue.DateStart, nil
}

// AddDateStart adds i to dateStart.
func (m *CattleGrowMutation) AddDateStart(i int64) {
	if m.adddateStart != nil {
		*m.adddateStart += i
	} else {
		m.adddateStart = &i
	}
}

// AddedDateStart returns the value that was added to the dateStart field in this mutation.
func (m *CattleGrowMutation) AddedDateStart() (r int64, exists bool) {
	v := m.adddateStart
	if v == nil {
		return
	}
	return *v, true
}

// ResetDateStart reset all changes of the "dateStart" field.
func (m *CattleGrowMutation) ResetDateStart() {
	m.dateStart = nil
	m.adddateStart = nil
}

// SetDateEnd sets the dateEnd field.
func (m *CattleGrowMutation) SetDateEnd(i int64) {
	m.dateEnd = &i
	m.adddateEnd = nil
}

// DateEnd returns the dateEnd value in the mutation.
func (m *CattleGrowMutation) DateEnd() (r int64, exists bool) {
	v := m.dateEnd
	if v == nil {
		return
	}
	return *v, true
}

// OldDateEnd returns the old dateEnd value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDateEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateEnd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateEnd: %w", err)
	}
	return oldValue.DateEnd, nil
}

// AddDateEnd adds i to dateEnd.
func (m *CattleGrowMutation) AddDateEnd(i int64) {
	if m.adddateEnd != nil {
		*m.adddateEnd += i
	} else {
		m.adddateEnd = &i
	}
}

// AddedDateEnd returns the value that was added to the dateEnd field in this mutation.
func (m *CattleGrowMutation) AddedDateEnd() (r int64, exists bool) {
	v := m.adddateEnd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDateEnd reset all changes of the "dateEnd" field.
func (m *CattleGrowMutation) ResetDateEnd() {
	m.dateEnd = nil
	m.adddateEnd = nil
}

// SetWeightStart sets the weightStart field.
func (m *CattleGrowMutation) SetWeightStart(f float32) {
	m.weightStart = &f
	m.addweightStart = nil
}

// WeightStart returns the weightStart value in the mutation.
func (m *CattleGrowMutation) WeightStart() (r float32, exists bool) {
	v := m.weightStart
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightStart returns the old weightStart value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldWeightStart(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightStart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightStart: %w", err)
	}
	return oldValue.WeightStart, nil
}

// AddWeightStart adds f to weightStart.
func (m *CattleGrowMutation) AddWeightStart(f float32) {
	if m.addweightStart != nil {
		*m.addweightStart += f
	} else {
		m.addweightStart = &f
	}
}

// AddedWeightStart returns the value that was added to the weightStart field in this mutation.
func (m *CattleGrowMutation) AddedWeightStart() (r float32, exists bool) {
	v := m.addweightStart
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightStart reset all changes of the "weightStart" field.
func (m *CattleGrowMutation) ResetWeightStart() {
	m.weightStart = nil
	m.addweightStart = nil
}

// SetWeightEnd sets the weightEnd field.
func (m *CattleGrowMutation) SetWeightEnd(f float32) {
	m.weightEnd = &f
	m.addweightEnd = nil
}

// WeightEnd returns the weightEnd value in the mutation.
func (m *CattleGrowMutation) WeightEnd() (r float32, exists bool) {
	v := m.weightEnd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightEnd returns the old weightEnd value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldWeightEnd(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightEnd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightEnd: %w", err)
	}
	return oldValue.WeightEnd, nil
}

// AddWeightEnd adds f to weightEnd.
func (m *CattleGrowMutation) AddWeightEnd(f float32) {
	if m.addweightEnd != nil {
		*m.addweightEnd += f
	} else {
		m.addweightEnd = &f
	}
}

// AddedWeightEnd returns the value that was added to the weightEnd field in this mutation.
func (m *CattleGrowMutation) AddedWeightEnd() (r float32, exists bool) {
	v := m.addweightEnd
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightEnd reset all changes of the "weightEnd" field.
func (m *CattleGrowMutation) ResetWeightEnd() {
	m.weightEnd = nil
	m.addweightEnd = nil
}

// SetDailyWeight sets the dailyWeight field.
func (m *CattleGrowMutation) SetDailyWeight(f float32) {
	m.dailyWeight = &f
	m.adddailyWeight = nil
}

// DailyWeight returns the dailyWeight value in the mutation.
func (m *CattleGrowMutation) DailyWeight() (r float32, exists bool) {
	v := m.dailyWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyWeight returns the old dailyWeight value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDailyWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyWeight: %w", err)
	}
	return oldValue.DailyWeight, nil
}

// AddDailyWeight adds f to dailyWeight.
func (m *CattleGrowMutation) AddDailyWeight(f float32) {
	if m.adddailyWeight != nil {
		*m.adddailyWeight += f
	} else {
		m.adddailyWeight = &f
	}
}

// AddedDailyWeight returns the value that was added to the dailyWeight field in this mutation.
func (m *CattleGrowMutation) AddedDailyWeight() (r float32, exists bool) {
	v := m.adddailyWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyWeight reset all changes of the "dailyWeight" field.
func (m *CattleGrowMutation) ResetDailyWeight() {
	m.dailyWeight = nil
	m.adddailyWeight = nil
}

// SetFeedWeight sets the feedWeight field.
func (m *CattleGrowMutation) SetFeedWeight(f float32) {
	m.feedWeight = &f
	m.addfeedWeight = nil
}

// FeedWeight returns the feedWeight value in the mutation.
func (m *CattleGrowMutation) FeedWeight() (r float32, exists bool) {
	v := m.feedWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedWeight returns the old feedWeight value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldFeedWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFeedWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFeedWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedWeight: %w", err)
	}
	return oldValue.FeedWeight, nil
}

// AddFeedWeight adds f to feedWeight.
func (m *CattleGrowMutation) AddFeedWeight(f float32) {
	if m.addfeedWeight != nil {
		*m.addfeedWeight += f
	} else {
		m.addfeedWeight = &f
	}
}

// AddedFeedWeight returns the value that was added to the feedWeight field in this mutation.
func (m *CattleGrowMutation) AddedFeedWeight() (r float32, exists bool) {
	v := m.addfeedWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetFeedWeight reset all changes of the "feedWeight" field.
func (m *CattleGrowMutation) ResetFeedWeight() {
	m.feedWeight = nil
	m.addfeedWeight = nil
}

// SetDailyFeedWeight sets the dailyFeedWeight field.
func (m *CattleGrowMutation) SetDailyFeedWeight(f float32) {
	m.dailyFeedWeight = &f
	m.adddailyFeedWeight = nil
}

// DailyFeedWeight returns the dailyFeedWeight value in the mutation.
func (m *CattleGrowMutation) DailyFeedWeight() (r float32, exists bool) {
	v := m.dailyFeedWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyFeedWeight returns the old dailyFeedWeight value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDailyFeedWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyFeedWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyFeedWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyFeedWeight: %w", err)
	}
	return oldValue.DailyFeedWeight, nil
}

// AddDailyFeedWeight adds f to dailyFeedWeight.
func (m *CattleGrowMutation) AddDailyFeedWeight(f float32) {
	if m.adddailyFeedWeight != nil {
		*m.adddailyFeedWeight += f
	} else {
		m.adddailyFeedWeight = &f
	}
}

// AddedDailyFeedWeight returns the value that was added to the dailyFeedWeight field in this mutation.
func (m *CattleGrowMutation) AddedDailyFeedWeight() (r float32, exists bool) {
	v := m.adddailyFeedWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyFeedWeight reset all changes of the "dailyFeedWeight" field.
func (m *CattleGrowMutation) ResetDailyFeedWeight() {
	m.dailyFeedWeight = nil
	m.adddailyFeedWeight = nil
}

// SetConversionRate sets the conversionRate field.
func (m *CattleGrowMutation) SetConversionRate(f float32) {
	m.conversionRate = &f
	m.addconversionRate = nil
}

// ConversionRate returns the conversionRate value in the mutation.
func (m *CattleGrowMutation) ConversionRate() (r float32, exists bool) {
	v := m.conversionRate
	if v == nil {
		return
	}
	return *v, true
}

// OldConversionRate returns the old conversionRate value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldConversionRate(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConversionRate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversionRate: %w", err)
	}
	return oldValue.ConversionRate, nil
}

// AddConversionRate adds f to conversionRate.
func (m *CattleGrowMutation) AddConversionRate(f float32) {
	if m.addconversionRate != nil {
		*m.addconversionRate += f
	} else {
		m.addconversionRate = &f
	}
}

// AddedConversionRate returns the value that was added to the conversionRate field in this mutation.
func (m *CattleGrowMutation) AddedConversionRate() (r float32, exists bool) {
	v := m.addconversionRate
	if v == nil {
		return
	}
	return *v, true
}

// ResetConversionRate reset all changes of the "conversionRate" field.
func (m *CattleGrowMutation) ResetConversionRate() {
	m.conversionRate = nil
	m.addconversionRate = nil
}

// SetUserName sets the userName field.
func (m *CattleGrowMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CattleGrowMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CattleGrowMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleGrowMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleGrowMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleGrowMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleGrowMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleGrowMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleGrowMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleGrowMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleGrowMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleGrowMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleGrowMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleGrowMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleGrowMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleGrowMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleGrowMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleGrowMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleGrowMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleGrowMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleGrowMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleGrowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGrow).
func (m *CattleGrowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGrowMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.name != nil {
		fields = append(fields, cattlegrow.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattlegrow.FieldEarNumber)
	}
	if m.stage != nil {
		fields = append(fields, cattlegrow.FieldStage)
	}
	if m.dateStart != nil {
		fields = append(fields, cattlegrow.FieldDateStart)
	}
	if m.dateEnd != nil {
		fields = append(fields, cattlegrow.FieldDateEnd)
	}
	if m.weightStart != nil {
		fields = append(fields, cattlegrow.FieldWeightStart)
	}
	if m.weightEnd != nil {
		fields = append(fields, cattlegrow.FieldWeightEnd)
	}
	if m.dailyWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyWeight)
	}
	if m.feedWeight != nil {
		fields = append(fields, cattlegrow.FieldFeedWeight)
	}
	if m.dailyFeedWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyFeedWeight)
	}
	if m.conversionRate != nil {
		fields = append(fields, cattlegrow.FieldConversionRate)
	}
	if m.userName != nil {
		fields = append(fields, cattlegrow.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, cattlegrow.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlegrow.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlegrow.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlegrow.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGrowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegrow.FieldName:
		return m.Name()
	case cattlegrow.FieldEarNumber:
		return m.EarNumber()
	case cattlegrow.FieldStage:
		return m.Stage()
	case cattlegrow.FieldDateStart:
		return m.DateStart()
	case cattlegrow.FieldDateEnd:
		return m.DateEnd()
	case cattlegrow.FieldWeightStart:
		return m.WeightStart()
	case cattlegrow.FieldWeightEnd:
		return m.WeightEnd()
	case cattlegrow.FieldDailyWeight:
		return m.DailyWeight()
	case cattlegrow.FieldFeedWeight:
		return m.FeedWeight()
	case cattlegrow.FieldDailyFeedWeight:
		return m.DailyFeedWeight()
	case cattlegrow.FieldConversionRate:
		return m.ConversionRate()
	case cattlegrow.FieldUserName:
		return m.UserName()
	case cattlegrow.FieldRemarks:
		return m.Remarks()
	case cattlegrow.FieldCreatedAt:
		return m.CreatedAt()
	case cattlegrow.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlegrow.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGrowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegrow.FieldName:
		return m.OldName(ctx)
	case cattlegrow.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlegrow.FieldStage:
		return m.OldStage(ctx)
	case cattlegrow.FieldDateStart:
		return m.OldDateStart(ctx)
	case cattlegrow.FieldDateEnd:
		return m.OldDateEnd(ctx)
	case cattlegrow.FieldWeightStart:
		return m.OldWeightStart(ctx)
	case cattlegrow.FieldWeightEnd:
		return m.OldWeightEnd(ctx)
	case cattlegrow.FieldDailyWeight:
		return m.OldDailyWeight(ctx)
	case cattlegrow.FieldFeedWeight:
		return m.OldFeedWeight(ctx)
	case cattlegrow.FieldDailyFeedWeight:
		return m.OldDailyFeedWeight(ctx)
	case cattlegrow.FieldConversionRate:
		return m.OldConversionRate(ctx)
	case cattlegrow.FieldUserName:
		return m.OldUserName(ctx)
	case cattlegrow.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlegrow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlegrow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlegrow.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGrow field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegrow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlegrow.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlegrow.FieldStage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStage(v)
		return nil
	case cattlegrow.FieldDateStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateStart(v)
		return nil
	case cattlegrow.FieldDateEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateEnd(v)
		return nil
	case cattlegrow.FieldWeightStart:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightStart(v)
		return nil
	case cattlegrow.FieldWeightEnd:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightEnd(v)
		return nil
	case cattlegrow.FieldDailyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyWeight(v)
		return nil
	case cattlegrow.FieldFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedWeight(v)
		return nil
	case cattlegrow.FieldDailyFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyFeedWeight(v)
		return nil
	case cattlegrow.FieldConversionRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversionRate(v)
		return nil
	case cattlegrow.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case cattlegrow.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlegrow.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlegrow.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlegrow.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGrowMutation) AddedFields() []string {
	var fields []string
	if m.adddateStart != nil {
		fields = append(fields, cattlegrow.FieldDateStart)
	}
	if m.adddateEnd != nil {
		fields = append(fields, cattlegrow.FieldDateEnd)
	}
	if m.addweightStart != nil {
		fields = append(fields, cattlegrow.FieldWeightStart)
	}
	if m.addweightEnd != nil {
		fields = append(fields, cattlegrow.FieldWeightEnd)
	}
	if m.adddailyWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyWeight)
	}
	if m.addfeedWeight != nil {
		fields = append(fields, cattlegrow.FieldFeedWeight)
	}
	if m.adddailyFeedWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyFeedWeight)
	}
	if m.addconversionRate != nil {
		fields = append(fields, cattlegrow.FieldConversionRate)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlegrow.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlegrow.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlegrow.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGrowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlegrow.FieldDateStart:
		return m.AddedDateStart()
	case cattlegrow.FieldDateEnd:
		return m.AddedDateEnd()
	case cattlegrow.FieldWeightStart:
		return m.AddedWeightStart()
	case cattlegrow.FieldWeightEnd:
		return m.AddedWeightEnd()
	case cattlegrow.FieldDailyWeight:
		return m.AddedDailyWeight()
	case cattlegrow.FieldFeedWeight:
		return m.AddedFeedWeight()
	case cattlegrow.FieldDailyFeedWeight:
		return m.AddedDailyFeedWeight()
	case cattlegrow.FieldConversionRate:
		return m.AddedConversionRate()
	case cattlegrow.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlegrow.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlegrow.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlegrow.FieldDateStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDateStart(v)
		return nil
	case cattlegrow.FieldDateEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDateEnd(v)
		return nil
	case cattlegrow.FieldWeightStart:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightStart(v)
		return nil
	case cattlegrow.FieldWeightEnd:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightEnd(v)
		return nil
	case cattlegrow.FieldDailyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyWeight(v)
		return nil
	case cattlegrow.FieldFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeedWeight(v)
		return nil
	case cattlegrow.FieldDailyFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyFeedWeight(v)
		return nil
	case cattlegrow.FieldConversionRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConversionRate(v)
		return nil
	case cattlegrow.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlegrow.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlegrow.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGrowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattlegrow.FieldName) {
		fields = append(fields, cattlegrow.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGrowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGrowMutation) ClearField(name string) error {
	switch name {
	case cattlegrow.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown CattleGrow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGrowMutation) ResetField(name string) error {
	switch name {
	case cattlegrow.FieldName:
		m.ResetName()
		return nil
	case cattlegrow.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlegrow.FieldStage:
		m.ResetStage()
		return nil
	case cattlegrow.FieldDateStart:
		m.ResetDateStart()
		return nil
	case cattlegrow.FieldDateEnd:
		m.ResetDateEnd()
		return nil
	case cattlegrow.FieldWeightStart:
		m.ResetWeightStart()
		return nil
	case cattlegrow.FieldWeightEnd:
		m.ResetWeightEnd()
		return nil
	case cattlegrow.FieldDailyWeight:
		m.ResetDailyWeight()
		return nil
	case cattlegrow.FieldFeedWeight:
		m.ResetFeedWeight()
		return nil
	case cattlegrow.FieldDailyFeedWeight:
		m.ResetDailyFeedWeight()
		return nil
	case cattlegrow.FieldConversionRate:
		m.ResetConversionRate()
		return nil
	case cattlegrow.FieldUserName:
		m.ResetUserName()
		return nil
	case cattlegrow.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlegrow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlegrow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlegrow.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleGrow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGrowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGrowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGrowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGrowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGrowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGrowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGrowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGrow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGrowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGrow edge %s", name)
}

// CattleGrowsDataMutation represents an operation that mutate the CattleGrowsDataSlice
// nodes in the graph.
type CattleGrowsDataMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	earNumber     *string
	shedName      *string
	measuredAt    *int64
	addmeasuredAt *int64
	measuredBy    *string
	weight        *int
	addweight     *int
	bust          *int
	addbust       *int
	height        *int
	addheight     *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleGrowsData, error)
}

var _ ent.Mutation = (*CattleGrowsDataMutation)(nil)

// cattlegrowsdataOption allows to manage the mutation configuration using functional options.
type cattlegrowsdataOption func(*CattleGrowsDataMutation)

// newCattleGrowsDataMutation creates new mutation for $n.Name.
func newCattleGrowsDataMutation(c config, op Op, opts ...cattlegrowsdataOption) *CattleGrowsDataMutation {
	m := &CattleGrowsDataMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGrowsData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGrowsDataID sets the id field of the mutation.
func withCattleGrowsDataID(id int64) cattlegrowsdataOption {
	return func(m *CattleGrowsDataMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGrowsData
		)
		m.oldValue = func(ctx context.Context) (*CattleGrowsData, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGrowsData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGrowsData sets the old CattleGrowsData of the mutation.
func withCattleGrowsData(node *CattleGrowsData) cattlegrowsdataOption {
	return func(m *CattleGrowsDataMutation) {
		m.oldValue = func(context.Context) (*CattleGrowsData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGrowsDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGrowsDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGrowsDataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleGrowsDataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGrowsDataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleGrowsDataMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattlegrowsdata.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleGrowsDataMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattlegrowsdata.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleGrowsDataMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattlegrowsdata.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CattleGrowsDataMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleGrowsDataMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleGrowsDataMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetShedName sets the shedName field.
func (m *CattleGrowsDataMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleGrowsDataMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleGrowsDataMutation) ResetShedName() {
	m.shedName = nil
}

// SetMeasuredAt sets the measuredAt field.
func (m *CattleGrowsDataMutation) SetMeasuredAt(i int64) {
	m.measuredAt = &i
	m.addmeasuredAt = nil
}

// MeasuredAt returns the measuredAt value in the mutation.
func (m *CattleGrowsDataMutation) MeasuredAt() (r int64, exists bool) {
	v := m.measuredAt
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasuredAt returns the old measuredAt value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldMeasuredAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMeasuredAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMeasuredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasuredAt: %w", err)
	}
	return oldValue.MeasuredAt, nil
}

// AddMeasuredAt adds i to measuredAt.
func (m *CattleGrowsDataMutation) AddMeasuredAt(i int64) {
	if m.addmeasuredAt != nil {
		*m.addmeasuredAt += i
	} else {
		m.addmeasuredAt = &i
	}
}

// AddedMeasuredAt returns the value that was added to the measuredAt field in this mutation.
func (m *CattleGrowsDataMutation) AddedMeasuredAt() (r int64, exists bool) {
	v := m.addmeasuredAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetMeasuredAt reset all changes of the "measuredAt" field.
func (m *CattleGrowsDataMutation) ResetMeasuredAt() {
	m.measuredAt = nil
	m.addmeasuredAt = nil
}

// SetMeasuredBy sets the measuredBy field.
func (m *CattleGrowsDataMutation) SetMeasuredBy(s string) {
	m.measuredBy = &s
}

// MeasuredBy returns the measuredBy value in the mutation.
func (m *CattleGrowsDataMutation) MeasuredBy() (r string, exists bool) {
	v := m.measuredBy
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasuredBy returns the old measuredBy value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldMeasuredBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMeasuredBy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMeasuredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasuredBy: %w", err)
	}
	return oldValue.MeasuredBy, nil
}

// ResetMeasuredBy reset all changes of the "measuredBy" field.
func (m *CattleGrowsDataMutation) ResetMeasuredBy() {
	m.measuredBy = nil
}

// SetWeight sets the weight field.
func (m *CattleGrowsDataMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *CattleGrowsDataMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *CattleGrowsDataMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *CattleGrowsDataMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *CattleGrowsDataMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetBust sets the bust field.
func (m *CattleGrowsDataMutation) SetBust(i int) {
	m.bust = &i
	m.addbust = nil
}

// Bust returns the bust value in the mutation.
func (m *CattleGrowsDataMutation) Bust() (r int, exists bool) {
	v := m.bust
	if v == nil {
		return
	}
	return *v, true
}

// OldBust returns the old bust value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldBust(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBust is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBust: %w", err)
	}
	return oldValue.Bust, nil
}

// AddBust adds i to bust.
func (m *CattleGrowsDataMutation) AddBust(i int) {
	if m.addbust != nil {
		*m.addbust += i
	} else {
		m.addbust = &i
	}
}

// AddedBust returns the value that was added to the bust field in this mutation.
func (m *CattleGrowsDataMutation) AddedBust() (r int, exists bool) {
	v := m.addbust
	if v == nil {
		return
	}
	return *v, true
}

// ResetBust reset all changes of the "bust" field.
func (m *CattleGrowsDataMutation) ResetBust() {
	m.bust = nil
	m.addbust = nil
}

// SetHeight sets the height field.
func (m *CattleGrowsDataMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the height value in the mutation.
func (m *CattleGrowsDataMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old height value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to height.
func (m *CattleGrowsDataMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the height field in this mutation.
func (m *CattleGrowsDataMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight reset all changes of the "height" field.
func (m *CattleGrowsDataMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetRemarks sets the remarks field.
func (m *CattleGrowsDataMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleGrowsDataMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleGrowsDataMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleGrowsDataMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleGrowsDataMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleGrowsDataMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleGrowsDataMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleGrowsDataMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleGrowsDataMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleGrowsDataMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleGrowsDataMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleGrowsDataMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleGrowsDataMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleGrowsDataMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleGrowsDataMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleGrowsDataMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleGrowsDataMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleGrowsDataMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleGrowsDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGrowsData).
func (m *CattleGrowsDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGrowsDataMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, cattlegrowsdata.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattlegrowsdata.FieldEarNumber)
	}
	if m.shedName != nil {
		fields = append(fields, cattlegrowsdata.FieldShedName)
	}
	if m.measuredAt != nil {
		fields = append(fields, cattlegrowsdata.FieldMeasuredAt)
	}
	if m.measuredBy != nil {
		fields = append(fields, cattlegrowsdata.FieldMeasuredBy)
	}
	if m.weight != nil {
		fields = append(fields, cattlegrowsdata.FieldWeight)
	}
	if m.bust != nil {
		fields = append(fields, cattlegrowsdata.FieldBust)
	}
	if m.height != nil {
		fields = append(fields, cattlegrowsdata.FieldHeight)
	}
	if m.remarks != nil {
		fields = append(fields, cattlegrowsdata.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlegrowsdata.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlegrowsdata.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlegrowsdata.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGrowsDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsdata.FieldName:
		return m.Name()
	case cattlegrowsdata.FieldEarNumber:
		return m.EarNumber()
	case cattlegrowsdata.FieldShedName:
		return m.ShedName()
	case cattlegrowsdata.FieldMeasuredAt:
		return m.MeasuredAt()
	case cattlegrowsdata.FieldMeasuredBy:
		return m.MeasuredBy()
	case cattlegrowsdata.FieldWeight:
		return m.Weight()
	case cattlegrowsdata.FieldBust:
		return m.Bust()
	case cattlegrowsdata.FieldHeight:
		return m.Height()
	case cattlegrowsdata.FieldRemarks:
		return m.Remarks()
	case cattlegrowsdata.FieldCreatedAt:
		return m.CreatedAt()
	case cattlegrowsdata.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlegrowsdata.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGrowsDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegrowsdata.FieldName:
		return m.OldName(ctx)
	case cattlegrowsdata.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlegrowsdata.FieldShedName:
		return m.OldShedName(ctx)
	case cattlegrowsdata.FieldMeasuredAt:
		return m.OldMeasuredAt(ctx)
	case cattlegrowsdata.FieldMeasuredBy:
		return m.OldMeasuredBy(ctx)
	case cattlegrowsdata.FieldWeight:
		return m.OldWeight(ctx)
	case cattlegrowsdata.FieldBust:
		return m.OldBust(ctx)
	case cattlegrowsdata.FieldHeight:
		return m.OldHeight(ctx)
	case cattlegrowsdata.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlegrowsdata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlegrowsdata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlegrowsdata.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGrowsData field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsdata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlegrowsdata.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlegrowsdata.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattlegrowsdata.FieldMeasuredAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasuredAt(v)
		return nil
	case cattlegrowsdata.FieldMeasuredBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasuredBy(v)
		return nil
	case cattlegrowsdata.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case cattlegrowsdata.FieldBust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBust(v)
		return nil
	case cattlegrowsdata.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case cattlegrowsdata.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlegrowsdata.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlegrowsdata.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlegrowsdata.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGrowsDataMutation) AddedFields() []string {
	var fields []string
	if m.addmeasuredAt != nil {
		fields = append(fields, cattlegrowsdata.FieldMeasuredAt)
	}
	if m.addweight != nil {
		fields = append(fields, cattlegrowsdata.FieldWeight)
	}
	if m.addbust != nil {
		fields = append(fields, cattlegrowsdata.FieldBust)
	}
	if m.addheight != nil {
		fields = append(fields, cattlegrowsdata.FieldHeight)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlegrowsdata.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlegrowsdata.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlegrowsdata.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGrowsDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsdata.FieldMeasuredAt:
		return m.AddedMeasuredAt()
	case cattlegrowsdata.FieldWeight:
		return m.AddedWeight()
	case cattlegrowsdata.FieldBust:
		return m.AddedBust()
	case cattlegrowsdata.FieldHeight:
		return m.AddedHeight()
	case cattlegrowsdata.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlegrowsdata.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlegrowsdata.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsdata.FieldMeasuredAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMeasuredAt(v)
		return nil
	case cattlegrowsdata.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case cattlegrowsdata.FieldBust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBust(v)
		return nil
	case cattlegrowsdata.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case cattlegrowsdata.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlegrowsdata.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlegrowsdata.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGrowsDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattlegrowsdata.FieldName) {
		fields = append(fields, cattlegrowsdata.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGrowsDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGrowsDataMutation) ClearField(name string) error {
	switch name {
	case cattlegrowsdata.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGrowsDataMutation) ResetField(name string) error {
	switch name {
	case cattlegrowsdata.FieldName:
		m.ResetName()
		return nil
	case cattlegrowsdata.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlegrowsdata.FieldShedName:
		m.ResetShedName()
		return nil
	case cattlegrowsdata.FieldMeasuredAt:
		m.ResetMeasuredAt()
		return nil
	case cattlegrowsdata.FieldMeasuredBy:
		m.ResetMeasuredBy()
		return nil
	case cattlegrowsdata.FieldWeight:
		m.ResetWeight()
		return nil
	case cattlegrowsdata.FieldBust:
		m.ResetBust()
		return nil
	case cattlegrowsdata.FieldHeight:
		m.ResetHeight()
		return nil
	case cattlegrowsdata.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlegrowsdata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlegrowsdata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlegrowsdata.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGrowsDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGrowsDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGrowsDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGrowsDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGrowsDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGrowsDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGrowsDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsData unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGrowsDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsData edge %s", name)
}

// CattleGrowsRateMutation represents an operation that mutate the CattleGrowsRates
// nodes in the graph.
type CattleGrowsRateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	earNumber     *string
	shedName      *string
	ratedAt       *int64
	addratedAt    *int64
	ratedBy       *string
	rate          *int
	addrate       *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleGrowsRate, error)
}

var _ ent.Mutation = (*CattleGrowsRateMutation)(nil)

// cattlegrowsrateOption allows to manage the mutation configuration using functional options.
type cattlegrowsrateOption func(*CattleGrowsRateMutation)

// newCattleGrowsRateMutation creates new mutation for $n.Name.
func newCattleGrowsRateMutation(c config, op Op, opts ...cattlegrowsrateOption) *CattleGrowsRateMutation {
	m := &CattleGrowsRateMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGrowsRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGrowsRateID sets the id field of the mutation.
func withCattleGrowsRateID(id int64) cattlegrowsrateOption {
	return func(m *CattleGrowsRateMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGrowsRate
		)
		m.oldValue = func(ctx context.Context) (*CattleGrowsRate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGrowsRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGrowsRate sets the old CattleGrowsRate of the mutation.
func withCattleGrowsRate(node *CattleGrowsRate) cattlegrowsrateOption {
	return func(m *CattleGrowsRateMutation) {
		m.oldValue = func(context.Context) (*CattleGrowsRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGrowsRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGrowsRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGrowsRateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleGrowsRateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGrowsRateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleGrowsRateMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattlegrowsrate.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleGrowsRateMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattlegrowsrate.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleGrowsRateMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattlegrowsrate.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CattleGrowsRateMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleGrowsRateMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleGrowsRateMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetShedName sets the shedName field.
func (m *CattleGrowsRateMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleGrowsRateMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleGrowsRateMutation) ResetShedName() {
	m.shedName = nil
}

// SetRatedAt sets the ratedAt field.
func (m *CattleGrowsRateMutation) SetRatedAt(i int64) {
	m.ratedAt = &i
	m.addratedAt = nil
}

// RatedAt returns the ratedAt value in the mutation.
func (m *CattleGrowsRateMutation) RatedAt() (r int64, exists bool) {
	v := m.ratedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldRatedAt returns the old ratedAt value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatedAt: %w", err)
	}
	return oldValue.RatedAt, nil
}

// AddRatedAt adds i to ratedAt.
func (m *CattleGrowsRateMutation) AddRatedAt(i int64) {
	if m.addratedAt != nil {
		*m.addratedAt += i
	} else {
		m.addratedAt = &i
	}
}

// AddedRatedAt returns the value that was added to the ratedAt field in this mutation.
func (m *CattleGrowsRateMutation) AddedRatedAt() (r int64, exists bool) {
	v := m.addratedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatedAt reset all changes of the "ratedAt" field.
func (m *CattleGrowsRateMutation) ResetRatedAt() {
	m.ratedAt = nil
	m.addratedAt = nil
}

// SetRatedBy sets the ratedBy field.
func (m *CattleGrowsRateMutation) SetRatedBy(s string) {
	m.ratedBy = &s
}

// RatedBy returns the ratedBy value in the mutation.
func (m *CattleGrowsRateMutation) RatedBy() (r string, exists bool) {
	v := m.ratedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldRatedBy returns the old ratedBy value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRatedBy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatedBy: %w", err)
	}
	return oldValue.RatedBy, nil
}

// ResetRatedBy reset all changes of the "ratedBy" field.
func (m *CattleGrowsRateMutation) ResetRatedBy() {
	m.ratedBy = nil
}

// SetRate sets the rate field.
func (m *CattleGrowsRateMutation) SetRate(i int) {
	m.rate = &i
	m.addrate = nil
}

// Rate returns the rate value in the mutation.
func (m *CattleGrowsRateMutation) Rate() (r int, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old rate value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds i to rate.
func (m *CattleGrowsRateMutation) AddRate(i int) {
	if m.addrate != nil {
		*m.addrate += i
	} else {
		m.addrate = &i
	}
}

// AddedRate returns the value that was added to the rate field in this mutation.
func (m *CattleGrowsRateMutation) AddedRate() (r int, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate reset all changes of the "rate" field.
func (m *CattleGrowsRateMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetRemarks sets the remarks field.
func (m *CattleGrowsRateMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleGrowsRateMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleGrowsRateMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleGrowsRateMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleGrowsRateMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleGrowsRateMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleGrowsRateMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleGrowsRateMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleGrowsRateMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleGrowsRateMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleGrowsRateMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleGrowsRateMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleGrowsRateMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleGrowsRateMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleGrowsRateMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleGrowsRateMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleGrowsRateMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleGrowsRateMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleGrowsRateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGrowsRate).
func (m *CattleGrowsRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGrowsRateMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, cattlegrowsrate.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattlegrowsrate.FieldEarNumber)
	}
	if m.shedName != nil {
		fields = append(fields, cattlegrowsrate.FieldShedName)
	}
	if m.ratedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldRatedAt)
	}
	if m.ratedBy != nil {
		fields = append(fields, cattlegrowsrate.FieldRatedBy)
	}
	if m.rate != nil {
		fields = append(fields, cattlegrowsrate.FieldRate)
	}
	if m.remarks != nil {
		fields = append(fields, cattlegrowsrate.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlegrowsrate.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlegrowsrate.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGrowsRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsrate.FieldName:
		return m.Name()
	case cattlegrowsrate.FieldEarNumber:
		return m.EarNumber()
	case cattlegrowsrate.FieldShedName:
		return m.ShedName()
	case cattlegrowsrate.FieldRatedAt:
		return m.RatedAt()
	case cattlegrowsrate.FieldRatedBy:
		return m.RatedBy()
	case cattlegrowsrate.FieldRate:
		return m.Rate()
	case cattlegrowsrate.FieldRemarks:
		return m.Remarks()
	case cattlegrowsrate.FieldCreatedAt:
		return m.CreatedAt()
	case cattlegrowsrate.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlegrowsrate.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGrowsRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegrowsrate.FieldName:
		return m.OldName(ctx)
	case cattlegrowsrate.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlegrowsrate.FieldShedName:
		return m.OldShedName(ctx)
	case cattlegrowsrate.FieldRatedAt:
		return m.OldRatedAt(ctx)
	case cattlegrowsrate.FieldRatedBy:
		return m.OldRatedBy(ctx)
	case cattlegrowsrate.FieldRate:
		return m.OldRate(ctx)
	case cattlegrowsrate.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlegrowsrate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlegrowsrate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlegrowsrate.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGrowsRate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsrate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlegrowsrate.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlegrowsrate.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattlegrowsrate.FieldRatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatedAt(v)
		return nil
	case cattlegrowsrate.FieldRatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatedBy(v)
		return nil
	case cattlegrowsrate.FieldRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case cattlegrowsrate.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlegrowsrate.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlegrowsrate.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlegrowsrate.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGrowsRateMutation) AddedFields() []string {
	var fields []string
	if m.addratedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldRatedAt)
	}
	if m.addrate != nil {
		fields = append(fields, cattlegrowsrate.FieldRate)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlegrowsrate.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGrowsRateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsrate.FieldRatedAt:
		return m.AddedRatedAt()
	case cattlegrowsrate.FieldRate:
		return m.AddedRate()
	case cattlegrowsrate.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlegrowsrate.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlegrowsrate.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsrate.FieldRatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatedAt(v)
		return nil
	case cattlegrowsrate.FieldRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	case cattlegrowsrate.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlegrowsrate.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlegrowsrate.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGrowsRateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattlegrowsrate.FieldName) {
		fields = append(fields, cattlegrowsrate.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGrowsRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGrowsRateMutation) ClearField(name string) error {
	switch name {
	case cattlegrowsrate.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGrowsRateMutation) ResetField(name string) error {
	switch name {
	case cattlegrowsrate.FieldName:
		m.ResetName()
		return nil
	case cattlegrowsrate.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlegrowsrate.FieldShedName:
		m.ResetShedName()
		return nil
	case cattlegrowsrate.FieldRatedAt:
		m.ResetRatedAt()
		return nil
	case cattlegrowsrate.FieldRatedBy:
		m.ResetRatedBy()
		return nil
	case cattlegrowsrate.FieldRate:
		m.ResetRate()
		return nil
	case cattlegrowsrate.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlegrowsrate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlegrowsrate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlegrowsrate.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGrowsRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGrowsRateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGrowsRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGrowsRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGrowsRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGrowsRateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGrowsRateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsRate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGrowsRateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsRate edge %s", name)
}

// CattleHairColorMutation represents an operation that mutate the CattleHairColors
// nodes in the graph.
type CattleHairColorMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleHairColor, error)
}

var _ ent.Mutation = (*CattleHairColorMutation)(nil)

// cattlehaircolorOption allows to manage the mutation configuration using functional options.
type cattlehaircolorOption func(*CattleHairColorMutation)

// newCattleHairColorMutation creates new mutation for $n.Name.
func newCattleHairColorMutation(c config, op Op, opts ...cattlehaircolorOption) *CattleHairColorMutation {
	m := &CattleHairColorMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleHairColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleHairColorID sets the id field of the mutation.
func withCattleHairColorID(id int64) cattlehaircolorOption {
	return func(m *CattleHairColorMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleHairColor
		)
		m.oldValue = func(ctx context.Context) (*CattleHairColor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleHairColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleHairColor sets the old CattleHairColor of the mutation.
func withCattleHairColor(node *CattleHairColor) cattlehaircolorOption {
	return func(m *CattleHairColorMutation) {
		m.oldValue = func(context.Context) (*CattleHairColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleHairColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleHairColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleHairColorMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleHairColorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleHairColorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleHairColorMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleHairColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleHairColor).
func (m *CattleHairColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleHairColorMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattlehaircolor.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleHairColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlehaircolor.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleHairColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlehaircolor.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleHairColor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleHairColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlehaircolor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleHairColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleHairColorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleHairColorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleHairColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleHairColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleHairColorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleHairColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleHairColorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleHairColor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleHairColorMutation) ResetField(name string) error {
	switch name {
	case cattlehaircolor.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleHairColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleHairColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleHairColorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleHairColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleHairColorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleHairColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleHairColorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleHairColorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleHairColor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleHairColorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleHairColor edge %s", name)
}

// CattleJoinedTypeMutation represents an operation that mutate the CattleJoinedTypes
// nodes in the graph.
type CattleJoinedTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleJoinedType, error)
}

var _ ent.Mutation = (*CattleJoinedTypeMutation)(nil)

// cattlejoinedtypeOption allows to manage the mutation configuration using functional options.
type cattlejoinedtypeOption func(*CattleJoinedTypeMutation)

// newCattleJoinedTypeMutation creates new mutation for $n.Name.
func newCattleJoinedTypeMutation(c config, op Op, opts ...cattlejoinedtypeOption) *CattleJoinedTypeMutation {
	m := &CattleJoinedTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleJoinedType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleJoinedTypeID sets the id field of the mutation.
func withCattleJoinedTypeID(id int64) cattlejoinedtypeOption {
	return func(m *CattleJoinedTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleJoinedType
		)
		m.oldValue = func(ctx context.Context) (*CattleJoinedType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleJoinedType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleJoinedType sets the old CattleJoinedType of the mutation.
func withCattleJoinedType(node *CattleJoinedType) cattlejoinedtypeOption {
	return func(m *CattleJoinedTypeMutation) {
		m.oldValue = func(context.Context) (*CattleJoinedType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleJoinedTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleJoinedTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleJoinedTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleJoinedTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleJoinedTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleJoinedType.
// If the CattleJoinedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleJoinedTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleJoinedTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleJoinedTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleJoinedType).
func (m *CattleJoinedTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleJoinedTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattlejoinedtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleJoinedTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlejoinedtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleJoinedTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlejoinedtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleJoinedType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleJoinedTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlejoinedtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleJoinedType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleJoinedTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleJoinedTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleJoinedTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleJoinedType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleJoinedTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleJoinedTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleJoinedTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleJoinedType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleJoinedTypeMutation) ResetField(name string) error {
	switch name {
	case cattlejoinedtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleJoinedType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleJoinedTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleJoinedTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleJoinedTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleJoinedTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleJoinedTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleJoinedTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleJoinedTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleJoinedType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleJoinedTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleJoinedType edge %s", name)
}

// CattleOwnerMutation represents an operation that mutate the CattleOwners
// nodes in the graph.
type CattleOwnerMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleOwner, error)
}

var _ ent.Mutation = (*CattleOwnerMutation)(nil)

// cattleownerOption allows to manage the mutation configuration using functional options.
type cattleownerOption func(*CattleOwnerMutation)

// newCattleOwnerMutation creates new mutation for $n.Name.
func newCattleOwnerMutation(c config, op Op, opts ...cattleownerOption) *CattleOwnerMutation {
	m := &CattleOwnerMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleOwner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleOwnerID sets the id field of the mutation.
func withCattleOwnerID(id int64) cattleownerOption {
	return func(m *CattleOwnerMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleOwner
		)
		m.oldValue = func(ctx context.Context) (*CattleOwner, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleOwner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleOwner sets the old CattleOwner of the mutation.
func withCattleOwner(node *CattleOwner) cattleownerOption {
	return func(m *CattleOwnerMutation) {
		m.oldValue = func(context.Context) (*CattleOwner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleOwnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleOwnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleOwnerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleOwnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleOwnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleOwner.
// If the CattleOwner object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOwnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleOwnerMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleOwnerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleOwner).
func (m *CattleOwnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleOwnerMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattleowner.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleOwnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattleowner.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleOwnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattleowner.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleOwner field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleOwnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattleowner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleOwner field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleOwnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleOwnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleOwnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleOwner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleOwnerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleOwnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleOwnerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleOwner nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleOwnerMutation) ResetField(name string) error {
	switch name {
	case cattleowner.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleOwner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleOwnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleOwnerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleOwnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleOwnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleOwnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleOwnerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleOwnerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleOwner unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleOwnerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleOwner edge %s", name)
}

// CattleTypeMutation represents an operation that mutate the CattleTypes
// nodes in the graph.
type CattleTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleType, error)
}

var _ ent.Mutation = (*CattleTypeMutation)(nil)

// cattletypeOption allows to manage the mutation configuration using functional options.
type cattletypeOption func(*CattleTypeMutation)

// newCattleTypeMutation creates new mutation for $n.Name.
func newCattleTypeMutation(c config, op Op, opts ...cattletypeOption) *CattleTypeMutation {
	m := &CattleTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleTypeID sets the id field of the mutation.
func withCattleTypeID(id int64) cattletypeOption {
	return func(m *CattleTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleType
		)
		m.oldValue = func(ctx context.Context) (*CattleType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleType sets the old CattleType of the mutation.
func withCattleType(node *CattleType) cattletypeOption {
	return func(m *CattleTypeMutation) {
		m.oldValue = func(context.Context) (*CattleType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleType.
// If the CattleType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleType).
func (m *CattleTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattletype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattletype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattletype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattletype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleTypeMutation) ResetField(name string) error {
	switch name {
	case cattletype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleType edge %s", name)
}

// ConfMutation represents an operation that mutate the Confs
// nodes in the graph.
type ConfMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	confs         **confs.Confs
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Conf, error)
}

var _ ent.Mutation = (*ConfMutation)(nil)

// confOption allows to manage the mutation configuration using functional options.
type confOption func(*ConfMutation)

// newConfMutation creates new mutation for $n.Name.
func newConfMutation(c config, op Op, opts ...confOption) *ConfMutation {
	m := &ConfMutation{
		config:        c,
		op:            op,
		typ:           TypeConf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfID sets the id field of the mutation.
func withConfID(id int64) confOption {
	return func(m *ConfMutation) {
		var (
			err   error
			once  sync.Once
			value *Conf
		)
		m.oldValue = func(ctx context.Context) (*Conf, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConf sets the old Conf of the mutation.
func withConf(node *Conf) confOption {
	return func(m *ConfMutation) {
		m.oldValue = func(context.Context) (*Conf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConfMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetConfs sets the confs field.
func (m *ConfMutation) SetConfs(c *confs.Confs) {
	m.confs = &c
}

// Confs returns the confs value in the mutation.
func (m *ConfMutation) Confs() (r *confs.Confs, exists bool) {
	v := m.confs
	if v == nil {
		return
	}
	return *v, true
}

// OldConfs returns the old confs value of the Conf.
// If the Conf object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfMutation) OldConfs(ctx context.Context) (v *confs.Confs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfs: %w", err)
	}
	return oldValue.Confs, nil
}

// ResetConfs reset all changes of the "confs" field.
func (m *ConfMutation) ResetConfs() {
	m.confs = nil
}

// Op returns the operation name.
func (m *ConfMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Conf).
func (m *ConfMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConfMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.confs != nil {
		fields = append(fields, conf.FieldConfs)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConfMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conf.FieldConfs:
		return m.Confs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ConfMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conf.FieldConfs:
		return m.OldConfs(ctx)
	}
	return nil, fmt.Errorf("unknown Conf field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conf.FieldConfs:
		v, ok := value.(*confs.Confs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfs(v)
		return nil
	}
	return fmt.Errorf("unknown Conf field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConfMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConfMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConfMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConfMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Conf nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConfMutation) ResetField(name string) error {
	switch name {
	case conf.FieldConfs:
		m.ResetConfs()
		return nil
	}
	return fmt.Errorf("unknown Conf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConfMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConfMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConfMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConfMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConfMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConfMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConfMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Conf unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConfMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Conf edge %s", name)
}

// DisinfectMutation represents an operation that mutate the Disinfects
// nodes in the graph.
type DisinfectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	date          *int64
	adddate       *int64
	typeId        *int
	addtypeId     *int
	typeName      *string
	methodId      *int
	addmethodId   *int
	methodName    *string
	wayId         *int
	addwayId      *int
	wayName       *string
	drug          *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Disinfect, error)
}

var _ ent.Mutation = (*DisinfectMutation)(nil)

// disinfectOption allows to manage the mutation configuration using functional options.
type disinfectOption func(*DisinfectMutation)

// newDisinfectMutation creates new mutation for $n.Name.
func newDisinfectMutation(c config, op Op, opts ...disinfectOption) *DisinfectMutation {
	m := &DisinfectMutation{
		config:        c,
		op:            op,
		typ:           TypeDisinfect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDisinfectID sets the id field of the mutation.
func withDisinfectID(id int64) disinfectOption {
	return func(m *DisinfectMutation) {
		var (
			err   error
			once  sync.Once
			value *Disinfect
		)
		m.oldValue = func(ctx context.Context) (*Disinfect, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disinfect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisinfect sets the old Disinfect of the mutation.
func withDisinfect(node *Disinfect) disinfectOption {
	return func(m *DisinfectMutation) {
		m.oldValue = func(context.Context) (*Disinfect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DisinfectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DisinfectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DisinfectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DisinfectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DisinfectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DisinfectMutation) ResetName() {
	m.name = nil
}

// SetDate sets the date field.
func (m *DisinfectMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *DisinfectMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *DisinfectMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *DisinfectMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *DisinfectMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetTypeId sets the typeId field.
func (m *DisinfectMutation) SetTypeId(i int) {
	m.typeId = &i
	m.addtypeId = nil
}

// TypeId returns the typeId value in the mutation.
func (m *DisinfectMutation) TypeId() (r int, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old typeId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds i to typeId.
func (m *DisinfectMutation) AddTypeId(i int) {
	if m.addtypeId != nil {
		*m.addtypeId += i
	} else {
		m.addtypeId = &i
	}
}

// AddedTypeId returns the value that was added to the typeId field in this mutation.
func (m *DisinfectMutation) AddedTypeId() (r int, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeId reset all changes of the "typeId" field.
func (m *DisinfectMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
}

// SetTypeName sets the typeName field.
func (m *DisinfectMutation) SetTypeName(s string) {
	m.typeName = &s
}

// TypeName returns the typeName value in the mutation.
func (m *DisinfectMutation) TypeName() (r string, exists bool) {
	v := m.typeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old typeName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName reset all changes of the "typeName" field.
func (m *DisinfectMutation) ResetTypeName() {
	m.typeName = nil
}

// SetMethodId sets the methodId field.
func (m *DisinfectMutation) SetMethodId(i int) {
	m.methodId = &i
	m.addmethodId = nil
}

// MethodId returns the methodId value in the mutation.
func (m *DisinfectMutation) MethodId() (r int, exists bool) {
	v := m.methodId
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodId returns the old methodId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldMethodId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodId: %w", err)
	}
	return oldValue.MethodId, nil
}

// AddMethodId adds i to methodId.
func (m *DisinfectMutation) AddMethodId(i int) {
	if m.addmethodId != nil {
		*m.addmethodId += i
	} else {
		m.addmethodId = &i
	}
}

// AddedMethodId returns the value that was added to the methodId field in this mutation.
func (m *DisinfectMutation) AddedMethodId() (r int, exists bool) {
	v := m.addmethodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetMethodId reset all changes of the "methodId" field.
func (m *DisinfectMutation) ResetMethodId() {
	m.methodId = nil
	m.addmethodId = nil
}

// SetMethodName sets the methodName field.
func (m *DisinfectMutation) SetMethodName(s string) {
	m.methodName = &s
}

// MethodName returns the methodName value in the mutation.
func (m *DisinfectMutation) MethodName() (r string, exists bool) {
	v := m.methodName
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodName returns the old methodName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodName: %w", err)
	}
	return oldValue.MethodName, nil
}

// ResetMethodName reset all changes of the "methodName" field.
func (m *DisinfectMutation) ResetMethodName() {
	m.methodName = nil
}

// SetWayId sets the wayId field.
func (m *DisinfectMutation) SetWayId(i int) {
	m.wayId = &i
	m.addwayId = nil
}

// WayId returns the wayId value in the mutation.
func (m *DisinfectMutation) WayId() (r int, exists bool) {
	v := m.wayId
	if v == nil {
		return
	}
	return *v, true
}

// OldWayId returns the old wayId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldWayId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWayId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWayId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWayId: %w", err)
	}
	return oldValue.WayId, nil
}

// AddWayId adds i to wayId.
func (m *DisinfectMutation) AddWayId(i int) {
	if m.addwayId != nil {
		*m.addwayId += i
	} else {
		m.addwayId = &i
	}
}

// AddedWayId returns the value that was added to the wayId field in this mutation.
func (m *DisinfectMutation) AddedWayId() (r int, exists bool) {
	v := m.addwayId
	if v == nil {
		return
	}
	return *v, true
}

// ResetWayId reset all changes of the "wayId" field.
func (m *DisinfectMutation) ResetWayId() {
	m.wayId = nil
	m.addwayId = nil
}

// SetWayName sets the wayName field.
func (m *DisinfectMutation) SetWayName(s string) {
	m.wayName = &s
}

// WayName returns the wayName value in the mutation.
func (m *DisinfectMutation) WayName() (r string, exists bool) {
	v := m.wayName
	if v == nil {
		return
	}
	return *v, true
}

// OldWayName returns the old wayName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldWayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWayName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWayName: %w", err)
	}
	return oldValue.WayName, nil
}

// ResetWayName reset all changes of the "wayName" field.
func (m *DisinfectMutation) ResetWayName() {
	m.wayName = nil
}

// SetDrug sets the drug field.
func (m *DisinfectMutation) SetDrug(s string) {
	m.drug = &s
}

// Drug returns the drug value in the mutation.
func (m *DisinfectMutation) Drug() (r string, exists bool) {
	v := m.drug
	if v == nil {
		return
	}
	return *v, true
}

// OldDrug returns the old drug value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldDrug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDrug is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDrug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrug: %w", err)
	}
	return oldValue.Drug, nil
}

// ResetDrug reset all changes of the "drug" field.
func (m *DisinfectMutation) ResetDrug() {
	m.drug = nil
}

// SetRemarks sets the remarks field.
func (m *DisinfectMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *DisinfectMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *DisinfectMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *DisinfectMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *DisinfectMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *DisinfectMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *DisinfectMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *DisinfectMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *DisinfectMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *DisinfectMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *DisinfectMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *DisinfectMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *DisinfectMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *DisinfectMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *DisinfectMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *DisinfectMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *DisinfectMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *DisinfectMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *DisinfectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disinfect).
func (m *DisinfectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DisinfectMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, disinfect.FieldName)
	}
	if m.date != nil {
		fields = append(fields, disinfect.FieldDate)
	}
	if m.typeId != nil {
		fields = append(fields, disinfect.FieldTypeId)
	}
	if m.typeName != nil {
		fields = append(fields, disinfect.FieldTypeName)
	}
	if m.methodId != nil {
		fields = append(fields, disinfect.FieldMethodId)
	}
	if m.methodName != nil {
		fields = append(fields, disinfect.FieldMethodName)
	}
	if m.wayId != nil {
		fields = append(fields, disinfect.FieldWayId)
	}
	if m.wayName != nil {
		fields = append(fields, disinfect.FieldWayName)
	}
	if m.drug != nil {
		fields = append(fields, disinfect.FieldDrug)
	}
	if m.remarks != nil {
		fields = append(fields, disinfect.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, disinfect.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, disinfect.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, disinfect.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DisinfectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disinfect.FieldName:
		return m.Name()
	case disinfect.FieldDate:
		return m.Date()
	case disinfect.FieldTypeId:
		return m.TypeId()
	case disinfect.FieldTypeName:
		return m.TypeName()
	case disinfect.FieldMethodId:
		return m.MethodId()
	case disinfect.FieldMethodName:
		return m.MethodName()
	case disinfect.FieldWayId:
		return m.WayId()
	case disinfect.FieldWayName:
		return m.WayName()
	case disinfect.FieldDrug:
		return m.Drug()
	case disinfect.FieldRemarks:
		return m.Remarks()
	case disinfect.FieldCreatedAt:
		return m.CreatedAt()
	case disinfect.FieldUpdatedAt:
		return m.UpdatedAt()
	case disinfect.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DisinfectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disinfect.FieldName:
		return m.OldName(ctx)
	case disinfect.FieldDate:
		return m.OldDate(ctx)
	case disinfect.FieldTypeId:
		return m.OldTypeId(ctx)
	case disinfect.FieldTypeName:
		return m.OldTypeName(ctx)
	case disinfect.FieldMethodId:
		return m.OldMethodId(ctx)
	case disinfect.FieldMethodName:
		return m.OldMethodName(ctx)
	case disinfect.FieldWayId:
		return m.OldWayId(ctx)
	case disinfect.FieldWayName:
		return m.OldWayName(ctx)
	case disinfect.FieldDrug:
		return m.OldDrug(ctx)
	case disinfect.FieldRemarks:
		return m.OldRemarks(ctx)
	case disinfect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case disinfect.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case disinfect.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Disinfect field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DisinfectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disinfect.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case disinfect.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case disinfect.FieldTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case disinfect.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case disinfect.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodId(v)
		return nil
	case disinfect.FieldMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodName(v)
		return nil
	case disinfect.FieldWayId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWayId(v)
		return nil
	case disinfect.FieldWayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWayName(v)
		return nil
	case disinfect.FieldDrug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrug(v)
		return nil
	case disinfect.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case disinfect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case disinfect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case disinfect.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Disinfect field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DisinfectMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, disinfect.FieldDate)
	}
	if m.addtypeId != nil {
		fields = append(fields, disinfect.FieldTypeId)
	}
	if m.addmethodId != nil {
		fields = append(fields, disinfect.FieldMethodId)
	}
	if m.addwayId != nil {
		fields = append(fields, disinfect.FieldWayId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, disinfect.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, disinfect.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, disinfect.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DisinfectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disinfect.FieldDate:
		return m.AddedDate()
	case disinfect.FieldTypeId:
		return m.AddedTypeId()
	case disinfect.FieldMethodId:
		return m.AddedMethodId()
	case disinfect.FieldWayId:
		return m.AddedWayId()
	case disinfect.FieldCreatedAt:
		return m.AddedCreatedAt()
	case disinfect.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case disinfect.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DisinfectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disinfect.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case disinfect.FieldTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case disinfect.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethodId(v)
		return nil
	case disinfect.FieldWayId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWayId(v)
		return nil
	case disinfect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case disinfect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case disinfect.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Disinfect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DisinfectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DisinfectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DisinfectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disinfect nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DisinfectMutation) ResetField(name string) error {
	switch name {
	case disinfect.FieldName:
		m.ResetName()
		return nil
	case disinfect.FieldDate:
		m.ResetDate()
		return nil
	case disinfect.FieldTypeId:
		m.ResetTypeId()
		return nil
	case disinfect.FieldTypeName:
		m.ResetTypeName()
		return nil
	case disinfect.FieldMethodId:
		m.ResetMethodId()
		return nil
	case disinfect.FieldMethodName:
		m.ResetMethodName()
		return nil
	case disinfect.FieldWayId:
		m.ResetWayId()
		return nil
	case disinfect.FieldWayName:
		m.ResetWayName()
		return nil
	case disinfect.FieldDrug:
		m.ResetDrug()
		return nil
	case disinfect.FieldRemarks:
		m.ResetRemarks()
		return nil
	case disinfect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case disinfect.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case disinfect.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Disinfect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DisinfectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DisinfectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DisinfectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DisinfectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DisinfectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DisinfectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DisinfectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Disinfect unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DisinfectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Disinfect edge %s", name)
}

// DispenceMutation represents an operation that mutate the Dispences
// nodes in the graph.
type DispenceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Dispence, error)
}

var _ ent.Mutation = (*DispenceMutation)(nil)

// dispenceOption allows to manage the mutation configuration using functional options.
type dispenceOption func(*DispenceMutation)

// newDispenceMutation creates new mutation for $n.Name.
func newDispenceMutation(c config, op Op, opts ...dispenceOption) *DispenceMutation {
	m := &DispenceMutation{
		config:        c,
		op:            op,
		typ:           TypeDispence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDispenceID sets the id field of the mutation.
func withDispenceID(id int64) dispenceOption {
	return func(m *DispenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Dispence
		)
		m.oldValue = func(ctx context.Context) (*Dispence, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dispence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDispence sets the old Dispence of the mutation.
func withDispence(node *Dispence) dispenceOption {
	return func(m *DispenceMutation) {
		m.oldValue = func(context.Context) (*Dispence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DispenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DispenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DispenceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *DispenceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dispence).
func (m *DispenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DispenceMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DispenceMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DispenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Dispence field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DispenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dispence field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DispenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DispenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DispenceMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Dispence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DispenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DispenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DispenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dispence nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DispenceMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Dispence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DispenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DispenceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DispenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DispenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DispenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DispenceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DispenceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Dispence unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DispenceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Dispence edge %s", name)
}

// DutyMutation represents an operation that mutate the Duties
// nodes in the graph.
type DutyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Duty, error)
}

var _ ent.Mutation = (*DutyMutation)(nil)

// dutyOption allows to manage the mutation configuration using functional options.
type dutyOption func(*DutyMutation)

// newDutyMutation creates new mutation for $n.Name.
func newDutyMutation(c config, op Op, opts ...dutyOption) *DutyMutation {
	m := &DutyMutation{
		config:        c,
		op:            op,
		typ:           TypeDuty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDutyID sets the id field of the mutation.
func withDutyID(id int64) dutyOption {
	return func(m *DutyMutation) {
		var (
			err   error
			once  sync.Once
			value *Duty
		)
		m.oldValue = func(ctx context.Context) (*Duty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Duty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDuty sets the old Duty of the mutation.
func withDuty(node *Duty) dutyOption {
	return func(m *DutyMutation) {
		m.oldValue = func(context.Context) (*Duty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DutyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DutyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DutyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DutyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DutyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Duty.
// If the Duty object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DutyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DutyMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *DutyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Duty).
func (m *DutyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DutyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, duty.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DutyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case duty.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DutyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case duty.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Duty field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DutyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case duty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Duty field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DutyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DutyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DutyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Duty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DutyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DutyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DutyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Duty nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DutyMutation) ResetField(name string) error {
	switch name {
	case duty.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Duty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DutyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DutyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DutyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DutyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DutyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DutyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DutyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Duty unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DutyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Duty edge %s", name)
}

// EpidemicMutation represents an operation that mutate the Epidemics
// nodes in the graph.
type EpidemicMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	name                 *string
	earNumber            *string
	shedName             *string
	onset                *int64
	addonset             *int64
	epidemicTypeId       *int
	addepidemicTypeId    *int
	epidemicTypeName     *string
	isolatedShedName     *string
	diagedBy             *string
	treatmentResultId    *int
	addtreatmentResultId *int
	treatmentResultName  *string
	treatmentAt          *int64
	addtreatmentAt       *int64
	whereabout           *string
	remarks              *string
	createdAt            *int64
	addcreatedAt         *int64
	updatedAt            *int64
	addupdatedAt         *int64
	deleted              *int
	adddeleted           *int
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Epidemic, error)
}

var _ ent.Mutation = (*EpidemicMutation)(nil)

// epidemicOption allows to manage the mutation configuration using functional options.
type epidemicOption func(*EpidemicMutation)

// newEpidemicMutation creates new mutation for $n.Name.
func newEpidemicMutation(c config, op Op, opts ...epidemicOption) *EpidemicMutation {
	m := &EpidemicMutation{
		config:        c,
		op:            op,
		typ:           TypeEpidemic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpidemicID sets the id field of the mutation.
func withEpidemicID(id int64) epidemicOption {
	return func(m *EpidemicMutation) {
		var (
			err   error
			once  sync.Once
			value *Epidemic
		)
		m.oldValue = func(ctx context.Context) (*Epidemic, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Epidemic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpidemic sets the old Epidemic of the mutation.
func withEpidemic(node *Epidemic) epidemicOption {
	return func(m *EpidemicMutation) {
		m.oldValue = func(context.Context) (*Epidemic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpidemicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpidemicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EpidemicMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EpidemicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EpidemicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EpidemicMutation) ResetName() {
	m.name = nil
}

// SetEarNumber sets the earNumber field.
func (m *EpidemicMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *EpidemicMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *EpidemicMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetShedName sets the shedName field.
func (m *EpidemicMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *EpidemicMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *EpidemicMutation) ResetShedName() {
	m.shedName = nil
}

// SetOnset sets the onset field.
func (m *EpidemicMutation) SetOnset(i int64) {
	m.onset = &i
	m.addonset = nil
}

// Onset returns the onset value in the mutation.
func (m *EpidemicMutation) Onset() (r int64, exists bool) {
	v := m.onset
	if v == nil {
		return
	}
	return *v, true
}

// OldOnset returns the old onset value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldOnset(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnset is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnset: %w", err)
	}
	return oldValue.Onset, nil
}

// AddOnset adds i to onset.
func (m *EpidemicMutation) AddOnset(i int64) {
	if m.addonset != nil {
		*m.addonset += i
	} else {
		m.addonset = &i
	}
}

// AddedOnset returns the value that was added to the onset field in this mutation.
func (m *EpidemicMutation) AddedOnset() (r int64, exists bool) {
	v := m.addonset
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnset reset all changes of the "onset" field.
func (m *EpidemicMutation) ResetOnset() {
	m.onset = nil
	m.addonset = nil
}

// SetEpidemicTypeId sets the epidemicTypeId field.
func (m *EpidemicMutation) SetEpidemicTypeId(i int) {
	m.epidemicTypeId = &i
	m.addepidemicTypeId = nil
}

// EpidemicTypeId returns the epidemicTypeId value in the mutation.
func (m *EpidemicMutation) EpidemicTypeId() (r int, exists bool) {
	v := m.epidemicTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldEpidemicTypeId returns the old epidemicTypeId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldEpidemicTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEpidemicTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEpidemicTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpidemicTypeId: %w", err)
	}
	return oldValue.EpidemicTypeId, nil
}

// AddEpidemicTypeId adds i to epidemicTypeId.
func (m *EpidemicMutation) AddEpidemicTypeId(i int) {
	if m.addepidemicTypeId != nil {
		*m.addepidemicTypeId += i
	} else {
		m.addepidemicTypeId = &i
	}
}

// AddedEpidemicTypeId returns the value that was added to the epidemicTypeId field in this mutation.
func (m *EpidemicMutation) AddedEpidemicTypeId() (r int, exists bool) {
	v := m.addepidemicTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpidemicTypeId reset all changes of the "epidemicTypeId" field.
func (m *EpidemicMutation) ResetEpidemicTypeId() {
	m.epidemicTypeId = nil
	m.addepidemicTypeId = nil
}

// SetEpidemicTypeName sets the epidemicTypeName field.
func (m *EpidemicMutation) SetEpidemicTypeName(s string) {
	m.epidemicTypeName = &s
}

// EpidemicTypeName returns the epidemicTypeName value in the mutation.
func (m *EpidemicMutation) EpidemicTypeName() (r string, exists bool) {
	v := m.epidemicTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEpidemicTypeName returns the old epidemicTypeName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldEpidemicTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEpidemicTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEpidemicTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpidemicTypeName: %w", err)
	}
	return oldValue.EpidemicTypeName, nil
}

// ResetEpidemicTypeName reset all changes of the "epidemicTypeName" field.
func (m *EpidemicMutation) ResetEpidemicTypeName() {
	m.epidemicTypeName = nil
}

// SetIsolatedShedName sets the isolatedShedName field.
func (m *EpidemicMutation) SetIsolatedShedName(s string) {
	m.isolatedShedName = &s
}

// IsolatedShedName returns the isolatedShedName value in the mutation.
func (m *EpidemicMutation) IsolatedShedName() (r string, exists bool) {
	v := m.isolatedShedName
	if v == nil {
		return
	}
	return *v, true
}

// OldIsolatedShedName returns the old isolatedShedName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldIsolatedShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsolatedShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsolatedShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsolatedShedName: %w", err)
	}
	return oldValue.IsolatedShedName, nil
}

// ResetIsolatedShedName reset all changes of the "isolatedShedName" field.
func (m *EpidemicMutation) ResetIsolatedShedName() {
	m.isolatedShedName = nil
}

// SetDiagedBy sets the diagedBy field.
func (m *EpidemicMutation) SetDiagedBy(s string) {
	m.diagedBy = &s
}

// DiagedBy returns the diagedBy value in the mutation.
func (m *EpidemicMutation) DiagedBy() (r string, exists bool) {
	v := m.diagedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagedBy returns the old diagedBy value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldDiagedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiagedBy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiagedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagedBy: %w", err)
	}
	return oldValue.DiagedBy, nil
}

// ResetDiagedBy reset all changes of the "diagedBy" field.
func (m *EpidemicMutation) ResetDiagedBy() {
	m.diagedBy = nil
}

// SetTreatmentResultId sets the treatmentResultId field.
func (m *EpidemicMutation) SetTreatmentResultId(i int) {
	m.treatmentResultId = &i
	m.addtreatmentResultId = nil
}

// TreatmentResultId returns the treatmentResultId value in the mutation.
func (m *EpidemicMutation) TreatmentResultId() (r int, exists bool) {
	v := m.treatmentResultId
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentResultId returns the old treatmentResultId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTreatmentResultId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatmentResultId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatmentResultId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentResultId: %w", err)
	}
	return oldValue.TreatmentResultId, nil
}

// AddTreatmentResultId adds i to treatmentResultId.
func (m *EpidemicMutation) AddTreatmentResultId(i int) {
	if m.addtreatmentResultId != nil {
		*m.addtreatmentResultId += i
	} else {
		m.addtreatmentResultId = &i
	}
}

// AddedTreatmentResultId returns the value that was added to the treatmentResultId field in this mutation.
func (m *EpidemicMutation) AddedTreatmentResultId() (r int, exists bool) {
	v := m.addtreatmentResultId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTreatmentResultId reset all changes of the "treatmentResultId" field.
func (m *EpidemicMutation) ResetTreatmentResultId() {
	m.treatmentResultId = nil
	m.addtreatmentResultId = nil
}

// SetTreatmentResultName sets the treatmentResultName field.
func (m *EpidemicMutation) SetTreatmentResultName(s string) {
	m.treatmentResultName = &s
}

// TreatmentResultName returns the treatmentResultName value in the mutation.
func (m *EpidemicMutation) TreatmentResultName() (r string, exists bool) {
	v := m.treatmentResultName
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentResultName returns the old treatmentResultName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTreatmentResultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatmentResultName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatmentResultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentResultName: %w", err)
	}
	return oldValue.TreatmentResultName, nil
}

// ResetTreatmentResultName reset all changes of the "treatmentResultName" field.
func (m *EpidemicMutation) ResetTreatmentResultName() {
	m.treatmentResultName = nil
}

// SetTreatmentAt sets the treatmentAt field.
func (m *EpidemicMutation) SetTreatmentAt(i int64) {
	m.treatmentAt = &i
	m.addtreatmentAt = nil
}

// TreatmentAt returns the treatmentAt value in the mutation.
func (m *EpidemicMutation) TreatmentAt() (r int64, exists bool) {
	v := m.treatmentAt
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentAt returns the old treatmentAt value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTreatmentAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatmentAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatmentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentAt: %w", err)
	}
	return oldValue.TreatmentAt, nil
}

// AddTreatmentAt adds i to treatmentAt.
func (m *EpidemicMutation) AddTreatmentAt(i int64) {
	if m.addtreatmentAt != nil {
		*m.addtreatmentAt += i
	} else {
		m.addtreatmentAt = &i
	}
}

// AddedTreatmentAt returns the value that was added to the treatmentAt field in this mutation.
func (m *EpidemicMutation) AddedTreatmentAt() (r int64, exists bool) {
	v := m.addtreatmentAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetTreatmentAt reset all changes of the "treatmentAt" field.
func (m *EpidemicMutation) ResetTreatmentAt() {
	m.treatmentAt = nil
	m.addtreatmentAt = nil
}

// SetWhereabout sets the whereabout field.
func (m *EpidemicMutation) SetWhereabout(s string) {
	m.whereabout = &s
}

// Whereabout returns the whereabout value in the mutation.
func (m *EpidemicMutation) Whereabout() (r string, exists bool) {
	v := m.whereabout
	if v == nil {
		return
	}
	return *v, true
}

// OldWhereabout returns the old whereabout value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldWhereabout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWhereabout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWhereabout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhereabout: %w", err)
	}
	return oldValue.Whereabout, nil
}

// ResetWhereabout reset all changes of the "whereabout" field.
func (m *EpidemicMutation) ResetWhereabout() {
	m.whereabout = nil
}

// SetRemarks sets the remarks field.
func (m *EpidemicMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *EpidemicMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *EpidemicMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *EpidemicMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *EpidemicMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *EpidemicMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *EpidemicMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *EpidemicMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *EpidemicMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *EpidemicMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *EpidemicMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *EpidemicMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *EpidemicMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *EpidemicMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *EpidemicMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *EpidemicMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *EpidemicMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *EpidemicMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *EpidemicMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Epidemic).
func (m *EpidemicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EpidemicMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.name != nil {
		fields = append(fields, epidemic.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, epidemic.FieldEarNumber)
	}
	if m.shedName != nil {
		fields = append(fields, epidemic.FieldShedName)
	}
	if m.onset != nil {
		fields = append(fields, epidemic.FieldOnset)
	}
	if m.epidemicTypeId != nil {
		fields = append(fields, epidemic.FieldEpidemicTypeId)
	}
	if m.epidemicTypeName != nil {
		fields = append(fields, epidemic.FieldEpidemicTypeName)
	}
	if m.isolatedShedName != nil {
		fields = append(fields, epidemic.FieldIsolatedShedName)
	}
	if m.diagedBy != nil {
		fields = append(fields, epidemic.FieldDiagedBy)
	}
	if m.treatmentResultId != nil {
		fields = append(fields, epidemic.FieldTreatmentResultId)
	}
	if m.treatmentResultName != nil {
		fields = append(fields, epidemic.FieldTreatmentResultName)
	}
	if m.treatmentAt != nil {
		fields = append(fields, epidemic.FieldTreatmentAt)
	}
	if m.whereabout != nil {
		fields = append(fields, epidemic.FieldWhereabout)
	}
	if m.remarks != nil {
		fields = append(fields, epidemic.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, epidemic.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, epidemic.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, epidemic.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EpidemicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case epidemic.FieldName:
		return m.Name()
	case epidemic.FieldEarNumber:
		return m.EarNumber()
	case epidemic.FieldShedName:
		return m.ShedName()
	case epidemic.FieldOnset:
		return m.Onset()
	case epidemic.FieldEpidemicTypeId:
		return m.EpidemicTypeId()
	case epidemic.FieldEpidemicTypeName:
		return m.EpidemicTypeName()
	case epidemic.FieldIsolatedShedName:
		return m.IsolatedShedName()
	case epidemic.FieldDiagedBy:
		return m.DiagedBy()
	case epidemic.FieldTreatmentResultId:
		return m.TreatmentResultId()
	case epidemic.FieldTreatmentResultName:
		return m.TreatmentResultName()
	case epidemic.FieldTreatmentAt:
		return m.TreatmentAt()
	case epidemic.FieldWhereabout:
		return m.Whereabout()
	case epidemic.FieldRemarks:
		return m.Remarks()
	case epidemic.FieldCreatedAt:
		return m.CreatedAt()
	case epidemic.FieldUpdatedAt:
		return m.UpdatedAt()
	case epidemic.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EpidemicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case epidemic.FieldName:
		return m.OldName(ctx)
	case epidemic.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case epidemic.FieldShedName:
		return m.OldShedName(ctx)
	case epidemic.FieldOnset:
		return m.OldOnset(ctx)
	case epidemic.FieldEpidemicTypeId:
		return m.OldEpidemicTypeId(ctx)
	case epidemic.FieldEpidemicTypeName:
		return m.OldEpidemicTypeName(ctx)
	case epidemic.FieldIsolatedShedName:
		return m.OldIsolatedShedName(ctx)
	case epidemic.FieldDiagedBy:
		return m.OldDiagedBy(ctx)
	case epidemic.FieldTreatmentResultId:
		return m.OldTreatmentResultId(ctx)
	case epidemic.FieldTreatmentResultName:
		return m.OldTreatmentResultName(ctx)
	case epidemic.FieldTreatmentAt:
		return m.OldTreatmentAt(ctx)
	case epidemic.FieldWhereabout:
		return m.OldWhereabout(ctx)
	case epidemic.FieldRemarks:
		return m.OldRemarks(ctx)
	case epidemic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case epidemic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case epidemic.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Epidemic field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case epidemic.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case epidemic.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case epidemic.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case epidemic.FieldOnset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnset(v)
		return nil
	case epidemic.FieldEpidemicTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpidemicTypeId(v)
		return nil
	case epidemic.FieldEpidemicTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpidemicTypeName(v)
		return nil
	case epidemic.FieldIsolatedShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsolatedShedName(v)
		return nil
	case epidemic.FieldDiagedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagedBy(v)
		return nil
	case epidemic.FieldTreatmentResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentResultId(v)
		return nil
	case epidemic.FieldTreatmentResultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentResultName(v)
		return nil
	case epidemic.FieldTreatmentAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentAt(v)
		return nil
	case epidemic.FieldWhereabout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhereabout(v)
		return nil
	case epidemic.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case epidemic.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case epidemic.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case epidemic.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Epidemic field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EpidemicMutation) AddedFields() []string {
	var fields []string
	if m.addonset != nil {
		fields = append(fields, epidemic.FieldOnset)
	}
	if m.addepidemicTypeId != nil {
		fields = append(fields, epidemic.FieldEpidemicTypeId)
	}
	if m.addtreatmentResultId != nil {
		fields = append(fields, epidemic.FieldTreatmentResultId)
	}
	if m.addtreatmentAt != nil {
		fields = append(fields, epidemic.FieldTreatmentAt)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, epidemic.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, epidemic.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, epidemic.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EpidemicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case epidemic.FieldOnset:
		return m.AddedOnset()
	case epidemic.FieldEpidemicTypeId:
		return m.AddedEpidemicTypeId()
	case epidemic.FieldTreatmentResultId:
		return m.AddedTreatmentResultId()
	case epidemic.FieldTreatmentAt:
		return m.AddedTreatmentAt()
	case epidemic.FieldCreatedAt:
		return m.AddedCreatedAt()
	case epidemic.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case epidemic.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicMutation) AddField(name string, value ent.Value) error {
	switch name {
	case epidemic.FieldOnset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnset(v)
		return nil
	case epidemic.FieldEpidemicTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpidemicTypeId(v)
		return nil
	case epidemic.FieldTreatmentResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTreatmentResultId(v)
		return nil
	case epidemic.FieldTreatmentAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTreatmentAt(v)
		return nil
	case epidemic.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case epidemic.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case epidemic.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Epidemic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EpidemicMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EpidemicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpidemicMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Epidemic nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EpidemicMutation) ResetField(name string) error {
	switch name {
	case epidemic.FieldName:
		m.ResetName()
		return nil
	case epidemic.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case epidemic.FieldShedName:
		m.ResetShedName()
		return nil
	case epidemic.FieldOnset:
		m.ResetOnset()
		return nil
	case epidemic.FieldEpidemicTypeId:
		m.ResetEpidemicTypeId()
		return nil
	case epidemic.FieldEpidemicTypeName:
		m.ResetEpidemicTypeName()
		return nil
	case epidemic.FieldIsolatedShedName:
		m.ResetIsolatedShedName()
		return nil
	case epidemic.FieldDiagedBy:
		m.ResetDiagedBy()
		return nil
	case epidemic.FieldTreatmentResultId:
		m.ResetTreatmentResultId()
		return nil
	case epidemic.FieldTreatmentResultName:
		m.ResetTreatmentResultName()
		return nil
	case epidemic.FieldTreatmentAt:
		m.ResetTreatmentAt()
		return nil
	case epidemic.FieldWhereabout:
		m.ResetWhereabout()
		return nil
	case epidemic.FieldRemarks:
		m.ResetRemarks()
		return nil
	case epidemic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case epidemic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case epidemic.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Epidemic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EpidemicMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EpidemicMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EpidemicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EpidemicMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EpidemicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EpidemicMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EpidemicMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Epidemic unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EpidemicMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Epidemic edge %s", name)
}

// EpidemicTypeMutation represents an operation that mutate the EpidemicTypes
// nodes in the graph.
type EpidemicTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EpidemicType, error)
}

var _ ent.Mutation = (*EpidemicTypeMutation)(nil)

// epidemictypeOption allows to manage the mutation configuration using functional options.
type epidemictypeOption func(*EpidemicTypeMutation)

// newEpidemicTypeMutation creates new mutation for $n.Name.
func newEpidemicTypeMutation(c config, op Op, opts ...epidemictypeOption) *EpidemicTypeMutation {
	m := &EpidemicTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEpidemicType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpidemicTypeID sets the id field of the mutation.
func withEpidemicTypeID(id int64) epidemictypeOption {
	return func(m *EpidemicTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EpidemicType
		)
		m.oldValue = func(ctx context.Context) (*EpidemicType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EpidemicType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpidemicType sets the old EpidemicType of the mutation.
func withEpidemicType(node *EpidemicType) epidemictypeOption {
	return func(m *EpidemicTypeMutation) {
		m.oldValue = func(context.Context) (*EpidemicType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpidemicTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpidemicTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EpidemicTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EpidemicTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EpidemicTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EpidemicType.
// If the EpidemicType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EpidemicTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *EpidemicTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EpidemicType).
func (m *EpidemicTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EpidemicTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, epidemictype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EpidemicTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case epidemictype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EpidemicTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case epidemictype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EpidemicType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case epidemictype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EpidemicType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EpidemicTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EpidemicTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EpidemicType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EpidemicTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EpidemicTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpidemicTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EpidemicType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EpidemicTypeMutation) ResetField(name string) error {
	switch name {
	case epidemictype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EpidemicType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EpidemicTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EpidemicTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EpidemicTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EpidemicTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EpidemicTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EpidemicTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EpidemicTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EpidemicType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EpidemicTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EpidemicType edge %s", name)
}

// EstrusMutation represents an operation that mutate the EstrusSlice
// nodes in the graph.
type EstrusMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name              *string
	earNumber         *string
	times             *int
	addtimes          *int
	reproductiveState *string
	shedName          *string
	estrusAt          *int64
	addestrusAt       *int64
	estrusTypeId      *int
	addestrusTypeId   *int
	estrusTypeName    *string
	userName          *string
	remarks           *string
	createdAt         *int64
	addcreatedAt      *int64
	updatedAt         *int64
	addupdatedAt      *int64
	deleted           *int
	adddeleted        *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Estrus, error)
}

var _ ent.Mutation = (*EstrusMutation)(nil)

// estrusOption allows to manage the mutation configuration using functional options.
type estrusOption func(*EstrusMutation)

// newEstrusMutation creates new mutation for $n.Name.
func newEstrusMutation(c config, op Op, opts ...estrusOption) *EstrusMutation {
	m := &EstrusMutation{
		config:        c,
		op:            op,
		typ:           TypeEstrus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstrusID sets the id field of the mutation.
func withEstrusID(id int64) estrusOption {
	return func(m *EstrusMutation) {
		var (
			err   error
			once  sync.Once
			value *Estrus
		)
		m.oldValue = func(ctx context.Context) (*Estrus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Estrus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstrus sets the old Estrus of the mutation.
func withEstrus(node *Estrus) estrusOption {
	return func(m *EstrusMutation) {
		m.oldValue = func(context.Context) (*Estrus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstrusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstrusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EstrusMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EstrusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EstrusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *EstrusMutation) ClearName() {
	m.name = nil
	m.clearedFields[estrus.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *EstrusMutation) NameCleared() bool {
	_, ok := m.clearedFields[estrus.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *EstrusMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, estrus.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *EstrusMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *EstrusMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *EstrusMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *EstrusMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *EstrusMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *EstrusMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *EstrusMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *EstrusMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetReproductiveState sets the reproductiveState field.
func (m *EstrusMutation) SetReproductiveState(s string) {
	m.reproductiveState = &s
}

// ReproductiveState returns the reproductiveState value in the mutation.
func (m *EstrusMutation) ReproductiveState() (r string, exists bool) {
	v := m.reproductiveState
	if v == nil {
		return
	}
	return *v, true
}

// OldReproductiveState returns the old reproductiveState value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldReproductiveState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReproductiveState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReproductiveState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReproductiveState: %w", err)
	}
	return oldValue.ReproductiveState, nil
}

// ResetReproductiveState reset all changes of the "reproductiveState" field.
func (m *EstrusMutation) ResetReproductiveState() {
	m.reproductiveState = nil
}

// SetShedName sets the shedName field.
func (m *EstrusMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *EstrusMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *EstrusMutation) ResetShedName() {
	m.shedName = nil
}

// SetEstrusAt sets the estrusAt field.
func (m *EstrusMutation) SetEstrusAt(i int64) {
	m.estrusAt = &i
	m.addestrusAt = nil
}

// EstrusAt returns the estrusAt value in the mutation.
func (m *EstrusMutation) EstrusAt() (r int64, exists bool) {
	v := m.estrusAt
	if v == nil {
		return
	}
	return *v, true
}

// OldEstrusAt returns the old estrusAt value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEstrusAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstrusAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstrusAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstrusAt: %w", err)
	}
	return oldValue.EstrusAt, nil
}

// AddEstrusAt adds i to estrusAt.
func (m *EstrusMutation) AddEstrusAt(i int64) {
	if m.addestrusAt != nil {
		*m.addestrusAt += i
	} else {
		m.addestrusAt = &i
	}
}

// AddedEstrusAt returns the value that was added to the estrusAt field in this mutation.
func (m *EstrusMutation) AddedEstrusAt() (r int64, exists bool) {
	v := m.addestrusAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstrusAt reset all changes of the "estrusAt" field.
func (m *EstrusMutation) ResetEstrusAt() {
	m.estrusAt = nil
	m.addestrusAt = nil
}

// SetEstrusTypeId sets the estrusTypeId field.
func (m *EstrusMutation) SetEstrusTypeId(i int) {
	m.estrusTypeId = &i
	m.addestrusTypeId = nil
}

// EstrusTypeId returns the estrusTypeId value in the mutation.
func (m *EstrusMutation) EstrusTypeId() (r int, exists bool) {
	v := m.estrusTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldEstrusTypeId returns the old estrusTypeId value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEstrusTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstrusTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstrusTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstrusTypeId: %w", err)
	}
	return oldValue.EstrusTypeId, nil
}

// AddEstrusTypeId adds i to estrusTypeId.
func (m *EstrusMutation) AddEstrusTypeId(i int) {
	if m.addestrusTypeId != nil {
		*m.addestrusTypeId += i
	} else {
		m.addestrusTypeId = &i
	}
}

// AddedEstrusTypeId returns the value that was added to the estrusTypeId field in this mutation.
func (m *EstrusMutation) AddedEstrusTypeId() (r int, exists bool) {
	v := m.addestrusTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstrusTypeId reset all changes of the "estrusTypeId" field.
func (m *EstrusMutation) ResetEstrusTypeId() {
	m.estrusTypeId = nil
	m.addestrusTypeId = nil
}

// SetEstrusTypeName sets the estrusTypeName field.
func (m *EstrusMutation) SetEstrusTypeName(s string) {
	m.estrusTypeName = &s
}

// EstrusTypeName returns the estrusTypeName value in the mutation.
func (m *EstrusMutation) EstrusTypeName() (r string, exists bool) {
	v := m.estrusTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEstrusTypeName returns the old estrusTypeName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEstrusTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstrusTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstrusTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstrusTypeName: %w", err)
	}
	return oldValue.EstrusTypeName, nil
}

// ResetEstrusTypeName reset all changes of the "estrusTypeName" field.
func (m *EstrusMutation) ResetEstrusTypeName() {
	m.estrusTypeName = nil
}

// SetUserName sets the userName field.
func (m *EstrusMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *EstrusMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *EstrusMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *EstrusMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *EstrusMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *EstrusMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *EstrusMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *EstrusMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *EstrusMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *EstrusMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *EstrusMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *EstrusMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *EstrusMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *EstrusMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *EstrusMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *EstrusMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *EstrusMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *EstrusMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *EstrusMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *EstrusMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *EstrusMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *EstrusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Estrus).
func (m *EstrusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EstrusMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, estrus.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, estrus.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, estrus.FieldTimes)
	}
	if m.reproductiveState != nil {
		fields = append(fields, estrus.FieldReproductiveState)
	}
	if m.shedName != nil {
		fields = append(fields, estrus.FieldShedName)
	}
	if m.estrusAt != nil {
		fields = append(fields, estrus.FieldEstrusAt)
	}
	if m.estrusTypeId != nil {
		fields = append(fields, estrus.FieldEstrusTypeId)
	}
	if m.estrusTypeName != nil {
		fields = append(fields, estrus.FieldEstrusTypeName)
	}
	if m.userName != nil {
		fields = append(fields, estrus.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, estrus.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, estrus.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, estrus.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, estrus.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EstrusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estrus.FieldName:
		return m.Name()
	case estrus.FieldEarNumber:
		return m.EarNumber()
	case estrus.FieldTimes:
		return m.Times()
	case estrus.FieldReproductiveState:
		return m.ReproductiveState()
	case estrus.FieldShedName:
		return m.ShedName()
	case estrus.FieldEstrusAt:
		return m.EstrusAt()
	case estrus.FieldEstrusTypeId:
		return m.EstrusTypeId()
	case estrus.FieldEstrusTypeName:
		return m.EstrusTypeName()
	case estrus.FieldUserName:
		return m.UserName()
	case estrus.FieldRemarks:
		return m.Remarks()
	case estrus.FieldCreatedAt:
		return m.CreatedAt()
	case estrus.FieldUpdatedAt:
		return m.UpdatedAt()
	case estrus.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EstrusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estrus.FieldName:
		return m.OldName(ctx)
	case estrus.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case estrus.FieldTimes:
		return m.OldTimes(ctx)
	case estrus.FieldReproductiveState:
		return m.OldReproductiveState(ctx)
	case estrus.FieldShedName:
		return m.OldShedName(ctx)
	case estrus.FieldEstrusAt:
		return m.OldEstrusAt(ctx)
	case estrus.FieldEstrusTypeId:
		return m.OldEstrusTypeId(ctx)
	case estrus.FieldEstrusTypeName:
		return m.OldEstrusTypeName(ctx)
	case estrus.FieldUserName:
		return m.OldUserName(ctx)
	case estrus.FieldRemarks:
		return m.OldRemarks(ctx)
	case estrus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case estrus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case estrus.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Estrus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estrus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case estrus.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case estrus.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case estrus.FieldReproductiveState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReproductiveState(v)
		return nil
	case estrus.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case estrus.FieldEstrusAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstrusAt(v)
		return nil
	case estrus.FieldEstrusTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstrusTypeId(v)
		return nil
	case estrus.FieldEstrusTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstrusTypeName(v)
		return nil
	case estrus.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case estrus.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case estrus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case estrus.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case estrus.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Estrus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EstrusMutation) AddedFields() []string {
	var fields []string
	if m.addtimes != nil {
		fields = append(fields, estrus.FieldTimes)
	}
	if m.addestrusAt != nil {
		fields = append(fields, estrus.FieldEstrusAt)
	}
	if m.addestrusTypeId != nil {
		fields = append(fields, estrus.FieldEstrusTypeId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, estrus.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, estrus.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, estrus.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EstrusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case estrus.FieldTimes:
		return m.AddedTimes()
	case estrus.FieldEstrusAt:
		return m.AddedEstrusAt()
	case estrus.FieldEstrusTypeId:
		return m.AddedEstrusTypeId()
	case estrus.FieldCreatedAt:
		return m.AddedCreatedAt()
	case estrus.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case estrus.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case estrus.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case estrus.FieldEstrusAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstrusAt(v)
		return nil
	case estrus.FieldEstrusTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstrusTypeId(v)
		return nil
	case estrus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case estrus.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case estrus.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Estrus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EstrusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(estrus.FieldName) {
		fields = append(fields, estrus.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EstrusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstrusMutation) ClearField(name string) error {
	switch name {
	case estrus.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Estrus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EstrusMutation) ResetField(name string) error {
	switch name {
	case estrus.FieldName:
		m.ResetName()
		return nil
	case estrus.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case estrus.FieldTimes:
		m.ResetTimes()
		return nil
	case estrus.FieldReproductiveState:
		m.ResetReproductiveState()
		return nil
	case estrus.FieldShedName:
		m.ResetShedName()
		return nil
	case estrus.FieldEstrusAt:
		m.ResetEstrusAt()
		return nil
	case estrus.FieldEstrusTypeId:
		m.ResetEstrusTypeId()
		return nil
	case estrus.FieldEstrusTypeName:
		m.ResetEstrusTypeName()
		return nil
	case estrus.FieldUserName:
		m.ResetUserName()
		return nil
	case estrus.FieldRemarks:
		m.ResetRemarks()
		return nil
	case estrus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case estrus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case estrus.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Estrus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EstrusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EstrusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EstrusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EstrusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EstrusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EstrusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EstrusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Estrus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EstrusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Estrus edge %s", name)
}

// EstrusTypeMutation represents an operation that mutate the EstrusTypes
// nodes in the graph.
type EstrusTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EstrusType, error)
}

var _ ent.Mutation = (*EstrusTypeMutation)(nil)

// estrustypeOption allows to manage the mutation configuration using functional options.
type estrustypeOption func(*EstrusTypeMutation)

// newEstrusTypeMutation creates new mutation for $n.Name.
func newEstrusTypeMutation(c config, op Op, opts ...estrustypeOption) *EstrusTypeMutation {
	m := &EstrusTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEstrusType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstrusTypeID sets the id field of the mutation.
func withEstrusTypeID(id int64) estrustypeOption {
	return func(m *EstrusTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EstrusType
		)
		m.oldValue = func(ctx context.Context) (*EstrusType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EstrusType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstrusType sets the old EstrusType of the mutation.
func withEstrusType(node *EstrusType) estrustypeOption {
	return func(m *EstrusTypeMutation) {
		m.oldValue = func(context.Context) (*EstrusType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstrusTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstrusTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EstrusTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EstrusTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EstrusTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EstrusType.
// If the EstrusType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EstrusTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *EstrusTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EstrusType).
func (m *EstrusTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EstrusTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, estrustype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EstrusTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estrustype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EstrusTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estrustype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EstrusType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estrustype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EstrusType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EstrusTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EstrusTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EstrusType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EstrusTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EstrusTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstrusTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EstrusType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EstrusTypeMutation) ResetField(name string) error {
	switch name {
	case estrustype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EstrusType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EstrusTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EstrusTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EstrusTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EstrusTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EstrusTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EstrusTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EstrusTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EstrusType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EstrusTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EstrusType edge %s", name)
}

// FarmMutation represents an operation that mutate the Farms
// nodes in the graph.
type FarmMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	name             *string
	code             *string
	constructionDate *string
	feedingScale     *int64
	addfeedingScale  *int64
	contactUser      *string
	contactPhone     *string
	contactAddress   *string
	square           *int64
	addsquare        *int64
	shedCount        *int64
	addshedCount     *int64
	categoryId       *int64
	addcategoryId    *int64
	categoryName     *string
	varietyId        *int64
	addvarietyId     *int64
	varietyName      *string
	districtCode     *string
	districtName     *string
	remarks          *string
	createdAt        *int64
	addcreatedAt     *int64
	updatedAt        *int64
	addupdatedAt     *int64
	deleted          *int
	adddeleted       *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Farm, error)
}

var _ ent.Mutation = (*FarmMutation)(nil)

// farmOption allows to manage the mutation configuration using functional options.
type farmOption func(*FarmMutation)

// newFarmMutation creates new mutation for $n.Name.
func newFarmMutation(c config, op Op, opts ...farmOption) *FarmMutation {
	m := &FarmMutation{
		config:        c,
		op:            op,
		typ:           TypeFarm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFarmID sets the id field of the mutation.
func withFarmID(id int64) farmOption {
	return func(m *FarmMutation) {
		var (
			err   error
			once  sync.Once
			value *Farm
		)
		m.oldValue = func(ctx context.Context) (*Farm, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Farm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFarm sets the old Farm of the mutation.
func withFarm(node *Farm) farmOption {
	return func(m *FarmMutation) {
		m.oldValue = func(context.Context) (*Farm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FarmMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FarmMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FarmMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FarmMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FarmMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FarmMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *FarmMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *FarmMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *FarmMutation) ResetCode() {
	m.code = nil
}

// SetConstructionDate sets the constructionDate field.
func (m *FarmMutation) SetConstructionDate(s string) {
	m.constructionDate = &s
}

// ConstructionDate returns the constructionDate value in the mutation.
func (m *FarmMutation) ConstructionDate() (r string, exists bool) {
	v := m.constructionDate
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionDate returns the old constructionDate value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldConstructionDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConstructionDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConstructionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionDate: %w", err)
	}
	return oldValue.ConstructionDate, nil
}

// ResetConstructionDate reset all changes of the "constructionDate" field.
func (m *FarmMutation) ResetConstructionDate() {
	m.constructionDate = nil
}

// SetFeedingScale sets the feedingScale field.
func (m *FarmMutation) SetFeedingScale(i int64) {
	m.feedingScale = &i
	m.addfeedingScale = nil
}

// FeedingScale returns the feedingScale value in the mutation.
func (m *FarmMutation) FeedingScale() (r int64, exists bool) {
	v := m.feedingScale
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedingScale returns the old feedingScale value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldFeedingScale(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFeedingScale is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFeedingScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedingScale: %w", err)
	}
	return oldValue.FeedingScale, nil
}

// AddFeedingScale adds i to feedingScale.
func (m *FarmMutation) AddFeedingScale(i int64) {
	if m.addfeedingScale != nil {
		*m.addfeedingScale += i
	} else {
		m.addfeedingScale = &i
	}
}

// AddedFeedingScale returns the value that was added to the feedingScale field in this mutation.
func (m *FarmMutation) AddedFeedingScale() (r int64, exists bool) {
	v := m.addfeedingScale
	if v == nil {
		return
	}
	return *v, true
}

// ResetFeedingScale reset all changes of the "feedingScale" field.
func (m *FarmMutation) ResetFeedingScale() {
	m.feedingScale = nil
	m.addfeedingScale = nil
}

// SetContactUser sets the contactUser field.
func (m *FarmMutation) SetContactUser(s string) {
	m.contactUser = &s
}

// ContactUser returns the contactUser value in the mutation.
func (m *FarmMutation) ContactUser() (r string, exists bool) {
	v := m.contactUser
	if v == nil {
		return
	}
	return *v, true
}

// OldContactUser returns the old contactUser value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldContactUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactUser is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactUser: %w", err)
	}
	return oldValue.ContactUser, nil
}

// ResetContactUser reset all changes of the "contactUser" field.
func (m *FarmMutation) ResetContactUser() {
	m.contactUser = nil
}

// SetContactPhone sets the contactPhone field.
func (m *FarmMutation) SetContactPhone(s string) {
	m.contactPhone = &s
}

// ContactPhone returns the contactPhone value in the mutation.
func (m *FarmMutation) ContactPhone() (r string, exists bool) {
	v := m.contactPhone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old contactPhone value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ResetContactPhone reset all changes of the "contactPhone" field.
func (m *FarmMutation) ResetContactPhone() {
	m.contactPhone = nil
}

// SetContactAddress sets the contactAddress field.
func (m *FarmMutation) SetContactAddress(s string) {
	m.contactAddress = &s
}

// ContactAddress returns the contactAddress value in the mutation.
func (m *FarmMutation) ContactAddress() (r string, exists bool) {
	v := m.contactAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldContactAddress returns the old contactAddress value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldContactAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactAddress: %w", err)
	}
	return oldValue.ContactAddress, nil
}

// ResetContactAddress reset all changes of the "contactAddress" field.
func (m *FarmMutation) ResetContactAddress() {
	m.contactAddress = nil
}

// SetSquare sets the square field.
func (m *FarmMutation) SetSquare(i int64) {
	m.square = &i
	m.addsquare = nil
}

// Square returns the square value in the mutation.
func (m *FarmMutation) Square() (r int64, exists bool) {
	v := m.square
	if v == nil {
		return
	}
	return *v, true
}

// OldSquare returns the old square value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldSquare(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSquare is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSquare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSquare: %w", err)
	}
	return oldValue.Square, nil
}

// AddSquare adds i to square.
func (m *FarmMutation) AddSquare(i int64) {
	if m.addsquare != nil {
		*m.addsquare += i
	} else {
		m.addsquare = &i
	}
}

// AddedSquare returns the value that was added to the square field in this mutation.
func (m *FarmMutation) AddedSquare() (r int64, exists bool) {
	v := m.addsquare
	if v == nil {
		return
	}
	return *v, true
}

// ResetSquare reset all changes of the "square" field.
func (m *FarmMutation) ResetSquare() {
	m.square = nil
	m.addsquare = nil
}

// SetShedCount sets the shedCount field.
func (m *FarmMutation) SetShedCount(i int64) {
	m.shedCount = &i
	m.addshedCount = nil
}

// ShedCount returns the shedCount value in the mutation.
func (m *FarmMutation) ShedCount() (r int64, exists bool) {
	v := m.shedCount
	if v == nil {
		return
	}
	return *v, true
}

// OldShedCount returns the old shedCount value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldShedCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedCount: %w", err)
	}
	return oldValue.ShedCount, nil
}

// AddShedCount adds i to shedCount.
func (m *FarmMutation) AddShedCount(i int64) {
	if m.addshedCount != nil {
		*m.addshedCount += i
	} else {
		m.addshedCount = &i
	}
}

// AddedShedCount returns the value that was added to the shedCount field in this mutation.
func (m *FarmMutation) AddedShedCount() (r int64, exists bool) {
	v := m.addshedCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedCount reset all changes of the "shedCount" field.
func (m *FarmMutation) ResetShedCount() {
	m.shedCount = nil
	m.addshedCount = nil
}

// SetCategoryId sets the categoryId field.
func (m *FarmMutation) SetCategoryId(i int64) {
	m.categoryId = &i
	m.addcategoryId = nil
}

// CategoryId returns the categoryId value in the mutation.
func (m *FarmMutation) CategoryId() (r int64, exists bool) {
	v := m.categoryId
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryId returns the old categoryId value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCategoryId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryId: %w", err)
	}
	return oldValue.CategoryId, nil
}

// AddCategoryId adds i to categoryId.
func (m *FarmMutation) AddCategoryId(i int64) {
	if m.addcategoryId != nil {
		*m.addcategoryId += i
	} else {
		m.addcategoryId = &i
	}
}

// AddedCategoryId returns the value that was added to the categoryId field in this mutation.
func (m *FarmMutation) AddedCategoryId() (r int64, exists bool) {
	v := m.addcategoryId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryId reset all changes of the "categoryId" field.
func (m *FarmMutation) ResetCategoryId() {
	m.categoryId = nil
	m.addcategoryId = nil
}

// SetCategoryName sets the categoryName field.
func (m *FarmMutation) SetCategoryName(s string) {
	m.categoryName = &s
}

// CategoryName returns the categoryName value in the mutation.
func (m *FarmMutation) CategoryName() (r string, exists bool) {
	v := m.categoryName
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryName returns the old categoryName value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCategoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryName: %w", err)
	}
	return oldValue.CategoryName, nil
}

// ResetCategoryName reset all changes of the "categoryName" field.
func (m *FarmMutation) ResetCategoryName() {
	m.categoryName = nil
}

// SetVarietyId sets the varietyId field.
func (m *FarmMutation) SetVarietyId(i int64) {
	m.varietyId = &i
	m.addvarietyId = nil
}

// VarietyId returns the varietyId value in the mutation.
func (m *FarmMutation) VarietyId() (r int64, exists bool) {
	v := m.varietyId
	if v == nil {
		return
	}
	return *v, true
}

// OldVarietyId returns the old varietyId value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldVarietyId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVarietyId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVarietyId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVarietyId: %w", err)
	}
	return oldValue.VarietyId, nil
}

// AddVarietyId adds i to varietyId.
func (m *FarmMutation) AddVarietyId(i int64) {
	if m.addvarietyId != nil {
		*m.addvarietyId += i
	} else {
		m.addvarietyId = &i
	}
}

// AddedVarietyId returns the value that was added to the varietyId field in this mutation.
func (m *FarmMutation) AddedVarietyId() (r int64, exists bool) {
	v := m.addvarietyId
	if v == nil {
		return
	}
	return *v, true
}

// ResetVarietyId reset all changes of the "varietyId" field.
func (m *FarmMutation) ResetVarietyId() {
	m.varietyId = nil
	m.addvarietyId = nil
}

// SetVarietyName sets the varietyName field.
func (m *FarmMutation) SetVarietyName(s string) {
	m.varietyName = &s
}

// VarietyName returns the varietyName value in the mutation.
func (m *FarmMutation) VarietyName() (r string, exists bool) {
	v := m.varietyName
	if v == nil {
		return
	}
	return *v, true
}

// OldVarietyName returns the old varietyName value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldVarietyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVarietyName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVarietyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVarietyName: %w", err)
	}
	return oldValue.VarietyName, nil
}

// ResetVarietyName reset all changes of the "varietyName" field.
func (m *FarmMutation) ResetVarietyName() {
	m.varietyName = nil
}

// SetDistrictCode sets the districtCode field.
func (m *FarmMutation) SetDistrictCode(s string) {
	m.districtCode = &s
}

// DistrictCode returns the districtCode value in the mutation.
func (m *FarmMutation) DistrictCode() (r string, exists bool) {
	v := m.districtCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictCode returns the old districtCode value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldDistrictCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictCode: %w", err)
	}
	return oldValue.DistrictCode, nil
}

// ResetDistrictCode reset all changes of the "districtCode" field.
func (m *FarmMutation) ResetDistrictCode() {
	m.districtCode = nil
}

// SetDistrictName sets the districtName field.
func (m *FarmMutation) SetDistrictName(s string) {
	m.districtName = &s
}

// DistrictName returns the districtName value in the mutation.
func (m *FarmMutation) DistrictName() (r string, exists bool) {
	v := m.districtName
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictName returns the old districtName value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldDistrictName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictName: %w", err)
	}
	return oldValue.DistrictName, nil
}

// ResetDistrictName reset all changes of the "districtName" field.
func (m *FarmMutation) ResetDistrictName() {
	m.districtName = nil
}

// SetRemarks sets the remarks field.
func (m *FarmMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *FarmMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *FarmMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *FarmMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *FarmMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *FarmMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *FarmMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *FarmMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *FarmMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *FarmMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *FarmMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *FarmMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *FarmMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *FarmMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *FarmMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *FarmMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *FarmMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *FarmMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *FarmMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Farm).
func (m *FarmMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FarmMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.name != nil {
		fields = append(fields, farm.FieldName)
	}
	if m.code != nil {
		fields = append(fields, farm.FieldCode)
	}
	if m.constructionDate != nil {
		fields = append(fields, farm.FieldConstructionDate)
	}
	if m.feedingScale != nil {
		fields = append(fields, farm.FieldFeedingScale)
	}
	if m.contactUser != nil {
		fields = append(fields, farm.FieldContactUser)
	}
	if m.contactPhone != nil {
		fields = append(fields, farm.FieldContactPhone)
	}
	if m.contactAddress != nil {
		fields = append(fields, farm.FieldContactAddress)
	}
	if m.square != nil {
		fields = append(fields, farm.FieldSquare)
	}
	if m.shedCount != nil {
		fields = append(fields, farm.FieldShedCount)
	}
	if m.categoryId != nil {
		fields = append(fields, farm.FieldCategoryId)
	}
	if m.categoryName != nil {
		fields = append(fields, farm.FieldCategoryName)
	}
	if m.varietyId != nil {
		fields = append(fields, farm.FieldVarietyId)
	}
	if m.varietyName != nil {
		fields = append(fields, farm.FieldVarietyName)
	}
	if m.districtCode != nil {
		fields = append(fields, farm.FieldDistrictCode)
	}
	if m.districtName != nil {
		fields = append(fields, farm.FieldDistrictName)
	}
	if m.remarks != nil {
		fields = append(fields, farm.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, farm.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, farm.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, farm.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FarmMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case farm.FieldName:
		return m.Name()
	case farm.FieldCode:
		return m.Code()
	case farm.FieldConstructionDate:
		return m.ConstructionDate()
	case farm.FieldFeedingScale:
		return m.FeedingScale()
	case farm.FieldContactUser:
		return m.ContactUser()
	case farm.FieldContactPhone:
		return m.ContactPhone()
	case farm.FieldContactAddress:
		return m.ContactAddress()
	case farm.FieldSquare:
		return m.Square()
	case farm.FieldShedCount:
		return m.ShedCount()
	case farm.FieldCategoryId:
		return m.CategoryId()
	case farm.FieldCategoryName:
		return m.CategoryName()
	case farm.FieldVarietyId:
		return m.VarietyId()
	case farm.FieldVarietyName:
		return m.VarietyName()
	case farm.FieldDistrictCode:
		return m.DistrictCode()
	case farm.FieldDistrictName:
		return m.DistrictName()
	case farm.FieldRemarks:
		return m.Remarks()
	case farm.FieldCreatedAt:
		return m.CreatedAt()
	case farm.FieldUpdatedAt:
		return m.UpdatedAt()
	case farm.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FarmMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case farm.FieldName:
		return m.OldName(ctx)
	case farm.FieldCode:
		return m.OldCode(ctx)
	case farm.FieldConstructionDate:
		return m.OldConstructionDate(ctx)
	case farm.FieldFeedingScale:
		return m.OldFeedingScale(ctx)
	case farm.FieldContactUser:
		return m.OldContactUser(ctx)
	case farm.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case farm.FieldContactAddress:
		return m.OldContactAddress(ctx)
	case farm.FieldSquare:
		return m.OldSquare(ctx)
	case farm.FieldShedCount:
		return m.OldShedCount(ctx)
	case farm.FieldCategoryId:
		return m.OldCategoryId(ctx)
	case farm.FieldCategoryName:
		return m.OldCategoryName(ctx)
	case farm.FieldVarietyId:
		return m.OldVarietyId(ctx)
	case farm.FieldVarietyName:
		return m.OldVarietyName(ctx)
	case farm.FieldDistrictCode:
		return m.OldDistrictCode(ctx)
	case farm.FieldDistrictName:
		return m.OldDistrictName(ctx)
	case farm.FieldRemarks:
		return m.OldRemarks(ctx)
	case farm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case farm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case farm.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Farm field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FarmMutation) SetField(name string, value ent.Value) error {
	switch name {
	case farm.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case farm.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case farm.FieldConstructionDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionDate(v)
		return nil
	case farm.FieldFeedingScale:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedingScale(v)
		return nil
	case farm.FieldContactUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactUser(v)
		return nil
	case farm.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case farm.FieldContactAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactAddress(v)
		return nil
	case farm.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSquare(v)
		return nil
	case farm.FieldShedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedCount(v)
		return nil
	case farm.FieldCategoryId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryId(v)
		return nil
	case farm.FieldCategoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryName(v)
		return nil
	case farm.FieldVarietyId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVarietyId(v)
		return nil
	case farm.FieldVarietyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVarietyName(v)
		return nil
	case farm.FieldDistrictCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictCode(v)
		return nil
	case farm.FieldDistrictName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictName(v)
		return nil
	case farm.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case farm.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case farm.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case farm.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Farm field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FarmMutation) AddedFields() []string {
	var fields []string
	if m.addfeedingScale != nil {
		fields = append(fields, farm.FieldFeedingScale)
	}
	if m.addsquare != nil {
		fields = append(fields, farm.FieldSquare)
	}
	if m.addshedCount != nil {
		fields = append(fields, farm.FieldShedCount)
	}
	if m.addcategoryId != nil {
		fields = append(fields, farm.FieldCategoryId)
	}
	if m.addvarietyId != nil {
		fields = append(fields, farm.FieldVarietyId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, farm.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, farm.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, farm.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FarmMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case farm.FieldFeedingScale:
		return m.AddedFeedingScale()
	case farm.FieldSquare:
		return m.AddedSquare()
	case farm.FieldShedCount:
		return m.AddedShedCount()
	case farm.FieldCategoryId:
		return m.AddedCategoryId()
	case farm.FieldVarietyId:
		return m.AddedVarietyId()
	case farm.FieldCreatedAt:
		return m.AddedCreatedAt()
	case farm.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case farm.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FarmMutation) AddField(name string, value ent.Value) error {
	switch name {
	case farm.FieldFeedingScale:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeedingScale(v)
		return nil
	case farm.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSquare(v)
		return nil
	case farm.FieldShedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedCount(v)
		return nil
	case farm.FieldCategoryId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryId(v)
		return nil
	case farm.FieldVarietyId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVarietyId(v)
		return nil
	case farm.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case farm.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case farm.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Farm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FarmMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FarmMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FarmMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Farm nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FarmMutation) ResetField(name string) error {
	switch name {
	case farm.FieldName:
		m.ResetName()
		return nil
	case farm.FieldCode:
		m.ResetCode()
		return nil
	case farm.FieldConstructionDate:
		m.ResetConstructionDate()
		return nil
	case farm.FieldFeedingScale:
		m.ResetFeedingScale()
		return nil
	case farm.FieldContactUser:
		m.ResetContactUser()
		return nil
	case farm.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case farm.FieldContactAddress:
		m.ResetContactAddress()
		return nil
	case farm.FieldSquare:
		m.ResetSquare()
		return nil
	case farm.FieldShedCount:
		m.ResetShedCount()
		return nil
	case farm.FieldCategoryId:
		m.ResetCategoryId()
		return nil
	case farm.FieldCategoryName:
		m.ResetCategoryName()
		return nil
	case farm.FieldVarietyId:
		m.ResetVarietyId()
		return nil
	case farm.FieldVarietyName:
		m.ResetVarietyName()
		return nil
	case farm.FieldDistrictCode:
		m.ResetDistrictCode()
		return nil
	case farm.FieldDistrictName:
		m.ResetDistrictName()
		return nil
	case farm.FieldRemarks:
		m.ResetRemarks()
		return nil
	case farm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case farm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case farm.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Farm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FarmMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FarmMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FarmMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FarmMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FarmMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FarmMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FarmMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Farm unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FarmMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Farm edge %s", name)
}

// HairStateMutation represents an operation that mutate the HairStates
// nodes in the graph.
type HairStateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*HairState, error)
}

var _ ent.Mutation = (*HairStateMutation)(nil)

// hairstateOption allows to manage the mutation configuration using functional options.
type hairstateOption func(*HairStateMutation)

// newHairStateMutation creates new mutation for $n.Name.
func newHairStateMutation(c config, op Op, opts ...hairstateOption) *HairStateMutation {
	m := &HairStateMutation{
		config:        c,
		op:            op,
		typ:           TypeHairState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHairStateID sets the id field of the mutation.
func withHairStateID(id int64) hairstateOption {
	return func(m *HairStateMutation) {
		var (
			err   error
			once  sync.Once
			value *HairState
		)
		m.oldValue = func(ctx context.Context) (*HairState, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HairState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHairState sets the old HairState of the mutation.
func withHairState(node *HairState) hairstateOption {
	return func(m *HairStateMutation) {
		m.oldValue = func(context.Context) (*HairState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HairStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HairStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HairStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *HairStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *HairStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the HairState.
// If the HairState object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HairStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *HairStateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *HairStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HairState).
func (m *HairStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HairStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, hairstate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HairStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hairstate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HairStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hairstate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown HairState field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HairStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hairstate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown HairState field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HairStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HairStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HairStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HairState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HairStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HairStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HairStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HairState nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HairStateMutation) ResetField(name string) error {
	switch name {
	case hairstate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown HairState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HairStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HairStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HairStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HairStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HairStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HairStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HairStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HairState unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HairStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HairState edge %s", name)
}

// ImmunityMutation represents an operation that mutate the Immunities
// nodes in the graph.
type ImmunityMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	earNumber     *string
	shedName      *string
	date          *int64
	adddate       *int64
	itemId        *int
	additemId     *int
	itemName      *string
	userName      *string
	drug          *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Immunity, error)
}

var _ ent.Mutation = (*ImmunityMutation)(nil)

// immunityOption allows to manage the mutation configuration using functional options.
type immunityOption func(*ImmunityMutation)

// newImmunityMutation creates new mutation for $n.Name.
func newImmunityMutation(c config, op Op, opts ...immunityOption) *ImmunityMutation {
	m := &ImmunityMutation{
		config:        c,
		op:            op,
		typ:           TypeImmunity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImmunityID sets the id field of the mutation.
func withImmunityID(id int64) immunityOption {
	return func(m *ImmunityMutation) {
		var (
			err   error
			once  sync.Once
			value *Immunity
		)
		m.oldValue = func(ctx context.Context) (*Immunity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Immunity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImmunity sets the old Immunity of the mutation.
func withImmunity(node *Immunity) immunityOption {
	return func(m *ImmunityMutation) {
		m.oldValue = func(context.Context) (*Immunity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImmunityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImmunityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ImmunityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ImmunityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ImmunityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ImmunityMutation) ResetName() {
	m.name = nil
}

// SetEarNumber sets the earNumber field.
func (m *ImmunityMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *ImmunityMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *ImmunityMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetShedName sets the shedName field.
func (m *ImmunityMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *ImmunityMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *ImmunityMutation) ResetShedName() {
	m.shedName = nil
}

// SetDate sets the date field.
func (m *ImmunityMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *ImmunityMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *ImmunityMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *ImmunityMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *ImmunityMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetItemId sets the itemId field.
func (m *ImmunityMutation) SetItemId(i int) {
	m.itemId = &i
	m.additemId = nil
}

// ItemId returns the itemId value in the mutation.
func (m *ImmunityMutation) ItemId() (r int, exists bool) {
	v := m.itemId
	if v == nil {
		return
	}
	return *v, true
}

// OldItemId returns the old itemId value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldItemId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemId: %w", err)
	}
	return oldValue.ItemId, nil
}

// AddItemId adds i to itemId.
func (m *ImmunityMutation) AddItemId(i int) {
	if m.additemId != nil {
		*m.additemId += i
	} else {
		m.additemId = &i
	}
}

// AddedItemId returns the value that was added to the itemId field in this mutation.
func (m *ImmunityMutation) AddedItemId() (r int, exists bool) {
	v := m.additemId
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemId reset all changes of the "itemId" field.
func (m *ImmunityMutation) ResetItemId() {
	m.itemId = nil
	m.additemId = nil
}

// SetItemName sets the itemName field.
func (m *ImmunityMutation) SetItemName(s string) {
	m.itemName = &s
}

// ItemName returns the itemName value in the mutation.
func (m *ImmunityMutation) ItemName() (r string, exists bool) {
	v := m.itemName
	if v == nil {
		return
	}
	return *v, true
}

// OldItemName returns the old itemName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldItemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemName: %w", err)
	}
	return oldValue.ItemName, nil
}

// ResetItemName reset all changes of the "itemName" field.
func (m *ImmunityMutation) ResetItemName() {
	m.itemName = nil
}

// SetUserName sets the userName field.
func (m *ImmunityMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *ImmunityMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *ImmunityMutation) ResetUserName() {
	m.userName = nil
}

// SetDrug sets the drug field.
func (m *ImmunityMutation) SetDrug(s string) {
	m.drug = &s
}

// Drug returns the drug value in the mutation.
func (m *ImmunityMutation) Drug() (r string, exists bool) {
	v := m.drug
	if v == nil {
		return
	}
	return *v, true
}

// OldDrug returns the old drug value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldDrug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDrug is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDrug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrug: %w", err)
	}
	return oldValue.Drug, nil
}

// ResetDrug reset all changes of the "drug" field.
func (m *ImmunityMutation) ResetDrug() {
	m.drug = nil
}

// SetRemarks sets the remarks field.
func (m *ImmunityMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ImmunityMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ImmunityMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ImmunityMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ImmunityMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ImmunityMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ImmunityMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ImmunityMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ImmunityMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ImmunityMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ImmunityMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ImmunityMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ImmunityMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ImmunityMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ImmunityMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ImmunityMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ImmunityMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ImmunityMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ImmunityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Immunity).
func (m *ImmunityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ImmunityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, immunity.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, immunity.FieldEarNumber)
	}
	if m.shedName != nil {
		fields = append(fields, immunity.FieldShedName)
	}
	if m.date != nil {
		fields = append(fields, immunity.FieldDate)
	}
	if m.itemId != nil {
		fields = append(fields, immunity.FieldItemId)
	}
	if m.itemName != nil {
		fields = append(fields, immunity.FieldItemName)
	}
	if m.userName != nil {
		fields = append(fields, immunity.FieldUserName)
	}
	if m.drug != nil {
		fields = append(fields, immunity.FieldDrug)
	}
	if m.remarks != nil {
		fields = append(fields, immunity.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, immunity.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, immunity.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, immunity.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ImmunityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case immunity.FieldName:
		return m.Name()
	case immunity.FieldEarNumber:
		return m.EarNumber()
	case immunity.FieldShedName:
		return m.ShedName()
	case immunity.FieldDate:
		return m.Date()
	case immunity.FieldItemId:
		return m.ItemId()
	case immunity.FieldItemName:
		return m.ItemName()
	case immunity.FieldUserName:
		return m.UserName()
	case immunity.FieldDrug:
		return m.Drug()
	case immunity.FieldRemarks:
		return m.Remarks()
	case immunity.FieldCreatedAt:
		return m.CreatedAt()
	case immunity.FieldUpdatedAt:
		return m.UpdatedAt()
	case immunity.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ImmunityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case immunity.FieldName:
		return m.OldName(ctx)
	case immunity.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case immunity.FieldShedName:
		return m.OldShedName(ctx)
	case immunity.FieldDate:
		return m.OldDate(ctx)
	case immunity.FieldItemId:
		return m.OldItemId(ctx)
	case immunity.FieldItemName:
		return m.OldItemName(ctx)
	case immunity.FieldUserName:
		return m.OldUserName(ctx)
	case immunity.FieldDrug:
		return m.OldDrug(ctx)
	case immunity.FieldRemarks:
		return m.OldRemarks(ctx)
	case immunity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case immunity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case immunity.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Immunity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ImmunityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case immunity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case immunity.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case immunity.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case immunity.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case immunity.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemId(v)
		return nil
	case immunity.FieldItemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemName(v)
		return nil
	case immunity.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case immunity.FieldDrug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrug(v)
		return nil
	case immunity.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case immunity.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case immunity.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case immunity.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Immunity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ImmunityMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, immunity.FieldDate)
	}
	if m.additemId != nil {
		fields = append(fields, immunity.FieldItemId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, immunity.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, immunity.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, immunity.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ImmunityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case immunity.FieldDate:
		return m.AddedDate()
	case immunity.FieldItemId:
		return m.AddedItemId()
	case immunity.FieldCreatedAt:
		return m.AddedCreatedAt()
	case immunity.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case immunity.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ImmunityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case immunity.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case immunity.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemId(v)
		return nil
	case immunity.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case immunity.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case immunity.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Immunity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ImmunityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ImmunityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImmunityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Immunity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ImmunityMutation) ResetField(name string) error {
	switch name {
	case immunity.FieldName:
		m.ResetName()
		return nil
	case immunity.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case immunity.FieldShedName:
		m.ResetShedName()
		return nil
	case immunity.FieldDate:
		m.ResetDate()
		return nil
	case immunity.FieldItemId:
		m.ResetItemId()
		return nil
	case immunity.FieldItemName:
		m.ResetItemName()
		return nil
	case immunity.FieldUserName:
		m.ResetUserName()
		return nil
	case immunity.FieldDrug:
		m.ResetDrug()
		return nil
	case immunity.FieldRemarks:
		m.ResetRemarks()
		return nil
	case immunity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case immunity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case immunity.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Immunity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ImmunityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ImmunityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ImmunityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ImmunityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ImmunityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ImmunityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ImmunityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Immunity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ImmunityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Immunity edge %s", name)
}

// InspectionMutation represents an operation that mutate the Inspections
// nodes in the graph.
type InspectionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	earNumber     *string
	shedName      *string
	date          *int64
	adddate       *int64
	itemId        *int
	additemId     *int
	itemName      *string
	methodId      *int
	addmethodId   *int
	methodName    *string
	byId          *int64
	addbyId       *int64
	byName        *string
	resultId      *int64
	addresultId   *int64
	resultName    *string
	handleId      *int
	addhandleId   *int
	handleName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Inspection, error)
}

var _ ent.Mutation = (*InspectionMutation)(nil)

// inspectionOption allows to manage the mutation configuration using functional options.
type inspectionOption func(*InspectionMutation)

// newInspectionMutation creates new mutation for $n.Name.
func newInspectionMutation(c config, op Op, opts ...inspectionOption) *InspectionMutation {
	m := &InspectionMutation{
		config:        c,
		op:            op,
		typ:           TypeInspection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInspectionID sets the id field of the mutation.
func withInspectionID(id int64) inspectionOption {
	return func(m *InspectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Inspection
		)
		m.oldValue = func(ctx context.Context) (*Inspection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inspection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInspection sets the old Inspection of the mutation.
func withInspection(node *Inspection) inspectionOption {
	return func(m *InspectionMutation) {
		m.oldValue = func(context.Context) (*Inspection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InspectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InspectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InspectionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *InspectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *InspectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *InspectionMutation) ResetName() {
	m.name = nil
}

// SetEarNumber sets the earNumber field.
func (m *InspectionMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *InspectionMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *InspectionMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetShedName sets the shedName field.
func (m *InspectionMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *InspectionMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *InspectionMutation) ResetShedName() {
	m.shedName = nil
}

// SetDate sets the date field.
func (m *InspectionMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *InspectionMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *InspectionMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *InspectionMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *InspectionMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetItemId sets the itemId field.
func (m *InspectionMutation) SetItemId(i int) {
	m.itemId = &i
	m.additemId = nil
}

// ItemId returns the itemId value in the mutation.
func (m *InspectionMutation) ItemId() (r int, exists bool) {
	v := m.itemId
	if v == nil {
		return
	}
	return *v, true
}

// OldItemId returns the old itemId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldItemId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemId: %w", err)
	}
	return oldValue.ItemId, nil
}

// AddItemId adds i to itemId.
func (m *InspectionMutation) AddItemId(i int) {
	if m.additemId != nil {
		*m.additemId += i
	} else {
		m.additemId = &i
	}
}

// AddedItemId returns the value that was added to the itemId field in this mutation.
func (m *InspectionMutation) AddedItemId() (r int, exists bool) {
	v := m.additemId
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemId reset all changes of the "itemId" field.
func (m *InspectionMutation) ResetItemId() {
	m.itemId = nil
	m.additemId = nil
}

// SetItemName sets the itemName field.
func (m *InspectionMutation) SetItemName(s string) {
	m.itemName = &s
}

// ItemName returns the itemName value in the mutation.
func (m *InspectionMutation) ItemName() (r string, exists bool) {
	v := m.itemName
	if v == nil {
		return
	}
	return *v, true
}

// OldItemName returns the old itemName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldItemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemName: %w", err)
	}
	return oldValue.ItemName, nil
}

// ResetItemName reset all changes of the "itemName" field.
func (m *InspectionMutation) ResetItemName() {
	m.itemName = nil
}

// SetMethodId sets the methodId field.
func (m *InspectionMutation) SetMethodId(i int) {
	m.methodId = &i
	m.addmethodId = nil
}

// MethodId returns the methodId value in the mutation.
func (m *InspectionMutation) MethodId() (r int, exists bool) {
	v := m.methodId
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodId returns the old methodId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldMethodId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodId: %w", err)
	}
	return oldValue.MethodId, nil
}

// AddMethodId adds i to methodId.
func (m *InspectionMutation) AddMethodId(i int) {
	if m.addmethodId != nil {
		*m.addmethodId += i
	} else {
		m.addmethodId = &i
	}
}

// AddedMethodId returns the value that was added to the methodId field in this mutation.
func (m *InspectionMutation) AddedMethodId() (r int, exists bool) {
	v := m.addmethodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetMethodId reset all changes of the "methodId" field.
func (m *InspectionMutation) ResetMethodId() {
	m.methodId = nil
	m.addmethodId = nil
}

// SetMethodName sets the methodName field.
func (m *InspectionMutation) SetMethodName(s string) {
	m.methodName = &s
}

// MethodName returns the methodName value in the mutation.
func (m *InspectionMutation) MethodName() (r string, exists bool) {
	v := m.methodName
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodName returns the old methodName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodName: %w", err)
	}
	return oldValue.MethodName, nil
}

// ResetMethodName reset all changes of the "methodName" field.
func (m *InspectionMutation) ResetMethodName() {
	m.methodName = nil
}

// SetById sets the byId field.
func (m *InspectionMutation) SetById(i int64) {
	m.byId = &i
	m.addbyId = nil
}

// ById returns the byId value in the mutation.
func (m *InspectionMutation) ById() (r int64, exists bool) {
	v := m.byId
	if v == nil {
		return
	}
	return *v, true
}

// OldById returns the old byId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldById(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldById is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldById: %w", err)
	}
	return oldValue.ById, nil
}

// AddById adds i to byId.
func (m *InspectionMutation) AddById(i int64) {
	if m.addbyId != nil {
		*m.addbyId += i
	} else {
		m.addbyId = &i
	}
}

// AddedById returns the value that was added to the byId field in this mutation.
func (m *InspectionMutation) AddedById() (r int64, exists bool) {
	v := m.addbyId
	if v == nil {
		return
	}
	return *v, true
}

// ResetById reset all changes of the "byId" field.
func (m *InspectionMutation) ResetById() {
	m.byId = nil
	m.addbyId = nil
}

// SetByName sets the byName field.
func (m *InspectionMutation) SetByName(s string) {
	m.byName = &s
}

// ByName returns the byName value in the mutation.
func (m *InspectionMutation) ByName() (r string, exists bool) {
	v := m.byName
	if v == nil {
		return
	}
	return *v, true
}

// OldByName returns the old byName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldByName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldByName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldByName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldByName: %w", err)
	}
	return oldValue.ByName, nil
}

// ResetByName reset all changes of the "byName" field.
func (m *InspectionMutation) ResetByName() {
	m.byName = nil
}

// SetResultId sets the resultId field.
func (m *InspectionMutation) SetResultId(i int64) {
	m.resultId = &i
	m.addresultId = nil
}

// ResultId returns the resultId value in the mutation.
func (m *InspectionMutation) ResultId() (r int64, exists bool) {
	v := m.resultId
	if v == nil {
		return
	}
	return *v, true
}

// OldResultId returns the old resultId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldResultId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResultId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResultId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultId: %w", err)
	}
	return oldValue.ResultId, nil
}

// AddResultId adds i to resultId.
func (m *InspectionMutation) AddResultId(i int64) {
	if m.addresultId != nil {
		*m.addresultId += i
	} else {
		m.addresultId = &i
	}
}

// AddedResultId returns the value that was added to the resultId field in this mutation.
func (m *InspectionMutation) AddedResultId() (r int64, exists bool) {
	v := m.addresultId
	if v == nil {
		return
	}
	return *v, true
}

// ResetResultId reset all changes of the "resultId" field.
func (m *InspectionMutation) ResetResultId() {
	m.resultId = nil
	m.addresultId = nil
}

// SetResultName sets the resultName field.
func (m *InspectionMutation) SetResultName(s string) {
	m.resultName = &s
}

// ResultName returns the resultName value in the mutation.
func (m *InspectionMutation) ResultName() (r string, exists bool) {
	v := m.resultName
	if v == nil {
		return
	}
	return *v, true
}

// OldResultName returns the old resultName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldResultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResultName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultName: %w", err)
	}
	return oldValue.ResultName, nil
}

// ResetResultName reset all changes of the "resultName" field.
func (m *InspectionMutation) ResetResultName() {
	m.resultName = nil
}

// SetHandleId sets the handleId field.
func (m *InspectionMutation) SetHandleId(i int) {
	m.handleId = &i
	m.addhandleId = nil
}

// HandleId returns the handleId value in the mutation.
func (m *InspectionMutation) HandleId() (r int, exists bool) {
	v := m.handleId
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleId returns the old handleId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldHandleId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHandleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHandleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleId: %w", err)
	}
	return oldValue.HandleId, nil
}

// AddHandleId adds i to handleId.
func (m *InspectionMutation) AddHandleId(i int) {
	if m.addhandleId != nil {
		*m.addhandleId += i
	} else {
		m.addhandleId = &i
	}
}

// AddedHandleId returns the value that was added to the handleId field in this mutation.
func (m *InspectionMutation) AddedHandleId() (r int, exists bool) {
	v := m.addhandleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandleId reset all changes of the "handleId" field.
func (m *InspectionMutation) ResetHandleId() {
	m.handleId = nil
	m.addhandleId = nil
}

// SetHandleName sets the handleName field.
func (m *InspectionMutation) SetHandleName(s string) {
	m.handleName = &s
}

// HandleName returns the handleName value in the mutation.
func (m *InspectionMutation) HandleName() (r string, exists bool) {
	v := m.handleName
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleName returns the old handleName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldHandleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHandleName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHandleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleName: %w", err)
	}
	return oldValue.HandleName, nil
}

// ResetHandleName reset all changes of the "handleName" field.
func (m *InspectionMutation) ResetHandleName() {
	m.handleName = nil
}

// SetRemarks sets the remarks field.
func (m *InspectionMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *InspectionMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *InspectionMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *InspectionMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *InspectionMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *InspectionMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *InspectionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *InspectionMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *InspectionMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *InspectionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *InspectionMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *InspectionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *InspectionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *InspectionMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *InspectionMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *InspectionMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *InspectionMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *InspectionMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *InspectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inspection).
func (m *InspectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InspectionMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, inspection.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, inspection.FieldEarNumber)
	}
	if m.shedName != nil {
		fields = append(fields, inspection.FieldShedName)
	}
	if m.date != nil {
		fields = append(fields, inspection.FieldDate)
	}
	if m.itemId != nil {
		fields = append(fields, inspection.FieldItemId)
	}
	if m.itemName != nil {
		fields = append(fields, inspection.FieldItemName)
	}
	if m.methodId != nil {
		fields = append(fields, inspection.FieldMethodId)
	}
	if m.methodName != nil {
		fields = append(fields, inspection.FieldMethodName)
	}
	if m.byId != nil {
		fields = append(fields, inspection.FieldById)
	}
	if m.byName != nil {
		fields = append(fields, inspection.FieldByName)
	}
	if m.resultId != nil {
		fields = append(fields, inspection.FieldResultId)
	}
	if m.resultName != nil {
		fields = append(fields, inspection.FieldResultName)
	}
	if m.handleId != nil {
		fields = append(fields, inspection.FieldHandleId)
	}
	if m.handleName != nil {
		fields = append(fields, inspection.FieldHandleName)
	}
	if m.remarks != nil {
		fields = append(fields, inspection.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, inspection.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, inspection.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, inspection.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InspectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inspection.FieldName:
		return m.Name()
	case inspection.FieldEarNumber:
		return m.EarNumber()
	case inspection.FieldShedName:
		return m.ShedName()
	case inspection.FieldDate:
		return m.Date()
	case inspection.FieldItemId:
		return m.ItemId()
	case inspection.FieldItemName:
		return m.ItemName()
	case inspection.FieldMethodId:
		return m.MethodId()
	case inspection.FieldMethodName:
		return m.MethodName()
	case inspection.FieldById:
		return m.ById()
	case inspection.FieldByName:
		return m.ByName()
	case inspection.FieldResultId:
		return m.ResultId()
	case inspection.FieldResultName:
		return m.ResultName()
	case inspection.FieldHandleId:
		return m.HandleId()
	case inspection.FieldHandleName:
		return m.HandleName()
	case inspection.FieldRemarks:
		return m.Remarks()
	case inspection.FieldCreatedAt:
		return m.CreatedAt()
	case inspection.FieldUpdatedAt:
		return m.UpdatedAt()
	case inspection.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InspectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inspection.FieldName:
		return m.OldName(ctx)
	case inspection.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case inspection.FieldShedName:
		return m.OldShedName(ctx)
	case inspection.FieldDate:
		return m.OldDate(ctx)
	case inspection.FieldItemId:
		return m.OldItemId(ctx)
	case inspection.FieldItemName:
		return m.OldItemName(ctx)
	case inspection.FieldMethodId:
		return m.OldMethodId(ctx)
	case inspection.FieldMethodName:
		return m.OldMethodName(ctx)
	case inspection.FieldById:
		return m.OldById(ctx)
	case inspection.FieldByName:
		return m.OldByName(ctx)
	case inspection.FieldResultId:
		return m.OldResultId(ctx)
	case inspection.FieldResultName:
		return m.OldResultName(ctx)
	case inspection.FieldHandleId:
		return m.OldHandleId(ctx)
	case inspection.FieldHandleName:
		return m.OldHandleName(ctx)
	case inspection.FieldRemarks:
		return m.OldRemarks(ctx)
	case inspection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inspection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inspection.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Inspection field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InspectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inspection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inspection.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case inspection.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case inspection.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case inspection.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemId(v)
		return nil
	case inspection.FieldItemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemName(v)
		return nil
	case inspection.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodId(v)
		return nil
	case inspection.FieldMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodName(v)
		return nil
	case inspection.FieldById:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetById(v)
		return nil
	case inspection.FieldByName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetByName(v)
		return nil
	case inspection.FieldResultId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultId(v)
		return nil
	case inspection.FieldResultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultName(v)
		return nil
	case inspection.FieldHandleId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleId(v)
		return nil
	case inspection.FieldHandleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleName(v)
		return nil
	case inspection.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case inspection.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inspection.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inspection.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Inspection field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InspectionMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, inspection.FieldDate)
	}
	if m.additemId != nil {
		fields = append(fields, inspection.FieldItemId)
	}
	if m.addmethodId != nil {
		fields = append(fields, inspection.FieldMethodId)
	}
	if m.addbyId != nil {
		fields = append(fields, inspection.FieldById)
	}
	if m.addresultId != nil {
		fields = append(fields, inspection.FieldResultId)
	}
	if m.addhandleId != nil {
		fields = append(fields, inspection.FieldHandleId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, inspection.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, inspection.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, inspection.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InspectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inspection.FieldDate:
		return m.AddedDate()
	case inspection.FieldItemId:
		return m.AddedItemId()
	case inspection.FieldMethodId:
		return m.AddedMethodId()
	case inspection.FieldById:
		return m.AddedById()
	case inspection.FieldResultId:
		return m.AddedResultId()
	case inspection.FieldHandleId:
		return m.AddedHandleId()
	case inspection.FieldCreatedAt:
		return m.AddedCreatedAt()
	case inspection.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case inspection.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InspectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inspection.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case inspection.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemId(v)
		return nil
	case inspection.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethodId(v)
		return nil
	case inspection.FieldById:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddById(v)
		return nil
	case inspection.FieldResultId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResultId(v)
		return nil
	case inspection.FieldHandleId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandleId(v)
		return nil
	case inspection.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case inspection.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case inspection.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Inspection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InspectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InspectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InspectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Inspection nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InspectionMutation) ResetField(name string) error {
	switch name {
	case inspection.FieldName:
		m.ResetName()
		return nil
	case inspection.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case inspection.FieldShedName:
		m.ResetShedName()
		return nil
	case inspection.FieldDate:
		m.ResetDate()
		return nil
	case inspection.FieldItemId:
		m.ResetItemId()
		return nil
	case inspection.FieldItemName:
		m.ResetItemName()
		return nil
	case inspection.FieldMethodId:
		m.ResetMethodId()
		return nil
	case inspection.FieldMethodName:
		m.ResetMethodName()
		return nil
	case inspection.FieldById:
		m.ResetById()
		return nil
	case inspection.FieldByName:
		m.ResetByName()
		return nil
	case inspection.FieldResultId:
		m.ResetResultId()
		return nil
	case inspection.FieldResultName:
		m.ResetResultName()
		return nil
	case inspection.FieldHandleId:
		m.ResetHandleId()
		return nil
	case inspection.FieldHandleName:
		m.ResetHandleName()
		return nil
	case inspection.FieldRemarks:
		m.ResetRemarks()
		return nil
	case inspection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inspection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inspection.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Inspection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InspectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InspectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InspectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InspectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InspectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InspectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InspectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Inspection unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InspectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Inspection edge %s", name)
}

// MaterialMutation represents an operation that mutate the Materials
// nodes in the graph.
type MaterialMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	seqNumber     *string
	date          *int64
	adddate       *int64
	_type         *int
	add_type      *int
	count         *int
	addcount      *int
	category      *int
	addcategory   *int
	status        *int
	addstatus     *int
	userName      *string
	payAt         *int64
	addpayAt      *int64
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Material, error)
}

var _ ent.Mutation = (*MaterialMutation)(nil)

// materialOption allows to manage the mutation configuration using functional options.
type materialOption func(*MaterialMutation)

// newMaterialMutation creates new mutation for $n.Name.
func newMaterialMutation(c config, op Op, opts ...materialOption) *MaterialMutation {
	m := &MaterialMutation{
		config:        c,
		op:            op,
		typ:           TypeMaterial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaterialID sets the id field of the mutation.
func withMaterialID(id int64) materialOption {
	return func(m *MaterialMutation) {
		var (
			err   error
			once  sync.Once
			value *Material
		)
		m.oldValue = func(ctx context.Context) (*Material, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Material.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaterial sets the old Material of the mutation.
func withMaterial(node *Material) materialOption {
	return func(m *MaterialMutation) {
		m.oldValue = func(context.Context) (*Material, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaterialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaterialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MaterialMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MaterialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MaterialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MaterialMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *MaterialMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *MaterialMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *MaterialMutation) ResetCode() {
	m.code = nil
}

// SetSeqNumber sets the seqNumber field.
func (m *MaterialMutation) SetSeqNumber(s string) {
	m.seqNumber = &s
}

// SeqNumber returns the seqNumber value in the mutation.
func (m *MaterialMutation) SeqNumber() (r string, exists bool) {
	v := m.seqNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNumber returns the old seqNumber value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldSeqNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeqNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeqNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNumber: %w", err)
	}
	return oldValue.SeqNumber, nil
}

// ResetSeqNumber reset all changes of the "seqNumber" field.
func (m *MaterialMutation) ResetSeqNumber() {
	m.seqNumber = nil
}

// SetDate sets the date field.
func (m *MaterialMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *MaterialMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *MaterialMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *MaterialMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *MaterialMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetType sets the type field.
func (m *MaterialMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *MaterialMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *MaterialMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *MaterialMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *MaterialMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCount sets the count field.
func (m *MaterialMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *MaterialMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to count.
func (m *MaterialMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *MaterialMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *MaterialMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetCategory sets the category field.
func (m *MaterialMutation) SetCategory(i int) {
	m.category = &i
	m.addcategory = nil
}

// Category returns the category value in the mutation.
func (m *MaterialMutation) Category() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old category value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCategory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// AddCategory adds i to category.
func (m *MaterialMutation) AddCategory(i int) {
	if m.addcategory != nil {
		*m.addcategory += i
	} else {
		m.addcategory = &i
	}
}

// AddedCategory returns the value that was added to the category field in this mutation.
func (m *MaterialMutation) AddedCategory() (r int, exists bool) {
	v := m.addcategory
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategory reset all changes of the "category" field.
func (m *MaterialMutation) ResetCategory() {
	m.category = nil
	m.addcategory = nil
}

// SetStatus sets the status field.
func (m *MaterialMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *MaterialMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *MaterialMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *MaterialMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *MaterialMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetUserName sets the userName field.
func (m *MaterialMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *MaterialMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *MaterialMutation) ResetUserName() {
	m.userName = nil
}

// SetPayAt sets the payAt field.
func (m *MaterialMutation) SetPayAt(i int64) {
	m.payAt = &i
	m.addpayAt = nil
}

// PayAt returns the payAt value in the mutation.
func (m *MaterialMutation) PayAt() (r int64, exists bool) {
	v := m.payAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPayAt returns the old payAt value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldPayAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayAt: %w", err)
	}
	return oldValue.PayAt, nil
}

// AddPayAt adds i to payAt.
func (m *MaterialMutation) AddPayAt(i int64) {
	if m.addpayAt != nil {
		*m.addpayAt += i
	} else {
		m.addpayAt = &i
	}
}

// AddedPayAt returns the value that was added to the payAt field in this mutation.
func (m *MaterialMutation) AddedPayAt() (r int64, exists bool) {
	v := m.addpayAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayAt reset all changes of the "payAt" field.
func (m *MaterialMutation) ResetPayAt() {
	m.payAt = nil
	m.addpayAt = nil
}

// SetRemarks sets the remarks field.
func (m *MaterialMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *MaterialMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *MaterialMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *MaterialMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *MaterialMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *MaterialMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *MaterialMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *MaterialMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *MaterialMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *MaterialMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *MaterialMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *MaterialMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *MaterialMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *MaterialMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *MaterialMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *MaterialMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *MaterialMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *MaterialMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *MaterialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Material).
func (m *MaterialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MaterialMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, material.FieldName)
	}
	if m.code != nil {
		fields = append(fields, material.FieldCode)
	}
	if m.seqNumber != nil {
		fields = append(fields, material.FieldSeqNumber)
	}
	if m.date != nil {
		fields = append(fields, material.FieldDate)
	}
	if m._type != nil {
		fields = append(fields, material.FieldType)
	}
	if m.count != nil {
		fields = append(fields, material.FieldCount)
	}
	if m.category != nil {
		fields = append(fields, material.FieldCategory)
	}
	if m.status != nil {
		fields = append(fields, material.FieldStatus)
	}
	if m.userName != nil {
		fields = append(fields, material.FieldUserName)
	}
	if m.payAt != nil {
		fields = append(fields, material.FieldPayAt)
	}
	if m.remarks != nil {
		fields = append(fields, material.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, material.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, material.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, material.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MaterialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case material.FieldName:
		return m.Name()
	case material.FieldCode:
		return m.Code()
	case material.FieldSeqNumber:
		return m.SeqNumber()
	case material.FieldDate:
		return m.Date()
	case material.FieldType:
		return m.GetType()
	case material.FieldCount:
		return m.Count()
	case material.FieldCategory:
		return m.Category()
	case material.FieldStatus:
		return m.Status()
	case material.FieldUserName:
		return m.UserName()
	case material.FieldPayAt:
		return m.PayAt()
	case material.FieldRemarks:
		return m.Remarks()
	case material.FieldCreatedAt:
		return m.CreatedAt()
	case material.FieldUpdatedAt:
		return m.UpdatedAt()
	case material.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MaterialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case material.FieldName:
		return m.OldName(ctx)
	case material.FieldCode:
		return m.OldCode(ctx)
	case material.FieldSeqNumber:
		return m.OldSeqNumber(ctx)
	case material.FieldDate:
		return m.OldDate(ctx)
	case material.FieldType:
		return m.OldType(ctx)
	case material.FieldCount:
		return m.OldCount(ctx)
	case material.FieldCategory:
		return m.OldCategory(ctx)
	case material.FieldStatus:
		return m.OldStatus(ctx)
	case material.FieldUserName:
		return m.OldUserName(ctx)
	case material.FieldPayAt:
		return m.OldPayAt(ctx)
	case material.FieldRemarks:
		return m.OldRemarks(ctx)
	case material.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case material.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case material.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Material field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case material.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case material.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case material.FieldSeqNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNumber(v)
		return nil
	case material.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case material.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case material.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case material.FieldCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case material.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case material.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case material.FieldPayAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayAt(v)
		return nil
	case material.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case material.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case material.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case material.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Material field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MaterialMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, material.FieldDate)
	}
	if m.add_type != nil {
		fields = append(fields, material.FieldType)
	}
	if m.addcount != nil {
		fields = append(fields, material.FieldCount)
	}
	if m.addcategory != nil {
		fields = append(fields, material.FieldCategory)
	}
	if m.addstatus != nil {
		fields = append(fields, material.FieldStatus)
	}
	if m.addpayAt != nil {
		fields = append(fields, material.FieldPayAt)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, material.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, material.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, material.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MaterialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case material.FieldDate:
		return m.AddedDate()
	case material.FieldType:
		return m.AddedType()
	case material.FieldCount:
		return m.AddedCount()
	case material.FieldCategory:
		return m.AddedCategory()
	case material.FieldStatus:
		return m.AddedStatus()
	case material.FieldPayAt:
		return m.AddedPayAt()
	case material.FieldCreatedAt:
		return m.AddedCreatedAt()
	case material.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case material.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case material.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case material.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case material.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case material.FieldCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategory(v)
		return nil
	case material.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case material.FieldPayAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayAt(v)
		return nil
	case material.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case material.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case material.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Material numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MaterialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MaterialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaterialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Material nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MaterialMutation) ResetField(name string) error {
	switch name {
	case material.FieldName:
		m.ResetName()
		return nil
	case material.FieldCode:
		m.ResetCode()
		return nil
	case material.FieldSeqNumber:
		m.ResetSeqNumber()
		return nil
	case material.FieldDate:
		m.ResetDate()
		return nil
	case material.FieldType:
		m.ResetType()
		return nil
	case material.FieldCount:
		m.ResetCount()
		return nil
	case material.FieldCategory:
		m.ResetCategory()
		return nil
	case material.FieldStatus:
		m.ResetStatus()
		return nil
	case material.FieldUserName:
		m.ResetUserName()
		return nil
	case material.FieldPayAt:
		m.ResetPayAt()
		return nil
	case material.FieldRemarks:
		m.ResetRemarks()
		return nil
	case material.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case material.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case material.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Material field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MaterialMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MaterialMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MaterialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MaterialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MaterialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MaterialMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MaterialMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Material unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MaterialMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Material edge %s", name)
}

// MaterialTestMutation represents an operation that mutate the MaterialTests
// nodes in the graph.
type MaterialTestMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	name                *string
	code                *string
	seqNumber           *string
	addSeqNumber        *string
	date                *int64
	adddate             *int64
	_type               *int
	add_type            *int
	category            *int
	addcategory         *int
	materialCategory    *int
	addmaterialCategory *int
	userName            *string
	remarks             *string
	createdAt           *int64
	addcreatedAt        *int64
	updatedAt           *int64
	addupdatedAt        *int64
	deleted             *int
	adddeleted          *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*MaterialTest, error)
}

var _ ent.Mutation = (*MaterialTestMutation)(nil)

// materialtestOption allows to manage the mutation configuration using functional options.
type materialtestOption func(*MaterialTestMutation)

// newMaterialTestMutation creates new mutation for $n.Name.
func newMaterialTestMutation(c config, op Op, opts ...materialtestOption) *MaterialTestMutation {
	m := &MaterialTestMutation{
		config:        c,
		op:            op,
		typ:           TypeMaterialTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaterialTestID sets the id field of the mutation.
func withMaterialTestID(id int64) materialtestOption {
	return func(m *MaterialTestMutation) {
		var (
			err   error
			once  sync.Once
			value *MaterialTest
		)
		m.oldValue = func(ctx context.Context) (*MaterialTest, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MaterialTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaterialTest sets the old MaterialTest of the mutation.
func withMaterialTest(node *MaterialTest) materialtestOption {
	return func(m *MaterialTestMutation) {
		m.oldValue = func(context.Context) (*MaterialTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaterialTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaterialTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MaterialTestMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MaterialTestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MaterialTestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MaterialTestMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *MaterialTestMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *MaterialTestMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *MaterialTestMutation) ResetCode() {
	m.code = nil
}

// SetSeqNumber sets the seqNumber field.
func (m *MaterialTestMutation) SetSeqNumber(s string) {
	m.seqNumber = &s
}

// SeqNumber returns the seqNumber value in the mutation.
func (m *MaterialTestMutation) SeqNumber() (r string, exists bool) {
	v := m.seqNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNumber returns the old seqNumber value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldSeqNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeqNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeqNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNumber: %w", err)
	}
	return oldValue.SeqNumber, nil
}

// ResetSeqNumber reset all changes of the "seqNumber" field.
func (m *MaterialTestMutation) ResetSeqNumber() {
	m.seqNumber = nil
}

// SetAddSeqNumber sets the addSeqNumber field.
func (m *MaterialTestMutation) SetAddSeqNumber(s string) {
	m.addSeqNumber = &s
}

// AddSeqNumber returns the addSeqNumber value in the mutation.
func (m *MaterialTestMutation) AddSeqNumber() (r string, exists bool) {
	v := m.addSeqNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldAddSeqNumber returns the old addSeqNumber value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldAddSeqNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddSeqNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddSeqNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddSeqNumber: %w", err)
	}
	return oldValue.AddSeqNumber, nil
}

// ResetAddSeqNumber reset all changes of the "addSeqNumber" field.
func (m *MaterialTestMutation) ResetAddSeqNumber() {
	m.addSeqNumber = nil
}

// SetDate sets the date field.
func (m *MaterialTestMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *MaterialTestMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *MaterialTestMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *MaterialTestMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *MaterialTestMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetType sets the type field.
func (m *MaterialTestMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *MaterialTestMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *MaterialTestMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *MaterialTestMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *MaterialTestMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCategory sets the category field.
func (m *MaterialTestMutation) SetCategory(i int) {
	m.category = &i
	m.addcategory = nil
}

// Category returns the category value in the mutation.
func (m *MaterialTestMutation) Category() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old category value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldCategory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// AddCategory adds i to category.
func (m *MaterialTestMutation) AddCategory(i int) {
	if m.addcategory != nil {
		*m.addcategory += i
	} else {
		m.addcategory = &i
	}
}

// AddedCategory returns the value that was added to the category field in this mutation.
func (m *MaterialTestMutation) AddedCategory() (r int, exists bool) {
	v := m.addcategory
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategory reset all changes of the "category" field.
func (m *MaterialTestMutation) ResetCategory() {
	m.category = nil
	m.addcategory = nil
}

// SetMaterialCategory sets the materialCategory field.
func (m *MaterialTestMutation) SetMaterialCategory(i int) {
	m.materialCategory = &i
	m.addmaterialCategory = nil
}

// MaterialCategory returns the materialCategory value in the mutation.
func (m *MaterialTestMutation) MaterialCategory() (r int, exists bool) {
	v := m.materialCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialCategory returns the old materialCategory value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldMaterialCategory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialCategory: %w", err)
	}
	return oldValue.MaterialCategory, nil
}

// AddMaterialCategory adds i to materialCategory.
func (m *MaterialTestMutation) AddMaterialCategory(i int) {
	if m.addmaterialCategory != nil {
		*m.addmaterialCategory += i
	} else {
		m.addmaterialCategory = &i
	}
}

// AddedMaterialCategory returns the value that was added to the materialCategory field in this mutation.
func (m *MaterialTestMutation) AddedMaterialCategory() (r int, exists bool) {
	v := m.addmaterialCategory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaterialCategory reset all changes of the "materialCategory" field.
func (m *MaterialTestMutation) ResetMaterialCategory() {
	m.materialCategory = nil
	m.addmaterialCategory = nil
}

// SetUserName sets the userName field.
func (m *MaterialTestMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *MaterialTestMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *MaterialTestMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *MaterialTestMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *MaterialTestMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *MaterialTestMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *MaterialTestMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *MaterialTestMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *MaterialTestMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *MaterialTestMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *MaterialTestMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *MaterialTestMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *MaterialTestMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *MaterialTestMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *MaterialTestMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *MaterialTestMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *MaterialTestMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *MaterialTestMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *MaterialTestMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *MaterialTestMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *MaterialTestMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *MaterialTestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MaterialTest).
func (m *MaterialTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MaterialTestMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, materialtest.FieldName)
	}
	if m.code != nil {
		fields = append(fields, materialtest.FieldCode)
	}
	if m.seqNumber != nil {
		fields = append(fields, materialtest.FieldSeqNumber)
	}
	if m.addSeqNumber != nil {
		fields = append(fields, materialtest.FieldAddSeqNumber)
	}
	if m.date != nil {
		fields = append(fields, materialtest.FieldDate)
	}
	if m._type != nil {
		fields = append(fields, materialtest.FieldType)
	}
	if m.category != nil {
		fields = append(fields, materialtest.FieldCategory)
	}
	if m.materialCategory != nil {
		fields = append(fields, materialtest.FieldMaterialCategory)
	}
	if m.userName != nil {
		fields = append(fields, materialtest.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, materialtest.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, materialtest.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, materialtest.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, materialtest.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MaterialTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case materialtest.FieldName:
		return m.Name()
	case materialtest.FieldCode:
		return m.Code()
	case materialtest.FieldSeqNumber:
		return m.SeqNumber()
	case materialtest.FieldAddSeqNumber:
		return m.AddSeqNumber()
	case materialtest.FieldDate:
		return m.Date()
	case materialtest.FieldType:
		return m.GetType()
	case materialtest.FieldCategory:
		return m.Category()
	case materialtest.FieldMaterialCategory:
		return m.MaterialCategory()
	case materialtest.FieldUserName:
		return m.UserName()
	case materialtest.FieldRemarks:
		return m.Remarks()
	case materialtest.FieldCreatedAt:
		return m.CreatedAt()
	case materialtest.FieldUpdatedAt:
		return m.UpdatedAt()
	case materialtest.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MaterialTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case materialtest.FieldName:
		return m.OldName(ctx)
	case materialtest.FieldCode:
		return m.OldCode(ctx)
	case materialtest.FieldSeqNumber:
		return m.OldSeqNumber(ctx)
	case materialtest.FieldAddSeqNumber:
		return m.OldAddSeqNumber(ctx)
	case materialtest.FieldDate:
		return m.OldDate(ctx)
	case materialtest.FieldType:
		return m.OldType(ctx)
	case materialtest.FieldCategory:
		return m.OldCategory(ctx)
	case materialtest.FieldMaterialCategory:
		return m.OldMaterialCategory(ctx)
	case materialtest.FieldUserName:
		return m.OldUserName(ctx)
	case materialtest.FieldRemarks:
		return m.OldRemarks(ctx)
	case materialtest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case materialtest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case materialtest.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown MaterialTest field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case materialtest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case materialtest.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case materialtest.FieldSeqNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNumber(v)
		return nil
	case materialtest.FieldAddSeqNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddSeqNumber(v)
		return nil
	case materialtest.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case materialtest.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case materialtest.FieldCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case materialtest.FieldMaterialCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialCategory(v)
		return nil
	case materialtest.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case materialtest.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case materialtest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case materialtest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case materialtest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown MaterialTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MaterialTestMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, materialtest.FieldDate)
	}
	if m.add_type != nil {
		fields = append(fields, materialtest.FieldType)
	}
	if m.addcategory != nil {
		fields = append(fields, materialtest.FieldCategory)
	}
	if m.addmaterialCategory != nil {
		fields = append(fields, materialtest.FieldMaterialCategory)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, materialtest.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, materialtest.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, materialtest.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MaterialTestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case materialtest.FieldDate:
		return m.AddedDate()
	case materialtest.FieldType:
		return m.AddedType()
	case materialtest.FieldCategory:
		return m.AddedCategory()
	case materialtest.FieldMaterialCategory:
		return m.AddedMaterialCategory()
	case materialtest.FieldCreatedAt:
		return m.AddedCreatedAt()
	case materialtest.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case materialtest.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case materialtest.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case materialtest.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case materialtest.FieldCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategory(v)
		return nil
	case materialtest.FieldMaterialCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialCategory(v)
		return nil
	case materialtest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case materialtest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case materialtest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown MaterialTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MaterialTestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MaterialTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaterialTestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MaterialTest nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MaterialTestMutation) ResetField(name string) error {
	switch name {
	case materialtest.FieldName:
		m.ResetName()
		return nil
	case materialtest.FieldCode:
		m.ResetCode()
		return nil
	case materialtest.FieldSeqNumber:
		m.ResetSeqNumber()
		return nil
	case materialtest.FieldAddSeqNumber:
		m.ResetAddSeqNumber()
		return nil
	case materialtest.FieldDate:
		m.ResetDate()
		return nil
	case materialtest.FieldType:
		m.ResetType()
		return nil
	case materialtest.FieldCategory:
		m.ResetCategory()
		return nil
	case materialtest.FieldMaterialCategory:
		m.ResetMaterialCategory()
		return nil
	case materialtest.FieldUserName:
		m.ResetUserName()
		return nil
	case materialtest.FieldRemarks:
		m.ResetRemarks()
		return nil
	case materialtest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case materialtest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case materialtest.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown MaterialTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MaterialTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MaterialTestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MaterialTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MaterialTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MaterialTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MaterialTestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MaterialTestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MaterialTest unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MaterialTestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MaterialTest edge %s", name)
}

// PositionMutation represents an operation that mutate the Positions
// nodes in the graph.
type PositionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Position, error)
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows to manage the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for $n.Name.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the id field of the mutation.
func withPositionID(id int64) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PositionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PositionMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, position.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Position edge %s", name)
}

// PregnancyTestMutation represents an operation that mutate the PregnancyTests
// nodes in the graph.
type PregnancyTestMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	name                     *string
	earNumber                *string
	times                    *int
	addtimes                 *int
	reproductiveState        *string
	shedName                 *string
	breedingAt               *int64
	addbreedingAt            *int64
	testAt                   *int64
	addtestAt                *int64
	pregnancyTestTypeId      *int
	addpregnancyTestTypeId   *int
	pregnancyTestTypeName    *string
	pregnancyTestMethodId    *int
	addpregnancyTestMethodId *int
	pregnancyTestMethodName  *string
	pregnancyTestResultId    *int
	addpregnancyTestResultId *int
	pregnancyTestResultName  *string
	userName                 *string
	remarks                  *string
	createdAt                *int64
	addcreatedAt             *int64
	updatedAt                *int64
	addupdatedAt             *int64
	deleted                  *int
	adddeleted               *int
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*PregnancyTest, error)
}

var _ ent.Mutation = (*PregnancyTestMutation)(nil)

// pregnancytestOption allows to manage the mutation configuration using functional options.
type pregnancytestOption func(*PregnancyTestMutation)

// newPregnancyTestMutation creates new mutation for $n.Name.
func newPregnancyTestMutation(c config, op Op, opts ...pregnancytestOption) *PregnancyTestMutation {
	m := &PregnancyTestMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestID sets the id field of the mutation.
func withPregnancyTestID(id int64) pregnancytestOption {
	return func(m *PregnancyTestMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTest
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTest, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTest sets the old PregnancyTest of the mutation.
func withPregnancyTest(node *PregnancyTest) pregnancytestOption {
	return func(m *PregnancyTestMutation) {
		m.oldValue = func(context.Context) (*PregnancyTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PregnancyTestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *PregnancyTestMutation) ClearName() {
	m.name = nil
	m.clearedFields[pregnancytest.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *PregnancyTestMutation) NameCleared() bool {
	_, ok := m.clearedFields[pregnancytest.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, pregnancytest.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *PregnancyTestMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *PregnancyTestMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *PregnancyTestMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *PregnancyTestMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *PregnancyTestMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *PregnancyTestMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *PregnancyTestMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *PregnancyTestMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetReproductiveState sets the reproductiveState field.
func (m *PregnancyTestMutation) SetReproductiveState(s string) {
	m.reproductiveState = &s
}

// ReproductiveState returns the reproductiveState value in the mutation.
func (m *PregnancyTestMutation) ReproductiveState() (r string, exists bool) {
	v := m.reproductiveState
	if v == nil {
		return
	}
	return *v, true
}

// OldReproductiveState returns the old reproductiveState value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldReproductiveState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReproductiveState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReproductiveState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReproductiveState: %w", err)
	}
	return oldValue.ReproductiveState, nil
}

// ResetReproductiveState reset all changes of the "reproductiveState" field.
func (m *PregnancyTestMutation) ResetReproductiveState() {
	m.reproductiveState = nil
}

// SetShedName sets the shedName field.
func (m *PregnancyTestMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *PregnancyTestMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *PregnancyTestMutation) ResetShedName() {
	m.shedName = nil
}

// SetBreedingAt sets the breedingAt field.
func (m *PregnancyTestMutation) SetBreedingAt(i int64) {
	m.breedingAt = &i
	m.addbreedingAt = nil
}

// BreedingAt returns the breedingAt value in the mutation.
func (m *PregnancyTestMutation) BreedingAt() (r int64, exists bool) {
	v := m.breedingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingAt returns the old breedingAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldBreedingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingAt: %w", err)
	}
	return oldValue.BreedingAt, nil
}

// AddBreedingAt adds i to breedingAt.
func (m *PregnancyTestMutation) AddBreedingAt(i int64) {
	if m.addbreedingAt != nil {
		*m.addbreedingAt += i
	} else {
		m.addbreedingAt = &i
	}
}

// AddedBreedingAt returns the value that was added to the breedingAt field in this mutation.
func (m *PregnancyTestMutation) AddedBreedingAt() (r int64, exists bool) {
	v := m.addbreedingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingAt reset all changes of the "breedingAt" field.
func (m *PregnancyTestMutation) ResetBreedingAt() {
	m.breedingAt = nil
	m.addbreedingAt = nil
}

// SetTestAt sets the testAt field.
func (m *PregnancyTestMutation) SetTestAt(i int64) {
	m.testAt = &i
	m.addtestAt = nil
}

// TestAt returns the testAt value in the mutation.
func (m *PregnancyTestMutation) TestAt() (r int64, exists bool) {
	v := m.testAt
	if v == nil {
		return
	}
	return *v, true
}

// OldTestAt returns the old testAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldTestAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTestAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTestAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestAt: %w", err)
	}
	return oldValue.TestAt, nil
}

// AddTestAt adds i to testAt.
func (m *PregnancyTestMutation) AddTestAt(i int64) {
	if m.addtestAt != nil {
		*m.addtestAt += i
	} else {
		m.addtestAt = &i
	}
}

// AddedTestAt returns the value that was added to the testAt field in this mutation.
func (m *PregnancyTestMutation) AddedTestAt() (r int64, exists bool) {
	v := m.addtestAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetTestAt reset all changes of the "testAt" field.
func (m *PregnancyTestMutation) ResetTestAt() {
	m.testAt = nil
	m.addtestAt = nil
}

// SetPregnancyTestTypeId sets the pregnancyTestTypeId field.
func (m *PregnancyTestMutation) SetPregnancyTestTypeId(i int) {
	m.pregnancyTestTypeId = &i
	m.addpregnancyTestTypeId = nil
}

// PregnancyTestTypeId returns the pregnancyTestTypeId value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestTypeId() (r int, exists bool) {
	v := m.pregnancyTestTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestTypeId returns the old pregnancyTestTypeId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestTypeId: %w", err)
	}
	return oldValue.PregnancyTestTypeId, nil
}

// AddPregnancyTestTypeId adds i to pregnancyTestTypeId.
func (m *PregnancyTestMutation) AddPregnancyTestTypeId(i int) {
	if m.addpregnancyTestTypeId != nil {
		*m.addpregnancyTestTypeId += i
	} else {
		m.addpregnancyTestTypeId = &i
	}
}

// AddedPregnancyTestTypeId returns the value that was added to the pregnancyTestTypeId field in this mutation.
func (m *PregnancyTestMutation) AddedPregnancyTestTypeId() (r int, exists bool) {
	v := m.addpregnancyTestTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyTestTypeId reset all changes of the "pregnancyTestTypeId" field.
func (m *PregnancyTestMutation) ResetPregnancyTestTypeId() {
	m.pregnancyTestTypeId = nil
	m.addpregnancyTestTypeId = nil
}

// SetPregnancyTestTypeName sets the pregnancyTestTypeName field.
func (m *PregnancyTestMutation) SetPregnancyTestTypeName(s string) {
	m.pregnancyTestTypeName = &s
}

// PregnancyTestTypeName returns the pregnancyTestTypeName value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestTypeName() (r string, exists bool) {
	v := m.pregnancyTestTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestTypeName returns the old pregnancyTestTypeName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestTypeName: %w", err)
	}
	return oldValue.PregnancyTestTypeName, nil
}

// ResetPregnancyTestTypeName reset all changes of the "pregnancyTestTypeName" field.
func (m *PregnancyTestMutation) ResetPregnancyTestTypeName() {
	m.pregnancyTestTypeName = nil
}

// SetPregnancyTestMethodId sets the pregnancyTestMethodId field.
func (m *PregnancyTestMutation) SetPregnancyTestMethodId(i int) {
	m.pregnancyTestMethodId = &i
	m.addpregnancyTestMethodId = nil
}

// PregnancyTestMethodId returns the pregnancyTestMethodId value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestMethodId() (r int, exists bool) {
	v := m.pregnancyTestMethodId
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestMethodId returns the old pregnancyTestMethodId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestMethodId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestMethodId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestMethodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestMethodId: %w", err)
	}
	return oldValue.PregnancyTestMethodId, nil
}

// AddPregnancyTestMethodId adds i to pregnancyTestMethodId.
func (m *PregnancyTestMutation) AddPregnancyTestMethodId(i int) {
	if m.addpregnancyTestMethodId != nil {
		*m.addpregnancyTestMethodId += i
	} else {
		m.addpregnancyTestMethodId = &i
	}
}

// AddedPregnancyTestMethodId returns the value that was added to the pregnancyTestMethodId field in this mutation.
func (m *PregnancyTestMutation) AddedPregnancyTestMethodId() (r int, exists bool) {
	v := m.addpregnancyTestMethodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyTestMethodId reset all changes of the "pregnancyTestMethodId" field.
func (m *PregnancyTestMutation) ResetPregnancyTestMethodId() {
	m.pregnancyTestMethodId = nil
	m.addpregnancyTestMethodId = nil
}

// SetPregnancyTestMethodName sets the pregnancyTestMethodName field.
func (m *PregnancyTestMutation) SetPregnancyTestMethodName(s string) {
	m.pregnancyTestMethodName = &s
}

// PregnancyTestMethodName returns the pregnancyTestMethodName value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestMethodName() (r string, exists bool) {
	v := m.pregnancyTestMethodName
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestMethodName returns the old pregnancyTestMethodName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestMethodName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestMethodName: %w", err)
	}
	return oldValue.PregnancyTestMethodName, nil
}

// ResetPregnancyTestMethodName reset all changes of the "pregnancyTestMethodName" field.
func (m *PregnancyTestMutation) ResetPregnancyTestMethodName() {
	m.pregnancyTestMethodName = nil
}

// SetPregnancyTestResultId sets the pregnancyTestResultId field.
func (m *PregnancyTestMutation) SetPregnancyTestResultId(i int) {
	m.pregnancyTestResultId = &i
	m.addpregnancyTestResultId = nil
}

// PregnancyTestResultId returns the pregnancyTestResultId value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestResultId() (r int, exists bool) {
	v := m.pregnancyTestResultId
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestResultId returns the old pregnancyTestResultId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestResultId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestResultId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestResultId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestResultId: %w", err)
	}
	return oldValue.PregnancyTestResultId, nil
}

// AddPregnancyTestResultId adds i to pregnancyTestResultId.
func (m *PregnancyTestMutation) AddPregnancyTestResultId(i int) {
	if m.addpregnancyTestResultId != nil {
		*m.addpregnancyTestResultId += i
	} else {
		m.addpregnancyTestResultId = &i
	}
}

// AddedPregnancyTestResultId returns the value that was added to the pregnancyTestResultId field in this mutation.
func (m *PregnancyTestMutation) AddedPregnancyTestResultId() (r int, exists bool) {
	v := m.addpregnancyTestResultId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyTestResultId reset all changes of the "pregnancyTestResultId" field.
func (m *PregnancyTestMutation) ResetPregnancyTestResultId() {
	m.pregnancyTestResultId = nil
	m.addpregnancyTestResultId = nil
}

// SetPregnancyTestResultName sets the pregnancyTestResultName field.
func (m *PregnancyTestMutation) SetPregnancyTestResultName(s string) {
	m.pregnancyTestResultName = &s
}

// PregnancyTestResultName returns the pregnancyTestResultName value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestResultName() (r string, exists bool) {
	v := m.pregnancyTestResultName
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestResultName returns the old pregnancyTestResultName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestResultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestResultName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestResultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestResultName: %w", err)
	}
	return oldValue.PregnancyTestResultName, nil
}

// ResetPregnancyTestResultName reset all changes of the "pregnancyTestResultName" field.
func (m *PregnancyTestMutation) ResetPregnancyTestResultName() {
	m.pregnancyTestResultName = nil
}

// SetUserName sets the userName field.
func (m *PregnancyTestMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *PregnancyTestMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *PregnancyTestMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *PregnancyTestMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *PregnancyTestMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *PregnancyTestMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *PregnancyTestMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *PregnancyTestMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *PregnancyTestMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *PregnancyTestMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *PregnancyTestMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *PregnancyTestMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *PregnancyTestMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *PregnancyTestMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *PregnancyTestMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *PregnancyTestMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *PregnancyTestMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *PregnancyTestMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *PregnancyTestMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *PregnancyTestMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *PregnancyTestMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *PregnancyTestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTest).
func (m *PregnancyTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, pregnancytest.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, pregnancytest.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, pregnancytest.FieldTimes)
	}
	if m.reproductiveState != nil {
		fields = append(fields, pregnancytest.FieldReproductiveState)
	}
	if m.shedName != nil {
		fields = append(fields, pregnancytest.FieldShedName)
	}
	if m.breedingAt != nil {
		fields = append(fields, pregnancytest.FieldBreedingAt)
	}
	if m.testAt != nil {
		fields = append(fields, pregnancytest.FieldTestAt)
	}
	if m.pregnancyTestTypeId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestTypeId)
	}
	if m.pregnancyTestTypeName != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestTypeName)
	}
	if m.pregnancyTestMethodId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestMethodId)
	}
	if m.pregnancyTestMethodName != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestMethodName)
	}
	if m.pregnancyTestResultId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestResultId)
	}
	if m.pregnancyTestResultName != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestResultName)
	}
	if m.userName != nil {
		fields = append(fields, pregnancytest.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, pregnancytest.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, pregnancytest.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, pregnancytest.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, pregnancytest.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytest.FieldName:
		return m.Name()
	case pregnancytest.FieldEarNumber:
		return m.EarNumber()
	case pregnancytest.FieldTimes:
		return m.Times()
	case pregnancytest.FieldReproductiveState:
		return m.ReproductiveState()
	case pregnancytest.FieldShedName:
		return m.ShedName()
	case pregnancytest.FieldBreedingAt:
		return m.BreedingAt()
	case pregnancytest.FieldTestAt:
		return m.TestAt()
	case pregnancytest.FieldPregnancyTestTypeId:
		return m.PregnancyTestTypeId()
	case pregnancytest.FieldPregnancyTestTypeName:
		return m.PregnancyTestTypeName()
	case pregnancytest.FieldPregnancyTestMethodId:
		return m.PregnancyTestMethodId()
	case pregnancytest.FieldPregnancyTestMethodName:
		return m.PregnancyTestMethodName()
	case pregnancytest.FieldPregnancyTestResultId:
		return m.PregnancyTestResultId()
	case pregnancytest.FieldPregnancyTestResultName:
		return m.PregnancyTestResultName()
	case pregnancytest.FieldUserName:
		return m.UserName()
	case pregnancytest.FieldRemarks:
		return m.Remarks()
	case pregnancytest.FieldCreatedAt:
		return m.CreatedAt()
	case pregnancytest.FieldUpdatedAt:
		return m.UpdatedAt()
	case pregnancytest.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytest.FieldName:
		return m.OldName(ctx)
	case pregnancytest.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case pregnancytest.FieldTimes:
		return m.OldTimes(ctx)
	case pregnancytest.FieldReproductiveState:
		return m.OldReproductiveState(ctx)
	case pregnancytest.FieldShedName:
		return m.OldShedName(ctx)
	case pregnancytest.FieldBreedingAt:
		return m.OldBreedingAt(ctx)
	case pregnancytest.FieldTestAt:
		return m.OldTestAt(ctx)
	case pregnancytest.FieldPregnancyTestTypeId:
		return m.OldPregnancyTestTypeId(ctx)
	case pregnancytest.FieldPregnancyTestTypeName:
		return m.OldPregnancyTestTypeName(ctx)
	case pregnancytest.FieldPregnancyTestMethodId:
		return m.OldPregnancyTestMethodId(ctx)
	case pregnancytest.FieldPregnancyTestMethodName:
		return m.OldPregnancyTestMethodName(ctx)
	case pregnancytest.FieldPregnancyTestResultId:
		return m.OldPregnancyTestResultId(ctx)
	case pregnancytest.FieldPregnancyTestResultName:
		return m.OldPregnancyTestResultName(ctx)
	case pregnancytest.FieldUserName:
		return m.OldUserName(ctx)
	case pregnancytest.FieldRemarks:
		return m.OldRemarks(ctx)
	case pregnancytest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pregnancytest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pregnancytest.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTest field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pregnancytest.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case pregnancytest.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case pregnancytest.FieldReproductiveState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReproductiveState(v)
		return nil
	case pregnancytest.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case pregnancytest.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingAt(v)
		return nil
	case pregnancytest.FieldTestAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestAt(v)
		return nil
	case pregnancytest.FieldPregnancyTestTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestTypeId(v)
		return nil
	case pregnancytest.FieldPregnancyTestTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestTypeName(v)
		return nil
	case pregnancytest.FieldPregnancyTestMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestMethodId(v)
		return nil
	case pregnancytest.FieldPregnancyTestMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestMethodName(v)
		return nil
	case pregnancytest.FieldPregnancyTestResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestResultId(v)
		return nil
	case pregnancytest.FieldPregnancyTestResultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestResultName(v)
		return nil
	case pregnancytest.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case pregnancytest.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case pregnancytest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pregnancytest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pregnancytest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestMutation) AddedFields() []string {
	var fields []string
	if m.addtimes != nil {
		fields = append(fields, pregnancytest.FieldTimes)
	}
	if m.addbreedingAt != nil {
		fields = append(fields, pregnancytest.FieldBreedingAt)
	}
	if m.addtestAt != nil {
		fields = append(fields, pregnancytest.FieldTestAt)
	}
	if m.addpregnancyTestTypeId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestTypeId)
	}
	if m.addpregnancyTestMethodId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestMethodId)
	}
	if m.addpregnancyTestResultId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestResultId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, pregnancytest.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, pregnancytest.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, pregnancytest.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pregnancytest.FieldTimes:
		return m.AddedTimes()
	case pregnancytest.FieldBreedingAt:
		return m.AddedBreedingAt()
	case pregnancytest.FieldTestAt:
		return m.AddedTestAt()
	case pregnancytest.FieldPregnancyTestTypeId:
		return m.AddedPregnancyTestTypeId()
	case pregnancytest.FieldPregnancyTestMethodId:
		return m.AddedPregnancyTestMethodId()
	case pregnancytest.FieldPregnancyTestResultId:
		return m.AddedPregnancyTestResultId()
	case pregnancytest.FieldCreatedAt:
		return m.AddedCreatedAt()
	case pregnancytest.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case pregnancytest.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pregnancytest.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case pregnancytest.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingAt(v)
		return nil
	case pregnancytest.FieldTestAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTestAt(v)
		return nil
	case pregnancytest.FieldPregnancyTestTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyTestTypeId(v)
		return nil
	case pregnancytest.FieldPregnancyTestMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyTestMethodId(v)
		return nil
	case pregnancytest.FieldPregnancyTestResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyTestResultId(v)
		return nil
	case pregnancytest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case pregnancytest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case pregnancytest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pregnancytest.FieldName) {
		fields = append(fields, pregnancytest.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestMutation) ClearField(name string) error {
	switch name {
	case pregnancytest.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestMutation) ResetField(name string) error {
	switch name {
	case pregnancytest.FieldName:
		m.ResetName()
		return nil
	case pregnancytest.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case pregnancytest.FieldTimes:
		m.ResetTimes()
		return nil
	case pregnancytest.FieldReproductiveState:
		m.ResetReproductiveState()
		return nil
	case pregnancytest.FieldShedName:
		m.ResetShedName()
		return nil
	case pregnancytest.FieldBreedingAt:
		m.ResetBreedingAt()
		return nil
	case pregnancytest.FieldTestAt:
		m.ResetTestAt()
		return nil
	case pregnancytest.FieldPregnancyTestTypeId:
		m.ResetPregnancyTestTypeId()
		return nil
	case pregnancytest.FieldPregnancyTestTypeName:
		m.ResetPregnancyTestTypeName()
		return nil
	case pregnancytest.FieldPregnancyTestMethodId:
		m.ResetPregnancyTestMethodId()
		return nil
	case pregnancytest.FieldPregnancyTestMethodName:
		m.ResetPregnancyTestMethodName()
		return nil
	case pregnancytest.FieldPregnancyTestResultId:
		m.ResetPregnancyTestResultId()
		return nil
	case pregnancytest.FieldPregnancyTestResultName:
		m.ResetPregnancyTestResultName()
		return nil
	case pregnancytest.FieldUserName:
		m.ResetUserName()
		return nil
	case pregnancytest.FieldRemarks:
		m.ResetRemarks()
		return nil
	case pregnancytest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pregnancytest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pregnancytest.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTest unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTest edge %s", name)
}

// PregnancyTestMethodMutation represents an operation that mutate the PregnancyTestMethods
// nodes in the graph.
type PregnancyTestMethodMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PregnancyTestMethod, error)
}

var _ ent.Mutation = (*PregnancyTestMethodMutation)(nil)

// pregnancytestmethodOption allows to manage the mutation configuration using functional options.
type pregnancytestmethodOption func(*PregnancyTestMethodMutation)

// newPregnancyTestMethodMutation creates new mutation for $n.Name.
func newPregnancyTestMethodMutation(c config, op Op, opts ...pregnancytestmethodOption) *PregnancyTestMethodMutation {
	m := &PregnancyTestMethodMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTestMethod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestMethodID sets the id field of the mutation.
func withPregnancyTestMethodID(id int64) pregnancytestmethodOption {
	return func(m *PregnancyTestMethodMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTestMethod
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTestMethod, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTestMethod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTestMethod sets the old PregnancyTestMethod of the mutation.
func withPregnancyTestMethod(node *PregnancyTestMethod) pregnancytestmethodOption {
	return func(m *PregnancyTestMethodMutation) {
		m.oldValue = func(context.Context) (*PregnancyTestMethod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestMethodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestMethodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestMethodMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PregnancyTestMethodMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestMethodMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTestMethod.
// If the PregnancyTestMethod object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMethodMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestMethodMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *PregnancyTestMethodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTestMethod).
func (m *PregnancyTestMethodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestMethodMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, pregnancytestmethod.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestMethodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytestmethod.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestMethodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytestmethod.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTestMethod field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMethodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytestmethod.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestMethod field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestMethodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestMethodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMethodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PregnancyTestMethod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestMethodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestMethodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestMethodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PregnancyTestMethod nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestMethodMutation) ResetField(name string) error {
	switch name {
	case pregnancytestmethod.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestMethod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestMethodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestMethodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestMethodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestMethodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestMethodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestMethodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestMethodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestMethod unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestMethodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestMethod edge %s", name)
}

// PregnancyTestResultMutation represents an operation that mutate the PregnancyTestResults
// nodes in the graph.
type PregnancyTestResultMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PregnancyTestResult, error)
}

var _ ent.Mutation = (*PregnancyTestResultMutation)(nil)

// pregnancytestresultOption allows to manage the mutation configuration using functional options.
type pregnancytestresultOption func(*PregnancyTestResultMutation)

// newPregnancyTestResultMutation creates new mutation for $n.Name.
func newPregnancyTestResultMutation(c config, op Op, opts ...pregnancytestresultOption) *PregnancyTestResultMutation {
	m := &PregnancyTestResultMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTestResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestResultID sets the id field of the mutation.
func withPregnancyTestResultID(id int64) pregnancytestresultOption {
	return func(m *PregnancyTestResultMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTestResult
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTestResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTestResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTestResult sets the old PregnancyTestResult of the mutation.
func withPregnancyTestResult(node *PregnancyTestResult) pregnancytestresultOption {
	return func(m *PregnancyTestResultMutation) {
		m.oldValue = func(context.Context) (*PregnancyTestResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestResultMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PregnancyTestResultMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestResultMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTestResult.
// If the PregnancyTestResult object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestResultMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestResultMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *PregnancyTestResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTestResult).
func (m *PregnancyTestResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestResultMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, pregnancytestresult.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytestresult.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytestresult.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTestResult field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytestresult.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PregnancyTestResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PregnancyTestResult nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestResultMutation) ResetField(name string) error {
	switch name {
	case pregnancytestresult.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestResult unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestResult edge %s", name)
}

// PregnancyTestTypeMutation represents an operation that mutate the PregnancyTestTypes
// nodes in the graph.
type PregnancyTestTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PregnancyTestType, error)
}

var _ ent.Mutation = (*PregnancyTestTypeMutation)(nil)

// pregnancytesttypeOption allows to manage the mutation configuration using functional options.
type pregnancytesttypeOption func(*PregnancyTestTypeMutation)

// newPregnancyTestTypeMutation creates new mutation for $n.Name.
func newPregnancyTestTypeMutation(c config, op Op, opts ...pregnancytesttypeOption) *PregnancyTestTypeMutation {
	m := &PregnancyTestTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTestType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestTypeID sets the id field of the mutation.
func withPregnancyTestTypeID(id int64) pregnancytesttypeOption {
	return func(m *PregnancyTestTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTestType
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTestType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTestType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTestType sets the old PregnancyTestType of the mutation.
func withPregnancyTestType(node *PregnancyTestType) pregnancytesttypeOption {
	return func(m *PregnancyTestTypeMutation) {
		m.oldValue = func(context.Context) (*PregnancyTestType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PregnancyTestTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTestType.
// If the PregnancyTestType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *PregnancyTestTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTestType).
func (m *PregnancyTestTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, pregnancytesttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytesttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytesttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTestType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytesttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PregnancyTestType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PregnancyTestType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestTypeMutation) ResetField(name string) error {
	switch name {
	case pregnancytesttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestType edge %s", name)
}

// ReproductiveStateMutation represents an operation that mutate the ReproductiveStates
// nodes in the graph.
type ReproductiveStateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ReproductiveState, error)
}

var _ ent.Mutation = (*ReproductiveStateMutation)(nil)

// reproductivestateOption allows to manage the mutation configuration using functional options.
type reproductivestateOption func(*ReproductiveStateMutation)

// newReproductiveStateMutation creates new mutation for $n.Name.
func newReproductiveStateMutation(c config, op Op, opts ...reproductivestateOption) *ReproductiveStateMutation {
	m := &ReproductiveStateMutation{
		config:        c,
		op:            op,
		typ:           TypeReproductiveState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReproductiveStateID sets the id field of the mutation.
func withReproductiveStateID(id int64) reproductivestateOption {
	return func(m *ReproductiveStateMutation) {
		var (
			err   error
			once  sync.Once
			value *ReproductiveState
		)
		m.oldValue = func(ctx context.Context) (*ReproductiveState, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReproductiveState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReproductiveState sets the old ReproductiveState of the mutation.
func withReproductiveState(node *ReproductiveState) reproductivestateOption {
	return func(m *ReproductiveStateMutation) {
		m.oldValue = func(context.Context) (*ReproductiveState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReproductiveStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReproductiveStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReproductiveStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ReproductiveStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ReproductiveStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ReproductiveState.
// If the ReproductiveState object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductiveStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ReproductiveStateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *ReproductiveStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReproductiveState).
func (m *ReproductiveStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReproductiveStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, reproductivestate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReproductiveStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reproductivestate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReproductiveStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reproductivestate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ReproductiveState field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReproductiveStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reproductivestate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ReproductiveState field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReproductiveStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReproductiveStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReproductiveStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReproductiveState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReproductiveStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReproductiveStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReproductiveStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReproductiveState nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReproductiveStateMutation) ResetField(name string) error {
	switch name {
	case reproductivestate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ReproductiveState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReproductiveStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReproductiveStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReproductiveStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReproductiveStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReproductiveStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReproductiveStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReproductiveStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReproductiveState unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReproductiveStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReproductiveState edge %s", name)
}

// SemenFrozenTypeMutation represents an operation that mutate the SemenFrozenTypes
// nodes in the graph.
type SemenFrozenTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SemenFrozenType, error)
}

var _ ent.Mutation = (*SemenFrozenTypeMutation)(nil)

// semenfrozentypeOption allows to manage the mutation configuration using functional options.
type semenfrozentypeOption func(*SemenFrozenTypeMutation)

// newSemenFrozenTypeMutation creates new mutation for $n.Name.
func newSemenFrozenTypeMutation(c config, op Op, opts ...semenfrozentypeOption) *SemenFrozenTypeMutation {
	m := &SemenFrozenTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSemenFrozenType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSemenFrozenTypeID sets the id field of the mutation.
func withSemenFrozenTypeID(id int64) semenfrozentypeOption {
	return func(m *SemenFrozenTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SemenFrozenType
		)
		m.oldValue = func(ctx context.Context) (*SemenFrozenType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SemenFrozenType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSemenFrozenType sets the old SemenFrozenType of the mutation.
func withSemenFrozenType(node *SemenFrozenType) semenfrozentypeOption {
	return func(m *SemenFrozenTypeMutation) {
		m.oldValue = func(context.Context) (*SemenFrozenType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SemenFrozenTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SemenFrozenTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SemenFrozenTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *SemenFrozenTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *SemenFrozenTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the SemenFrozenType.
// If the SemenFrozenType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SemenFrozenTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *SemenFrozenTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *SemenFrozenTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SemenFrozenType).
func (m *SemenFrozenTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SemenFrozenTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, semenfrozentype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SemenFrozenTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case semenfrozentype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SemenFrozenTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case semenfrozentype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown SemenFrozenType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SemenFrozenTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case semenfrozentype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown SemenFrozenType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SemenFrozenTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SemenFrozenTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SemenFrozenTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SemenFrozenType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SemenFrozenTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SemenFrozenTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SemenFrozenTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SemenFrozenType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SemenFrozenTypeMutation) ResetField(name string) error {
	switch name {
	case semenfrozentype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown SemenFrozenType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SemenFrozenTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SemenFrozenTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SemenFrozenTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SemenFrozenTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SemenFrozenTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SemenFrozenTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SemenFrozenTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SemenFrozenType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SemenFrozenTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SemenFrozenType edge %s", name)
}

// ShedMutation represents an operation that mutate the Sheds
// nodes in the graph.
type ShedMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	name          *string
	shedCateId    *int64
	addshedCateId *int64
	shedCateName  *string
	shedTypeId    *int
	addshedTypeId *int
	shedTypeName  *string
	square        *int64
	addsquare     *int64
	length        *int64
	addlength     *int64
	width         *int64
	addwidth      *int64
	height        *int64
	addheight     *int64
	remarks       *string
	userId        *int
	adduserId     *int
	userName      *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Shed, error)
}

var _ ent.Mutation = (*ShedMutation)(nil)

// shedOption allows to manage the mutation configuration using functional options.
type shedOption func(*ShedMutation)

// newShedMutation creates new mutation for $n.Name.
func newShedMutation(c config, op Op, opts ...shedOption) *ShedMutation {
	m := &ShedMutation{
		config:        c,
		op:            op,
		typ:           TypeShed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedID sets the id field of the mutation.
func withShedID(id int64) shedOption {
	return func(m *ShedMutation) {
		var (
			err   error
			once  sync.Once
			value *Shed
		)
		m.oldValue = func(ctx context.Context) (*Shed, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShed sets the old Shed of the mutation.
func withShed(node *Shed) shedOption {
	return func(m *ShedMutation) {
		m.oldValue = func(context.Context) (*Shed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFarmId sets the farmId field.
func (m *ShedMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *ShedMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *ShedMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *ShedMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *ShedMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *ShedMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *ShedMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *ShedMutation) ResetFarmName() {
	m.farmName = nil
}

// SetName sets the name field.
func (m *ShedMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ShedMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ShedMutation) ResetName() {
	m.name = nil
}

// SetShedCateId sets the shedCateId field.
func (m *ShedMutation) SetShedCateId(i int64) {
	m.shedCateId = &i
	m.addshedCateId = nil
}

// ShedCateId returns the shedCateId value in the mutation.
func (m *ShedMutation) ShedCateId() (r int64, exists bool) {
	v := m.shedCateId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedCateId returns the old shedCateId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedCateId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedCateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedCateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedCateId: %w", err)
	}
	return oldValue.ShedCateId, nil
}

// AddShedCateId adds i to shedCateId.
func (m *ShedMutation) AddShedCateId(i int64) {
	if m.addshedCateId != nil {
		*m.addshedCateId += i
	} else {
		m.addshedCateId = &i
	}
}

// AddedShedCateId returns the value that was added to the shedCateId field in this mutation.
func (m *ShedMutation) AddedShedCateId() (r int64, exists bool) {
	v := m.addshedCateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedCateId reset all changes of the "shedCateId" field.
func (m *ShedMutation) ResetShedCateId() {
	m.shedCateId = nil
	m.addshedCateId = nil
}

// SetShedCateName sets the shedCateName field.
func (m *ShedMutation) SetShedCateName(s string) {
	m.shedCateName = &s
}

// ShedCateName returns the shedCateName value in the mutation.
func (m *ShedMutation) ShedCateName() (r string, exists bool) {
	v := m.shedCateName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedCateName returns the old shedCateName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedCateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedCateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedCateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedCateName: %w", err)
	}
	return oldValue.ShedCateName, nil
}

// ResetShedCateName reset all changes of the "shedCateName" field.
func (m *ShedMutation) ResetShedCateName() {
	m.shedCateName = nil
}

// SetShedTypeId sets the shedTypeId field.
func (m *ShedMutation) SetShedTypeId(i int) {
	m.shedTypeId = &i
	m.addshedTypeId = nil
}

// ShedTypeId returns the shedTypeId value in the mutation.
func (m *ShedMutation) ShedTypeId() (r int, exists bool) {
	v := m.shedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeId returns the old shedTypeId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeId: %w", err)
	}
	return oldValue.ShedTypeId, nil
}

// AddShedTypeId adds i to shedTypeId.
func (m *ShedMutation) AddShedTypeId(i int) {
	if m.addshedTypeId != nil {
		*m.addshedTypeId += i
	} else {
		m.addshedTypeId = &i
	}
}

// AddedShedTypeId returns the value that was added to the shedTypeId field in this mutation.
func (m *ShedMutation) AddedShedTypeId() (r int, exists bool) {
	v := m.addshedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedTypeId reset all changes of the "shedTypeId" field.
func (m *ShedMutation) ResetShedTypeId() {
	m.shedTypeId = nil
	m.addshedTypeId = nil
}

// SetShedTypeName sets the shedTypeName field.
func (m *ShedMutation) SetShedTypeName(s string) {
	m.shedTypeName = &s
}

// ShedTypeName returns the shedTypeName value in the mutation.
func (m *ShedMutation) ShedTypeName() (r string, exists bool) {
	v := m.shedTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeName returns the old shedTypeName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeName: %w", err)
	}
	return oldValue.ShedTypeName, nil
}

// ResetShedTypeName reset all changes of the "shedTypeName" field.
func (m *ShedMutation) ResetShedTypeName() {
	m.shedTypeName = nil
}

// SetSquare sets the square field.
func (m *ShedMutation) SetSquare(i int64) {
	m.square = &i
	m.addsquare = nil
}

// Square returns the square value in the mutation.
func (m *ShedMutation) Square() (r int64, exists bool) {
	v := m.square
	if v == nil {
		return
	}
	return *v, true
}

// OldSquare returns the old square value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldSquare(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSquare is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSquare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSquare: %w", err)
	}
	return oldValue.Square, nil
}

// AddSquare adds i to square.
func (m *ShedMutation) AddSquare(i int64) {
	if m.addsquare != nil {
		*m.addsquare += i
	} else {
		m.addsquare = &i
	}
}

// AddedSquare returns the value that was added to the square field in this mutation.
func (m *ShedMutation) AddedSquare() (r int64, exists bool) {
	v := m.addsquare
	if v == nil {
		return
	}
	return *v, true
}

// ResetSquare reset all changes of the "square" field.
func (m *ShedMutation) ResetSquare() {
	m.square = nil
	m.addsquare = nil
}

// SetLength sets the length field.
func (m *ShedMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the length value in the mutation.
func (m *ShedMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old length value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLength is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to length.
func (m *ShedMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the length field in this mutation.
func (m *ShedMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength reset all changes of the "length" field.
func (m *ShedMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the width field.
func (m *ShedMutation) SetWidth(i int64) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the width value in the mutation.
func (m *ShedMutation) Width() (r int64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old width value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldWidth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWidth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to width.
func (m *ShedMutation) AddWidth(i int64) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the width field in this mutation.
func (m *ShedMutation) AddedWidth() (r int64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth reset all changes of the "width" field.
func (m *ShedMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the height field.
func (m *ShedMutation) SetHeight(i int64) {
	m.height = &i
	m.addheight = nil
}

// Height returns the height value in the mutation.
func (m *ShedMutation) Height() (r int64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old height value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to height.
func (m *ShedMutation) AddHeight(i int64) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the height field in this mutation.
func (m *ShedMutation) AddedHeight() (r int64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight reset all changes of the "height" field.
func (m *ShedMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetRemarks sets the remarks field.
func (m *ShedMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ShedMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ShedMutation) ResetRemarks() {
	m.remarks = nil
}

// SetUserId sets the userId field.
func (m *ShedMutation) SetUserId(i int) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the userId value in the mutation.
func (m *ShedMutation) UserId() (r int, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old userId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to userId.
func (m *ShedMutation) AddUserId(i int) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the userId field in this mutation.
func (m *ShedMutation) AddedUserId() (r int, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId reset all changes of the "userId" field.
func (m *ShedMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetUserName sets the userName field.
func (m *ShedMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *ShedMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *ShedMutation) ResetUserName() {
	m.userName = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ShedMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ShedMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ShedMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ShedMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ShedMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ShedMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ShedMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ShedMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ShedMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ShedMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ShedMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ShedMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ShedMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ShedMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ShedMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ShedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Shed).
func (m *ShedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.farmId != nil {
		fields = append(fields, shed.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, shed.FieldFarmName)
	}
	if m.name != nil {
		fields = append(fields, shed.FieldName)
	}
	if m.shedCateId != nil {
		fields = append(fields, shed.FieldShedCateId)
	}
	if m.shedCateName != nil {
		fields = append(fields, shed.FieldShedCateName)
	}
	if m.shedTypeId != nil {
		fields = append(fields, shed.FieldShedTypeId)
	}
	if m.shedTypeName != nil {
		fields = append(fields, shed.FieldShedTypeName)
	}
	if m.square != nil {
		fields = append(fields, shed.FieldSquare)
	}
	if m.length != nil {
		fields = append(fields, shed.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, shed.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, shed.FieldHeight)
	}
	if m.remarks != nil {
		fields = append(fields, shed.FieldRemarks)
	}
	if m.userId != nil {
		fields = append(fields, shed.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, shed.FieldUserName)
	}
	if m.createdAt != nil {
		fields = append(fields, shed.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, shed.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, shed.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shed.FieldFarmId:
		return m.FarmId()
	case shed.FieldFarmName:
		return m.FarmName()
	case shed.FieldName:
		return m.Name()
	case shed.FieldShedCateId:
		return m.ShedCateId()
	case shed.FieldShedCateName:
		return m.ShedCateName()
	case shed.FieldShedTypeId:
		return m.ShedTypeId()
	case shed.FieldShedTypeName:
		return m.ShedTypeName()
	case shed.FieldSquare:
		return m.Square()
	case shed.FieldLength:
		return m.Length()
	case shed.FieldWidth:
		return m.Width()
	case shed.FieldHeight:
		return m.Height()
	case shed.FieldRemarks:
		return m.Remarks()
	case shed.FieldUserId:
		return m.UserId()
	case shed.FieldUserName:
		return m.UserName()
	case shed.FieldCreatedAt:
		return m.CreatedAt()
	case shed.FieldUpdatedAt:
		return m.UpdatedAt()
	case shed.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shed.FieldFarmId:
		return m.OldFarmId(ctx)
	case shed.FieldFarmName:
		return m.OldFarmName(ctx)
	case shed.FieldName:
		return m.OldName(ctx)
	case shed.FieldShedCateId:
		return m.OldShedCateId(ctx)
	case shed.FieldShedCateName:
		return m.OldShedCateName(ctx)
	case shed.FieldShedTypeId:
		return m.OldShedTypeId(ctx)
	case shed.FieldShedTypeName:
		return m.OldShedTypeName(ctx)
	case shed.FieldSquare:
		return m.OldSquare(ctx)
	case shed.FieldLength:
		return m.OldLength(ctx)
	case shed.FieldWidth:
		return m.OldWidth(ctx)
	case shed.FieldHeight:
		return m.OldHeight(ctx)
	case shed.FieldRemarks:
		return m.OldRemarks(ctx)
	case shed.FieldUserId:
		return m.OldUserId(ctx)
	case shed.FieldUserName:
		return m.OldUserName(ctx)
	case shed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shed.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Shed field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shed.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case shed.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case shed.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shed.FieldShedCateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedCateId(v)
		return nil
	case shed.FieldShedCateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedCateName(v)
		return nil
	case shed.FieldShedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeId(v)
		return nil
	case shed.FieldShedTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeName(v)
		return nil
	case shed.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSquare(v)
		return nil
	case shed.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case shed.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case shed.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case shed.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case shed.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case shed.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case shed.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shed.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shed.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Shed field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedMutation) AddedFields() []string {
	var fields []string
	if m.addfarmId != nil {
		fields = append(fields, shed.FieldFarmId)
	}
	if m.addshedCateId != nil {
		fields = append(fields, shed.FieldShedCateId)
	}
	if m.addshedTypeId != nil {
		fields = append(fields, shed.FieldShedTypeId)
	}
	if m.addsquare != nil {
		fields = append(fields, shed.FieldSquare)
	}
	if m.addlength != nil {
		fields = append(fields, shed.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, shed.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, shed.FieldHeight)
	}
	if m.adduserId != nil {
		fields = append(fields, shed.FieldUserId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, shed.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, shed.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, shed.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shed.FieldFarmId:
		return m.AddedFarmId()
	case shed.FieldShedCateId:
		return m.AddedShedCateId()
	case shed.FieldShedTypeId:
		return m.AddedShedTypeId()
	case shed.FieldSquare:
		return m.AddedSquare()
	case shed.FieldLength:
		return m.AddedLength()
	case shed.FieldWidth:
		return m.AddedWidth()
	case shed.FieldHeight:
		return m.AddedHeight()
	case shed.FieldUserId:
		return m.AddedUserId()
	case shed.FieldCreatedAt:
		return m.AddedCreatedAt()
	case shed.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case shed.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shed.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case shed.FieldShedCateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedCateId(v)
		return nil
	case shed.FieldShedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedTypeId(v)
		return nil
	case shed.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSquare(v)
		return nil
	case shed.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case shed.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case shed.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case shed.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case shed.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case shed.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case shed.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Shed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Shed nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedMutation) ResetField(name string) error {
	switch name {
	case shed.FieldFarmId:
		m.ResetFarmId()
		return nil
	case shed.FieldFarmName:
		m.ResetFarmName()
		return nil
	case shed.FieldName:
		m.ResetName()
		return nil
	case shed.FieldShedCateId:
		m.ResetShedCateId()
		return nil
	case shed.FieldShedCateName:
		m.ResetShedCateName()
		return nil
	case shed.FieldShedTypeId:
		m.ResetShedTypeId()
		return nil
	case shed.FieldShedTypeName:
		m.ResetShedTypeName()
		return nil
	case shed.FieldSquare:
		m.ResetSquare()
		return nil
	case shed.FieldLength:
		m.ResetLength()
		return nil
	case shed.FieldWidth:
		m.ResetWidth()
		return nil
	case shed.FieldHeight:
		m.ResetHeight()
		return nil
	case shed.FieldRemarks:
		m.ResetRemarks()
		return nil
	case shed.FieldUserId:
		m.ResetUserId()
		return nil
	case shed.FieldUserName:
		m.ResetUserName()
		return nil
	case shed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shed.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Shed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Shed unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Shed edge %s", name)
}

// ShedCategoryMutation represents an operation that mutate the ShedCategories
// nodes in the graph.
type ShedCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShedCategory, error)
}

var _ ent.Mutation = (*ShedCategoryMutation)(nil)

// shedcategoryOption allows to manage the mutation configuration using functional options.
type shedcategoryOption func(*ShedCategoryMutation)

// newShedCategoryMutation creates new mutation for $n.Name.
func newShedCategoryMutation(c config, op Op, opts ...shedcategoryOption) *ShedCategoryMutation {
	m := &ShedCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeShedCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedCategoryID sets the id field of the mutation.
func withShedCategoryID(id int64) shedcategoryOption {
	return func(m *ShedCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ShedCategory
		)
		m.oldValue = func(ctx context.Context) (*ShedCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShedCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShedCategory sets the old ShedCategory of the mutation.
func withShedCategory(node *ShedCategory) shedcategoryOption {
	return func(m *ShedCategoryMutation) {
		m.oldValue = func(context.Context) (*ShedCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedCategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ShedCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ShedCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ShedCategory.
// If the ShedCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ShedCategoryMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *ShedCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShedCategory).
func (m *ShedCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedCategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, shedcategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shedcategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shedcategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ShedCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shedcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ShedCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShedCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShedCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedCategoryMutation) ResetField(name string) error {
	switch name {
	case shedcategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ShedCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShedCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShedCategory edge %s", name)
}

// ShedTypeMutation represents an operation that mutate the ShedTypes
// nodes in the graph.
type ShedTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShedType, error)
}

var _ ent.Mutation = (*ShedTypeMutation)(nil)

// shedtypeOption allows to manage the mutation configuration using functional options.
type shedtypeOption func(*ShedTypeMutation)

// newShedTypeMutation creates new mutation for $n.Name.
func newShedTypeMutation(c config, op Op, opts ...shedtypeOption) *ShedTypeMutation {
	m := &ShedTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShedType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedTypeID sets the id field of the mutation.
func withShedTypeID(id int64) shedtypeOption {
	return func(m *ShedTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShedType
		)
		m.oldValue = func(ctx context.Context) (*ShedType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShedType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShedType sets the old ShedType of the mutation.
func withShedType(node *ShedType) shedtypeOption {
	return func(m *ShedTypeMutation) {
		m.oldValue = func(context.Context) (*ShedType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ShedTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ShedTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ShedTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *ShedTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShedType).
func (m *ShedTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, shedtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shedtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shedtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ShedType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shedtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ShedType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShedType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShedType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedTypeMutation) ResetField(name string) error {
	switch name {
	case shedtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ShedType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShedType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShedType edge %s", name)
}

// TreatmentResultMutation represents an operation that mutate the TreatmentResults
// nodes in the graph.
type TreatmentResultMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TreatmentResult, error)
}

var _ ent.Mutation = (*TreatmentResultMutation)(nil)

// treatmentresultOption allows to manage the mutation configuration using functional options.
type treatmentresultOption func(*TreatmentResultMutation)

// newTreatmentResultMutation creates new mutation for $n.Name.
func newTreatmentResultMutation(c config, op Op, opts ...treatmentresultOption) *TreatmentResultMutation {
	m := &TreatmentResultMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatmentResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentResultID sets the id field of the mutation.
func withTreatmentResultID(id int64) treatmentresultOption {
	return func(m *TreatmentResultMutation) {
		var (
			err   error
			once  sync.Once
			value *TreatmentResult
		)
		m.oldValue = func(ctx context.Context) (*TreatmentResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreatmentResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatmentResult sets the old TreatmentResult of the mutation.
func withTreatmentResult(node *TreatmentResult) treatmentresultOption {
	return func(m *TreatmentResultMutation) {
		m.oldValue = func(context.Context) (*TreatmentResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TreatmentResultMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *TreatmentResultMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TreatmentResultMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the TreatmentResult.
// If the TreatmentResult object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentResultMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TreatmentResultMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *TreatmentResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TreatmentResult).
func (m *TreatmentResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TreatmentResultMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, treatmentresult.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TreatmentResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatmentresult.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TreatmentResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatmentresult.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TreatmentResult field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatmentresult.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TreatmentResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TreatmentResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TreatmentResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TreatmentResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TreatmentResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TreatmentResult nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TreatmentResultMutation) ResetField(name string) error {
	switch name {
	case treatmentresult.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TreatmentResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TreatmentResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TreatmentResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TreatmentResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TreatmentResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TreatmentResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TreatmentResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TreatmentResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TreatmentResult unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TreatmentResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TreatmentResult edge %s", name)
}

// TreatmentStateMutation represents an operation that mutate the TreatmentStates
// nodes in the graph.
type TreatmentStateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TreatmentState, error)
}

var _ ent.Mutation = (*TreatmentStateMutation)(nil)

// treatmentstateOption allows to manage the mutation configuration using functional options.
type treatmentstateOption func(*TreatmentStateMutation)

// newTreatmentStateMutation creates new mutation for $n.Name.
func newTreatmentStateMutation(c config, op Op, opts ...treatmentstateOption) *TreatmentStateMutation {
	m := &TreatmentStateMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatmentState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentStateID sets the id field of the mutation.
func withTreatmentStateID(id int64) treatmentstateOption {
	return func(m *TreatmentStateMutation) {
		var (
			err   error
			once  sync.Once
			value *TreatmentState
		)
		m.oldValue = func(ctx context.Context) (*TreatmentState, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreatmentState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatmentState sets the old TreatmentState of the mutation.
func withTreatmentState(node *TreatmentState) treatmentstateOption {
	return func(m *TreatmentStateMutation) {
		m.oldValue = func(context.Context) (*TreatmentState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TreatmentStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *TreatmentStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TreatmentStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the TreatmentState.
// If the TreatmentState object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TreatmentStateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *TreatmentStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TreatmentState).
func (m *TreatmentStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TreatmentStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, treatmentstate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TreatmentStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatmentstate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TreatmentStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatmentstate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TreatmentState field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatmentstate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TreatmentState field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TreatmentStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TreatmentStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TreatmentStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TreatmentStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TreatmentState nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TreatmentStateMutation) ResetField(name string) error {
	switch name {
	case treatmentstate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TreatmentState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TreatmentStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TreatmentStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TreatmentStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TreatmentStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TreatmentStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TreatmentStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TreatmentStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TreatmentState unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TreatmentStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TreatmentState edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	positionId    *int64
	addpositionId *int64
	positionName  *string
	dutyName      *string
	name          *string
	gender        *int
	addgender     *int
	age           *int
	addage        *int
	education     *string
	major         *string
	jobTitle      *string
	phone         *string
	idCard        *string
	address       *string
	onJobState    *int
	addonJobState *int
	joinedAt      *int64
	addjoinedAt   *int64
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFarmId sets the farmId field.
func (m *UserMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *UserMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *UserMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *UserMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *UserMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *UserMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *UserMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *UserMutation) ResetFarmName() {
	m.farmName = nil
}

// SetPositionId sets the positionId field.
func (m *UserMutation) SetPositionId(i int64) {
	m.positionId = &i
	m.addpositionId = nil
}

// PositionId returns the positionId value in the mutation.
func (m *UserMutation) PositionId() (r int64, exists bool) {
	v := m.positionId
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionId returns the old positionId value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPositionId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionId: %w", err)
	}
	return oldValue.PositionId, nil
}

// AddPositionId adds i to positionId.
func (m *UserMutation) AddPositionId(i int64) {
	if m.addpositionId != nil {
		*m.addpositionId += i
	} else {
		m.addpositionId = &i
	}
}

// AddedPositionId returns the value that was added to the positionId field in this mutation.
func (m *UserMutation) AddedPositionId() (r int64, exists bool) {
	v := m.addpositionId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionId reset all changes of the "positionId" field.
func (m *UserMutation) ResetPositionId() {
	m.positionId = nil
	m.addpositionId = nil
}

// SetPositionName sets the positionName field.
func (m *UserMutation) SetPositionName(s string) {
	m.positionName = &s
}

// PositionName returns the positionName value in the mutation.
func (m *UserMutation) PositionName() (r string, exists bool) {
	v := m.positionName
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionName returns the old positionName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPositionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionName: %w", err)
	}
	return oldValue.PositionName, nil
}

// ResetPositionName reset all changes of the "positionName" field.
func (m *UserMutation) ResetPositionName() {
	m.positionName = nil
}

// SetDutyName sets the dutyName field.
func (m *UserMutation) SetDutyName(s string) {
	m.dutyName = &s
}

// DutyName returns the dutyName value in the mutation.
func (m *UserMutation) DutyName() (r string, exists bool) {
	v := m.dutyName
	if v == nil {
		return
	}
	return *v, true
}

// OldDutyName returns the old dutyName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDutyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDutyName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDutyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDutyName: %w", err)
	}
	return oldValue.DutyName, nil
}

// ResetDutyName reset all changes of the "dutyName" field.
func (m *UserMutation) ResetDutyName() {
	m.dutyName = nil
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetGender sets the gender field.
func (m *UserMutation) SetGender(i int) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the gender value in the mutation.
func (m *UserMutation) Gender() (r int, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to gender.
func (m *UserMutation) AddGender(i int) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the gender field in this mutation.
func (m *UserMutation) AddedGender() (r int, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender reset all changes of the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetAge sets the age field.
func (m *UserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the age value in the mutation.
func (m *UserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old age value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to age.
func (m *UserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the age field in this mutation.
func (m *UserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge reset all changes of the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetEducation sets the education field.
func (m *UserMutation) SetEducation(s string) {
	m.education = &s
}

// Education returns the education value in the mutation.
func (m *UserMutation) Education() (r string, exists bool) {
	v := m.education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old education value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEducation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ResetEducation reset all changes of the "education" field.
func (m *UserMutation) ResetEducation() {
	m.education = nil
}

// SetMajor sets the major field.
func (m *UserMutation) SetMajor(s string) {
	m.major = &s
}

// Major returns the major value in the mutation.
func (m *UserMutation) Major() (r string, exists bool) {
	v := m.major
	if v == nil {
		return
	}
	return *v, true
}

// OldMajor returns the old major value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldMajor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMajor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajor: %w", err)
	}
	return oldValue.Major, nil
}

// ResetMajor reset all changes of the "major" field.
func (m *UserMutation) ResetMajor() {
	m.major = nil
}

// SetJobTitle sets the jobTitle field.
func (m *UserMutation) SetJobTitle(s string) {
	m.jobTitle = &s
}

// JobTitle returns the jobTitle value in the mutation.
func (m *UserMutation) JobTitle() (r string, exists bool) {
	v := m.jobTitle
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTitle returns the old jobTitle value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldJobTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJobTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJobTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTitle: %w", err)
	}
	return oldValue.JobTitle, nil
}

// ResetJobTitle reset all changes of the "jobTitle" field.
func (m *UserMutation) ResetJobTitle() {
	m.jobTitle = nil
}

// SetPhone sets the phone field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetIdCard sets the idCard field.
func (m *UserMutation) SetIdCard(s string) {
	m.idCard = &s
}

// IdCard returns the idCard value in the mutation.
func (m *UserMutation) IdCard() (r string, exists bool) {
	v := m.idCard
	if v == nil {
		return
	}
	return *v, true
}

// OldIdCard returns the old idCard value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldIdCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIdCard is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIdCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdCard: %w", err)
	}
	return oldValue.IdCard, nil
}

// ResetIdCard reset all changes of the "idCard" field.
func (m *UserMutation) ResetIdCard() {
	m.idCard = nil
}

// SetAddress sets the address field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetOnJobState sets the onJobState field.
func (m *UserMutation) SetOnJobState(i int) {
	m.onJobState = &i
	m.addonJobState = nil
}

// OnJobState returns the onJobState value in the mutation.
func (m *UserMutation) OnJobState() (r int, exists bool) {
	v := m.onJobState
	if v == nil {
		return
	}
	return *v, true
}

// OldOnJobState returns the old onJobState value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldOnJobState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnJobState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnJobState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnJobState: %w", err)
	}
	return oldValue.OnJobState, nil
}

// AddOnJobState adds i to onJobState.
func (m *UserMutation) AddOnJobState(i int) {
	if m.addonJobState != nil {
		*m.addonJobState += i
	} else {
		m.addonJobState = &i
	}
}

// AddedOnJobState returns the value that was added to the onJobState field in this mutation.
func (m *UserMutation) AddedOnJobState() (r int, exists bool) {
	v := m.addonJobState
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnJobState reset all changes of the "onJobState" field.
func (m *UserMutation) ResetOnJobState() {
	m.onJobState = nil
	m.addonJobState = nil
}

// SetJoinedAt sets the joinedAt field.
func (m *UserMutation) SetJoinedAt(i int64) {
	m.joinedAt = &i
	m.addjoinedAt = nil
}

// JoinedAt returns the joinedAt value in the mutation.
func (m *UserMutation) JoinedAt() (r int64, exists bool) {
	v := m.joinedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old joinedAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldJoinedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// AddJoinedAt adds i to joinedAt.
func (m *UserMutation) AddJoinedAt(i int64) {
	if m.addjoinedAt != nil {
		*m.addjoinedAt += i
	} else {
		m.addjoinedAt = &i
	}
}

// AddedJoinedAt returns the value that was added to the joinedAt field in this mutation.
func (m *UserMutation) AddedJoinedAt() (r int64, exists bool) {
	v := m.addjoinedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetJoinedAt reset all changes of the "joinedAt" field.
func (m *UserMutation) ResetJoinedAt() {
	m.joinedAt = nil
	m.addjoinedAt = nil
}

// SetRemarks sets the remarks field.
func (m *UserMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *UserMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *UserMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *UserMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *UserMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *UserMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *UserMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *UserMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *UserMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *UserMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *UserMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *UserMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *UserMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *UserMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *UserMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *UserMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.farmId != nil {
		fields = append(fields, user.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, user.FieldFarmName)
	}
	if m.positionId != nil {
		fields = append(fields, user.FieldPositionId)
	}
	if m.positionName != nil {
		fields = append(fields, user.FieldPositionName)
	}
	if m.dutyName != nil {
		fields = append(fields, user.FieldDutyName)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.education != nil {
		fields = append(fields, user.FieldEducation)
	}
	if m.major != nil {
		fields = append(fields, user.FieldMajor)
	}
	if m.jobTitle != nil {
		fields = append(fields, user.FieldJobTitle)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.idCard != nil {
		fields = append(fields, user.FieldIdCard)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.onJobState != nil {
		fields = append(fields, user.FieldOnJobState)
	}
	if m.joinedAt != nil {
		fields = append(fields, user.FieldJoinedAt)
	}
	if m.remarks != nil {
		fields = append(fields, user.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, user.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFarmId:
		return m.FarmId()
	case user.FieldFarmName:
		return m.FarmName()
	case user.FieldPositionId:
		return m.PositionId()
	case user.FieldPositionName:
		return m.PositionName()
	case user.FieldDutyName:
		return m.DutyName()
	case user.FieldName:
		return m.Name()
	case user.FieldGender:
		return m.Gender()
	case user.FieldAge:
		return m.Age()
	case user.FieldEducation:
		return m.Education()
	case user.FieldMajor:
		return m.Major()
	case user.FieldJobTitle:
		return m.JobTitle()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldIdCard:
		return m.IdCard()
	case user.FieldAddress:
		return m.Address()
	case user.FieldOnJobState:
		return m.OnJobState()
	case user.FieldJoinedAt:
		return m.JoinedAt()
	case user.FieldRemarks:
		return m.Remarks()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFarmId:
		return m.OldFarmId(ctx)
	case user.FieldFarmName:
		return m.OldFarmName(ctx)
	case user.FieldPositionId:
		return m.OldPositionId(ctx)
	case user.FieldPositionName:
		return m.OldPositionName(ctx)
	case user.FieldDutyName:
		return m.OldDutyName(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldEducation:
		return m.OldEducation(ctx)
	case user.FieldMajor:
		return m.OldMajor(ctx)
	case user.FieldJobTitle:
		return m.OldJobTitle(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldIdCard:
		return m.OldIdCard(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldOnJobState:
		return m.OldOnJobState(ctx)
	case user.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case user.FieldRemarks:
		return m.OldRemarks(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case user.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case user.FieldPositionId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionId(v)
		return nil
	case user.FieldPositionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionName(v)
		return nil
	case user.FieldDutyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDutyName(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case user.FieldMajor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajor(v)
		return nil
	case user.FieldJobTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTitle(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldIdCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdCard(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldOnJobState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnJobState(v)
		return nil
	case user.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case user.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addfarmId != nil {
		fields = append(fields, user.FieldFarmId)
	}
	if m.addpositionId != nil {
		fields = append(fields, user.FieldPositionId)
	}
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.addonJobState != nil {
		fields = append(fields, user.FieldOnJobState)
	}
	if m.addjoinedAt != nil {
		fields = append(fields, user.FieldJoinedAt)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, user.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFarmId:
		return m.AddedFarmId()
	case user.FieldPositionId:
		return m.AddedPositionId()
	case user.FieldGender:
		return m.AddedGender()
	case user.FieldAge:
		return m.AddedAge()
	case user.FieldOnJobState:
		return m.AddedOnJobState()
	case user.FieldJoinedAt:
		return m.AddedJoinedAt()
	case user.FieldCreatedAt:
		return m.AddedCreatedAt()
	case user.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case user.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case user.FieldPositionId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionId(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case user.FieldOnJobState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnJobState(v)
		return nil
	case user.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case user.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFarmId:
		m.ResetFarmId()
		return nil
	case user.FieldFarmName:
		m.ResetFarmName()
		return nil
	case user.FieldPositionId:
		m.ResetPositionId()
		return nil
	case user.FieldPositionName:
		m.ResetPositionName()
		return nil
	case user.FieldDutyName:
		m.ResetDutyName()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldEducation:
		m.ResetEducation()
		return nil
	case user.FieldMajor:
		m.ResetMajor()
		return nil
	case user.FieldJobTitle:
		m.ResetJobTitle()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldIdCard:
		m.ResetIdCard()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldOnJobState:
		m.ResetOnJobState()
		return nil
	case user.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case user.FieldRemarks:
		m.ResetRemarks()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// WhereaboutsMutation represents an operation that mutate the WhereaboutsSlice
// nodes in the graph.
type WhereaboutsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Whereabouts, error)
}

var _ ent.Mutation = (*WhereaboutsMutation)(nil)

// whereaboutsOption allows to manage the mutation configuration using functional options.
type whereaboutsOption func(*WhereaboutsMutation)

// newWhereaboutsMutation creates new mutation for $n.Name.
func newWhereaboutsMutation(c config, op Op, opts ...whereaboutsOption) *WhereaboutsMutation {
	m := &WhereaboutsMutation{
		config:        c,
		op:            op,
		typ:           TypeWhereabouts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWhereaboutsID sets the id field of the mutation.
func withWhereaboutsID(id int64) whereaboutsOption {
	return func(m *WhereaboutsMutation) {
		var (
			err   error
			once  sync.Once
			value *Whereabouts
		)
		m.oldValue = func(ctx context.Context) (*Whereabouts, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Whereabouts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWhereabouts sets the old Whereabouts of the mutation.
func withWhereabouts(node *Whereabouts) whereaboutsOption {
	return func(m *WhereaboutsMutation) {
		m.oldValue = func(context.Context) (*Whereabouts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WhereaboutsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WhereaboutsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WhereaboutsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *WhereaboutsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WhereaboutsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Whereabouts.
// If the Whereabouts object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WhereaboutsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WhereaboutsMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *WhereaboutsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Whereabouts).
func (m *WhereaboutsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WhereaboutsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, whereabouts.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WhereaboutsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case whereabouts.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WhereaboutsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case whereabouts.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Whereabouts field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WhereaboutsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case whereabouts.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Whereabouts field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WhereaboutsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WhereaboutsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WhereaboutsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Whereabouts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WhereaboutsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WhereaboutsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WhereaboutsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Whereabouts nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WhereaboutsMutation) ResetField(name string) error {
	switch name {
	case whereabouts.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Whereabouts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WhereaboutsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WhereaboutsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WhereaboutsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WhereaboutsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WhereaboutsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WhereaboutsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WhereaboutsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Whereabouts unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WhereaboutsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Whereabouts edge %s", name)
}

// WindDirectionMutation represents an operation that mutate the WindDirections
// nodes in the graph.
type WindDirectionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WindDirection, error)
}

var _ ent.Mutation = (*WindDirectionMutation)(nil)

// winddirectionOption allows to manage the mutation configuration using functional options.
type winddirectionOption func(*WindDirectionMutation)

// newWindDirectionMutation creates new mutation for $n.Name.
func newWindDirectionMutation(c config, op Op, opts ...winddirectionOption) *WindDirectionMutation {
	m := &WindDirectionMutation{
		config:        c,
		op:            op,
		typ:           TypeWindDirection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWindDirectionID sets the id field of the mutation.
func withWindDirectionID(id int64) winddirectionOption {
	return func(m *WindDirectionMutation) {
		var (
			err   error
			once  sync.Once
			value *WindDirection
		)
		m.oldValue = func(ctx context.Context) (*WindDirection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WindDirection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWindDirection sets the old WindDirection of the mutation.
func withWindDirection(node *WindDirection) winddirectionOption {
	return func(m *WindDirectionMutation) {
		m.oldValue = func(context.Context) (*WindDirection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WindDirectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WindDirectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WindDirectionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *WindDirectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WindDirectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the WindDirection.
// If the WindDirection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WindDirectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WindDirectionMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *WindDirectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WindDirection).
func (m *WindDirectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WindDirectionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, winddirection.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WindDirectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winddirection.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WindDirectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winddirection.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown WindDirection field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WindDirectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winddirection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown WindDirection field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WindDirectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WindDirectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WindDirectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WindDirection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WindDirectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WindDirectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WindDirectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WindDirection nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WindDirectionMutation) ResetField(name string) error {
	switch name {
	case winddirection.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown WindDirection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WindDirectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WindDirectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WindDirectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WindDirectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WindDirectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WindDirectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WindDirectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WindDirection unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WindDirectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WindDirection edge %s", name)
}

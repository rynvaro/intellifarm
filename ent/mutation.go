// Code generated by entc, DO NOT EDIT.

package ent

import (
	"cattleai/confs"
	"cattleai/ent/abortion"
	"cattleai/ent/abortionreason"
	"cattleai/ent/abortiontype"
	"cattleai/ent/api"
	"cattleai/ent/birthsurrounding"
	"cattleai/ent/breathrate"
	"cattleai/ent/breeding"
	"cattleai/ent/breedingtype"
	"cattleai/ent/calve"
	"cattleai/ent/calvecount"
	"cattleai/ent/calvetype"
	"cattleai/ent/category"
	"cattleai/ent/cattle"
	"cattleai/ent/cattlebreed"
	"cattleai/ent/cattlecate"
	"cattleai/ent/cattledie"
	"cattleai/ent/cattlegender"
	"cattleai/ent/cattlegroup"
	"cattleai/ent/cattlegrow"
	"cattleai/ent/cattlegrowsdata"
	"cattleai/ent/cattlegrowsrate"
	"cattleai/ent/cattlehaircolor"
	"cattleai/ent/cattlein"
	"cattleai/ent/cattlejoinedtype"
	"cattleai/ent/cattlemove"
	"cattleai/ent/cattlemovereason"
	"cattleai/ent/cattleout"
	"cattleai/ent/cattleowner"
	"cattleai/ent/cattletype"
	"cattleai/ent/concentrateformula"
	"cattleai/ent/concentrateprocess"
	"cattleai/ent/conf"
	"cattleai/ent/customer"
	"cattleai/ent/diseaseinfo"
	"cattleai/ent/disinfect"
	"cattleai/ent/duty"
	"cattleai/ent/epidemic"
	"cattleai/ent/epidemictype"
	"cattleai/ent/estrus"
	"cattleai/ent/estrustype"
	"cattleai/ent/event"
	"cattleai/ent/farm"
	"cattleai/ent/feedinfo"
	"cattleai/ent/feedrecord"
	"cattleai/ent/frozensemeninfo"
	"cattleai/ent/hairstate"
	"cattleai/ent/healthcare"
	"cattleai/ent/immunity"
	"cattleai/ent/inspection"
	"cattleai/ent/inventoryflow"
	"cattleai/ent/material"
	"cattleai/ent/materialtest"
	"cattleai/ent/medicine"
	"cattleai/ent/operation"
	"cattleai/ent/position"
	"cattleai/ent/positionapi"
	"cattleai/ent/pregnancytest"
	"cattleai/ent/pregnancytestmethod"
	"cattleai/ent/pregnancytestresult"
	"cattleai/ent/pregnancytesttype"
	"cattleai/ent/ration"
	"cattleai/ent/reproductionparameters"
	"cattleai/ent/reproductivestate"
	"cattleai/ent/semenfrozentype"
	"cattleai/ent/shed"
	"cattleai/ent/shedcategory"
	"cattleai/ent/shedsetting"
	"cattleai/ent/shedtype"
	"cattleai/ent/tenant"
	"cattleai/ent/treatmentresult"
	"cattleai/ent/treatmentstate"
	"cattleai/ent/user"
	"cattleai/ent/veterinarydrugsinfo"
	"cattleai/ent/warehousesetting"
	"cattleai/ent/whereabouts"
	"cattleai/ent/winddirection"
	"context"
	"fmt"
	"sync"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI                    = "API"
	TypeAbortion               = "Abortion"
	TypeAbortionReason         = "AbortionReason"
	TypeAbortionType           = "AbortionType"
	TypeBirthSurrounding       = "BirthSurrounding"
	TypeBreathRate             = "BreathRate"
	TypeBreeding               = "Breeding"
	TypeBreedingType           = "BreedingType"
	TypeCalve                  = "Calve"
	TypeCalveCount             = "CalveCount"
	TypeCalveType              = "CalveType"
	TypeCategory               = "Category"
	TypeCattle                 = "Cattle"
	TypeCattleBreed            = "CattleBreed"
	TypeCattleCate             = "CattleCate"
	TypeCattleDie              = "CattleDie"
	TypeCattleGender           = "CattleGender"
	TypeCattleGroup            = "CattleGroup"
	TypeCattleGrow             = "CattleGrow"
	TypeCattleGrowsData        = "CattleGrowsData"
	TypeCattleGrowsRate        = "CattleGrowsRate"
	TypeCattleHairColor        = "CattleHairColor"
	TypeCattleIn               = "CattleIn"
	TypeCattleJoinedType       = "CattleJoinedType"
	TypeCattleMove             = "CattleMove"
	TypeCattleMoveReason       = "CattleMoveReason"
	TypeCattleOut              = "CattleOut"
	TypeCattleOwner            = "CattleOwner"
	TypeCattleType             = "CattleType"
	TypeChange                 = "Change"
	TypeConcentrateFormula     = "ConcentrateFormula"
	TypeConcentrateProcess     = "ConcentrateProcess"
	TypeConf                   = "Conf"
	TypeCustomer               = "Customer"
	TypeDiseaseInfo            = "DiseaseInfo"
	TypeDisinfect              = "Disinfect"
	TypeDispence               = "Dispence"
	TypeDuty                   = "Duty"
	TypeEpidemic               = "Epidemic"
	TypeEpidemicType           = "EpidemicType"
	TypeEstrus                 = "Estrus"
	TypeEstrusType             = "EstrusType"
	TypeEvent                  = "Event"
	TypeFarm                   = "Farm"
	TypeFeedGroup              = "FeedGroup"
	TypeFeedInfo               = "FeedInfo"
	TypeFeedRecord             = "FeedRecord"
	TypeFrozenSemenInfo        = "FrozenSemenInfo"
	TypeHairState              = "HairState"
	TypeHealthCare             = "HealthCare"
	TypeImmunity               = "Immunity"
	TypeInspection             = "Inspection"
	TypeInventoryFlow          = "InventoryFlow"
	TypeMaterial               = "Material"
	TypeMaterialTest           = "MaterialTest"
	TypeMedicine               = "Medicine"
	TypeOperation              = "Operation"
	TypePosition               = "Position"
	TypePositionApi            = "PositionApi"
	TypePregnancyTest          = "PregnancyTest"
	TypePregnancyTestMethod    = "PregnancyTestMethod"
	TypePregnancyTestResult    = "PregnancyTestResult"
	TypePregnancyTestType      = "PregnancyTestType"
	TypeRation                 = "Ration"
	TypeReproductionParameters = "ReproductionParameters"
	TypeReproductiveState      = "ReproductiveState"
	TypeSemenFrozenType        = "SemenFrozenType"
	TypeShed                   = "Shed"
	TypeShedCategory           = "ShedCategory"
	TypeShedSetting            = "ShedSetting"
	TypeShedTrans              = "ShedTrans"
	TypeShedType               = "ShedType"
	TypeTenant                 = "Tenant"
	TypeTreatmentResult        = "TreatmentResult"
	TypeTreatmentState         = "TreatmentState"
	TypeUser                   = "User"
	TypeVeterinaryDrugsInfo    = "VeterinaryDrugsInfo"
	TypeWarehouseSetting       = "WarehouseSetting"
	TypeWhereabouts            = "Whereabouts"
	TypeWindDirection          = "WindDirection"
)

// APIMutation represents an operation that mutate the APIs
// nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	_path         *string
	level         *int
	addlevel      *int
	hash          *string
	redirect      *string
	component     *string
	isSub         *bool
	hasSub        *bool
	single        *bool
	parentId      *int64
	addparentId   *int64
	tenantId      *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows to manage the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for $n.Name.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the id field of the mutation.
func withAPIID(id int64) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on API creation.
func (m *APIMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *APIMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *APIMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *APIMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *APIMutation) ResetName() {
	m.name = nil
}

// SetPath sets the path field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the path value in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old path value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPath is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath reset all changes of the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetLevel sets the level field.
func (m *APIMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the level value in the mutation.
func (m *APIMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old level value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to level.
func (m *APIMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the level field in this mutation.
func (m *APIMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel reset all changes of the "level" field.
func (m *APIMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetHash sets the hash field.
func (m *APIMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the hash value in the mutation.
func (m *APIMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old hash value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHash is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash reset all changes of the "hash" field.
func (m *APIMutation) ResetHash() {
	m.hash = nil
}

// SetRedirect sets the redirect field.
func (m *APIMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the redirect value in the mutation.
func (m *APIMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old redirect value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRedirect is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of redirect.
func (m *APIMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[api.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the field redirect was cleared in this mutation.
func (m *APIMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[api.FieldRedirect]
	return ok
}

// ResetRedirect reset all changes of the "redirect" field.
func (m *APIMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, api.FieldRedirect)
}

// SetComponent sets the component field.
func (m *APIMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the component value in the mutation.
func (m *APIMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old component value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComponent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ResetComponent reset all changes of the "component" field.
func (m *APIMutation) ResetComponent() {
	m.component = nil
}

// SetIsSub sets the isSub field.
func (m *APIMutation) SetIsSub(b bool) {
	m.isSub = &b
}

// IsSub returns the isSub value in the mutation.
func (m *APIMutation) IsSub() (r bool, exists bool) {
	v := m.isSub
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSub returns the old isSub value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldIsSub(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsSub is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsSub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSub: %w", err)
	}
	return oldValue.IsSub, nil
}

// ResetIsSub reset all changes of the "isSub" field.
func (m *APIMutation) ResetIsSub() {
	m.isSub = nil
}

// SetHasSub sets the hasSub field.
func (m *APIMutation) SetHasSub(b bool) {
	m.hasSub = &b
}

// HasSub returns the hasSub value in the mutation.
func (m *APIMutation) HasSub() (r bool, exists bool) {
	v := m.hasSub
	if v == nil {
		return
	}
	return *v, true
}

// OldHasSub returns the old hasSub value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldHasSub(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHasSub is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHasSub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasSub: %w", err)
	}
	return oldValue.HasSub, nil
}

// ResetHasSub reset all changes of the "hasSub" field.
func (m *APIMutation) ResetHasSub() {
	m.hasSub = nil
}

// SetSingle sets the single field.
func (m *APIMutation) SetSingle(b bool) {
	m.single = &b
}

// Single returns the single value in the mutation.
func (m *APIMutation) Single() (r bool, exists bool) {
	v := m.single
	if v == nil {
		return
	}
	return *v, true
}

// OldSingle returns the old single value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldSingle(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSingle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSingle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSingle: %w", err)
	}
	return oldValue.Single, nil
}

// ResetSingle reset all changes of the "single" field.
func (m *APIMutation) ResetSingle() {
	m.single = nil
}

// SetParentId sets the parentId field.
func (m *APIMutation) SetParentId(i int64) {
	m.parentId = &i
	m.addparentId = nil
}

// ParentId returns the parentId value in the mutation.
func (m *APIMutation) ParentId() (r int64, exists bool) {
	v := m.parentId
	if v == nil {
		return
	}
	return *v, true
}

// OldParentId returns the old parentId value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldParentId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParentId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentId: %w", err)
	}
	return oldValue.ParentId, nil
}

// AddParentId adds i to parentId.
func (m *APIMutation) AddParentId(i int64) {
	if m.addparentId != nil {
		*m.addparentId += i
	} else {
		m.addparentId = &i
	}
}

// AddedParentId returns the value that was added to the parentId field in this mutation.
func (m *APIMutation) AddedParentId() (r int64, exists bool) {
	v := m.addparentId
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentId reset all changes of the "parentId" field.
func (m *APIMutation) ResetParentId() {
	m.parentId = nil
	m.addparentId = nil
}

// SetTenantId sets the tenantId field.
func (m *APIMutation) SetTenantId(s string) {
	m.tenantId = &s
}

// TenantId returns the tenantId value in the mutation.
func (m *APIMutation) TenantId() (r string, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldTenantId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *APIMutation) ResetTenantId() {
	m.tenantId = nil
}

// SetCreatedAt sets the createdAt field.
func (m *APIMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *APIMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *APIMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *APIMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *APIMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *APIMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *APIMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *APIMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *APIMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *APIMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *APIMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the API.
// If the API object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *APIMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *APIMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *APIMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *APIMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, api.FieldName)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.level != nil {
		fields = append(fields, api.FieldLevel)
	}
	if m.hash != nil {
		fields = append(fields, api.FieldHash)
	}
	if m.redirect != nil {
		fields = append(fields, api.FieldRedirect)
	}
	if m.component != nil {
		fields = append(fields, api.FieldComponent)
	}
	if m.isSub != nil {
		fields = append(fields, api.FieldIsSub)
	}
	if m.hasSub != nil {
		fields = append(fields, api.FieldHasSub)
	}
	if m.single != nil {
		fields = append(fields, api.FieldSingle)
	}
	if m.parentId != nil {
		fields = append(fields, api.FieldParentId)
	}
	if m.tenantId != nil {
		fields = append(fields, api.FieldTenantId)
	}
	if m.createdAt != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, api.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldName:
		return m.Name()
	case api.FieldPath:
		return m.Path()
	case api.FieldLevel:
		return m.Level()
	case api.FieldHash:
		return m.Hash()
	case api.FieldRedirect:
		return m.Redirect()
	case api.FieldComponent:
		return m.Component()
	case api.FieldIsSub:
		return m.IsSub()
	case api.FieldHasSub:
		return m.HasSub()
	case api.FieldSingle:
		return m.Single()
	case api.FieldParentId:
		return m.ParentId()
	case api.FieldTenantId:
		return m.TenantId()
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldName:
		return m.OldName(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldLevel:
		return m.OldLevel(ctx)
	case api.FieldHash:
		return m.OldHash(ctx)
	case api.FieldRedirect:
		return m.OldRedirect(ctx)
	case api.FieldComponent:
		return m.OldComponent(ctx)
	case api.FieldIsSub:
		return m.OldIsSub(ctx)
	case api.FieldHasSub:
		return m.OldHasSub(ctx)
	case api.FieldSingle:
		return m.OldSingle(ctx)
	case api.FieldParentId:
		return m.OldParentId(ctx)
	case api.FieldTenantId:
		return m.OldTenantId(ctx)
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case api.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case api.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case api.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case api.FieldIsSub:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSub(v)
		return nil
	case api.FieldHasSub:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasSub(v)
		return nil
	case api.FieldSingle:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSingle(v)
		return nil
	case api.FieldParentId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentId(v)
		return nil
	case api.FieldTenantId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case api.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *APIMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, api.FieldLevel)
	}
	if m.addparentId != nil {
		fields = append(fields, api.FieldParentId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, api.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case api.FieldLevel:
		return m.AddedLevel()
	case api.FieldParentId:
		return m.AddedParentId()
	case api.FieldCreatedAt:
		return m.AddedCreatedAt()
	case api.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case api.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	case api.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case api.FieldParentId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentId(v)
		return nil
	case api.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case api.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldRedirect) {
		fields = append(fields, api.FieldRedirect)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldRedirect:
		m.ClearRedirect()
		return nil
	}
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldName:
		m.ResetName()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldLevel:
		m.ResetLevel()
		return nil
	case api.FieldHash:
		m.ResetHash()
		return nil
	case api.FieldRedirect:
		m.ResetRedirect()
		return nil
	case api.FieldComponent:
		m.ResetComponent()
		return nil
	case api.FieldIsSub:
		m.ResetIsSub()
		return nil
	case api.FieldHasSub:
		m.ResetHasSub()
		return nil
	case api.FieldSingle:
		m.ResetSingle()
		return nil
	case api.FieldParentId:
		m.ResetParentId()
		return nil
	case api.FieldTenantId:
		m.ResetTenantId()
		return nil
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// AbortionMutation represents an operation that mutate the Abortions
// nodes in the graph.
type AbortionMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	cattleId          *int64
	addcattleId       *int64
	tenantId          *int64
	addtenantId       *int64
	tenantName        *string
	farmId            *int64
	addfarmId         *int64
	farmName          *string
	shedId            *int64
	addshedId         *int64
	shedName          *string
	name              *string
	earNumber         *string
	times             *int
	addtimes          *int
	pregnantAt        *int64
	addpregnantAt     *int64
	abortionAt        *int64
	addabortionAt     *int64
	abortionTypeId    *int
	addabortionTypeId *int
	abortionTypeName  *string
	userName          *string
	remarks           *string
	createdAt         *int64
	addcreatedAt      *int64
	updatedAt         *int64
	addupdatedAt      *int64
	deleted           *int
	adddeleted        *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Abortion, error)
}

var _ ent.Mutation = (*AbortionMutation)(nil)

// abortionOption allows to manage the mutation configuration using functional options.
type abortionOption func(*AbortionMutation)

// newAbortionMutation creates new mutation for $n.Name.
func newAbortionMutation(c config, op Op, opts ...abortionOption) *AbortionMutation {
	m := &AbortionMutation{
		config:        c,
		op:            op,
		typ:           TypeAbortion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbortionID sets the id field of the mutation.
func withAbortionID(id int64) abortionOption {
	return func(m *AbortionMutation) {
		var (
			err   error
			once  sync.Once
			value *Abortion
		)
		m.oldValue = func(ctx context.Context) (*Abortion, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Abortion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbortion sets the old Abortion of the mutation.
func withAbortion(node *Abortion) abortionOption {
	return func(m *AbortionMutation) {
		m.oldValue = func(context.Context) (*Abortion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbortionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbortionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AbortionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *AbortionMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *AbortionMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *AbortionMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *AbortionMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *AbortionMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *AbortionMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *AbortionMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *AbortionMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *AbortionMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *AbortionMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *AbortionMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *AbortionMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *AbortionMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *AbortionMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *AbortionMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *AbortionMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *AbortionMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *AbortionMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *AbortionMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *AbortionMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *AbortionMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *AbortionMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *AbortionMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *AbortionMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *AbortionMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *AbortionMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *AbortionMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *AbortionMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *AbortionMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *AbortionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AbortionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *AbortionMutation) ClearName() {
	m.name = nil
	m.clearedFields[abortion.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *AbortionMutation) NameCleared() bool {
	_, ok := m.clearedFields[abortion.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *AbortionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, abortion.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *AbortionMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *AbortionMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *AbortionMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *AbortionMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *AbortionMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *AbortionMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *AbortionMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *AbortionMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetPregnantAt sets the pregnantAt field.
func (m *AbortionMutation) SetPregnantAt(i int64) {
	m.pregnantAt = &i
	m.addpregnantAt = nil
}

// PregnantAt returns the pregnantAt value in the mutation.
func (m *AbortionMutation) PregnantAt() (r int64, exists bool) {
	v := m.pregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnantAt returns the old pregnantAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldPregnantAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnantAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnantAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnantAt: %w", err)
	}
	return oldValue.PregnantAt, nil
}

// AddPregnantAt adds i to pregnantAt.
func (m *AbortionMutation) AddPregnantAt(i int64) {
	if m.addpregnantAt != nil {
		*m.addpregnantAt += i
	} else {
		m.addpregnantAt = &i
	}
}

// AddedPregnantAt returns the value that was added to the pregnantAt field in this mutation.
func (m *AbortionMutation) AddedPregnantAt() (r int64, exists bool) {
	v := m.addpregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnantAt reset all changes of the "pregnantAt" field.
func (m *AbortionMutation) ResetPregnantAt() {
	m.pregnantAt = nil
	m.addpregnantAt = nil
}

// SetAbortionAt sets the abortionAt field.
func (m *AbortionMutation) SetAbortionAt(i int64) {
	m.abortionAt = &i
	m.addabortionAt = nil
}

// AbortionAt returns the abortionAt value in the mutation.
func (m *AbortionMutation) AbortionAt() (r int64, exists bool) {
	v := m.abortionAt
	if v == nil {
		return
	}
	return *v, true
}

// OldAbortionAt returns the old abortionAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldAbortionAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbortionAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbortionAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbortionAt: %w", err)
	}
	return oldValue.AbortionAt, nil
}

// AddAbortionAt adds i to abortionAt.
func (m *AbortionMutation) AddAbortionAt(i int64) {
	if m.addabortionAt != nil {
		*m.addabortionAt += i
	} else {
		m.addabortionAt = &i
	}
}

// AddedAbortionAt returns the value that was added to the abortionAt field in this mutation.
func (m *AbortionMutation) AddedAbortionAt() (r int64, exists bool) {
	v := m.addabortionAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbortionAt reset all changes of the "abortionAt" field.
func (m *AbortionMutation) ResetAbortionAt() {
	m.abortionAt = nil
	m.addabortionAt = nil
}

// SetAbortionTypeId sets the abortionTypeId field.
func (m *AbortionMutation) SetAbortionTypeId(i int) {
	m.abortionTypeId = &i
	m.addabortionTypeId = nil
}

// AbortionTypeId returns the abortionTypeId value in the mutation.
func (m *AbortionMutation) AbortionTypeId() (r int, exists bool) {
	v := m.abortionTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldAbortionTypeId returns the old abortionTypeId value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldAbortionTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbortionTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbortionTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbortionTypeId: %w", err)
	}
	return oldValue.AbortionTypeId, nil
}

// AddAbortionTypeId adds i to abortionTypeId.
func (m *AbortionMutation) AddAbortionTypeId(i int) {
	if m.addabortionTypeId != nil {
		*m.addabortionTypeId += i
	} else {
		m.addabortionTypeId = &i
	}
}

// AddedAbortionTypeId returns the value that was added to the abortionTypeId field in this mutation.
func (m *AbortionMutation) AddedAbortionTypeId() (r int, exists bool) {
	v := m.addabortionTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetAbortionTypeId reset all changes of the "abortionTypeId" field.
func (m *AbortionMutation) ResetAbortionTypeId() {
	m.abortionTypeId = nil
	m.addabortionTypeId = nil
}

// SetAbortionTypeName sets the abortionTypeName field.
func (m *AbortionMutation) SetAbortionTypeName(s string) {
	m.abortionTypeName = &s
}

// AbortionTypeName returns the abortionTypeName value in the mutation.
func (m *AbortionMutation) AbortionTypeName() (r string, exists bool) {
	v := m.abortionTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldAbortionTypeName returns the old abortionTypeName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldAbortionTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAbortionTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAbortionTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbortionTypeName: %w", err)
	}
	return oldValue.AbortionTypeName, nil
}

// ResetAbortionTypeName reset all changes of the "abortionTypeName" field.
func (m *AbortionMutation) ResetAbortionTypeName() {
	m.abortionTypeName = nil
}

// SetUserName sets the userName field.
func (m *AbortionMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *AbortionMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *AbortionMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *AbortionMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *AbortionMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *AbortionMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *AbortionMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *AbortionMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *AbortionMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *AbortionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *AbortionMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *AbortionMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *AbortionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *AbortionMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *AbortionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *AbortionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *AbortionMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *AbortionMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Abortion.
// If the Abortion object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *AbortionMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *AbortionMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *AbortionMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *AbortionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Abortion).
func (m *AbortionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AbortionMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.cattleId != nil {
		fields = append(fields, abortion.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, abortion.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, abortion.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, abortion.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, abortion.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, abortion.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, abortion.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, abortion.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, abortion.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, abortion.FieldTimes)
	}
	if m.pregnantAt != nil {
		fields = append(fields, abortion.FieldPregnantAt)
	}
	if m.abortionAt != nil {
		fields = append(fields, abortion.FieldAbortionAt)
	}
	if m.abortionTypeId != nil {
		fields = append(fields, abortion.FieldAbortionTypeId)
	}
	if m.abortionTypeName != nil {
		fields = append(fields, abortion.FieldAbortionTypeName)
	}
	if m.userName != nil {
		fields = append(fields, abortion.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, abortion.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, abortion.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, abortion.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, abortion.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AbortionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abortion.FieldCattleId:
		return m.CattleId()
	case abortion.FieldTenantId:
		return m.TenantId()
	case abortion.FieldTenantName:
		return m.TenantName()
	case abortion.FieldFarmId:
		return m.FarmId()
	case abortion.FieldFarmName:
		return m.FarmName()
	case abortion.FieldShedId:
		return m.ShedId()
	case abortion.FieldShedName:
		return m.ShedName()
	case abortion.FieldName:
		return m.Name()
	case abortion.FieldEarNumber:
		return m.EarNumber()
	case abortion.FieldTimes:
		return m.Times()
	case abortion.FieldPregnantAt:
		return m.PregnantAt()
	case abortion.FieldAbortionAt:
		return m.AbortionAt()
	case abortion.FieldAbortionTypeId:
		return m.AbortionTypeId()
	case abortion.FieldAbortionTypeName:
		return m.AbortionTypeName()
	case abortion.FieldUserName:
		return m.UserName()
	case abortion.FieldRemarks:
		return m.Remarks()
	case abortion.FieldCreatedAt:
		return m.CreatedAt()
	case abortion.FieldUpdatedAt:
		return m.UpdatedAt()
	case abortion.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AbortionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abortion.FieldCattleId:
		return m.OldCattleId(ctx)
	case abortion.FieldTenantId:
		return m.OldTenantId(ctx)
	case abortion.FieldTenantName:
		return m.OldTenantName(ctx)
	case abortion.FieldFarmId:
		return m.OldFarmId(ctx)
	case abortion.FieldFarmName:
		return m.OldFarmName(ctx)
	case abortion.FieldShedId:
		return m.OldShedId(ctx)
	case abortion.FieldShedName:
		return m.OldShedName(ctx)
	case abortion.FieldName:
		return m.OldName(ctx)
	case abortion.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case abortion.FieldTimes:
		return m.OldTimes(ctx)
	case abortion.FieldPregnantAt:
		return m.OldPregnantAt(ctx)
	case abortion.FieldAbortionAt:
		return m.OldAbortionAt(ctx)
	case abortion.FieldAbortionTypeId:
		return m.OldAbortionTypeId(ctx)
	case abortion.FieldAbortionTypeName:
		return m.OldAbortionTypeName(ctx)
	case abortion.FieldUserName:
		return m.OldUserName(ctx)
	case abortion.FieldRemarks:
		return m.OldRemarks(ctx)
	case abortion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case abortion.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case abortion.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Abortion field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abortion.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case abortion.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case abortion.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case abortion.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case abortion.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case abortion.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case abortion.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case abortion.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abortion.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case abortion.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case abortion.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnantAt(v)
		return nil
	case abortion.FieldAbortionAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbortionAt(v)
		return nil
	case abortion.FieldAbortionTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbortionTypeId(v)
		return nil
	case abortion.FieldAbortionTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbortionTypeName(v)
		return nil
	case abortion.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case abortion.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case abortion.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case abortion.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case abortion.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Abortion field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AbortionMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, abortion.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, abortion.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, abortion.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, abortion.FieldShedId)
	}
	if m.addtimes != nil {
		fields = append(fields, abortion.FieldTimes)
	}
	if m.addpregnantAt != nil {
		fields = append(fields, abortion.FieldPregnantAt)
	}
	if m.addabortionAt != nil {
		fields = append(fields, abortion.FieldAbortionAt)
	}
	if m.addabortionTypeId != nil {
		fields = append(fields, abortion.FieldAbortionTypeId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, abortion.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, abortion.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, abortion.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AbortionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abortion.FieldCattleId:
		return m.AddedCattleId()
	case abortion.FieldTenantId:
		return m.AddedTenantId()
	case abortion.FieldFarmId:
		return m.AddedFarmId()
	case abortion.FieldShedId:
		return m.AddedShedId()
	case abortion.FieldTimes:
		return m.AddedTimes()
	case abortion.FieldPregnantAt:
		return m.AddedPregnantAt()
	case abortion.FieldAbortionAt:
		return m.AddedAbortionAt()
	case abortion.FieldAbortionTypeId:
		return m.AddedAbortionTypeId()
	case abortion.FieldCreatedAt:
		return m.AddedCreatedAt()
	case abortion.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case abortion.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abortion.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case abortion.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case abortion.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case abortion.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case abortion.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case abortion.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnantAt(v)
		return nil
	case abortion.FieldAbortionAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbortionAt(v)
		return nil
	case abortion.FieldAbortionTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAbortionTypeId(v)
		return nil
	case abortion.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case abortion.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case abortion.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Abortion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AbortionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(abortion.FieldName) {
		fields = append(fields, abortion.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AbortionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbortionMutation) ClearField(name string) error {
	switch name {
	case abortion.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Abortion nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AbortionMutation) ResetField(name string) error {
	switch name {
	case abortion.FieldCattleId:
		m.ResetCattleId()
		return nil
	case abortion.FieldTenantId:
		m.ResetTenantId()
		return nil
	case abortion.FieldTenantName:
		m.ResetTenantName()
		return nil
	case abortion.FieldFarmId:
		m.ResetFarmId()
		return nil
	case abortion.FieldFarmName:
		m.ResetFarmName()
		return nil
	case abortion.FieldShedId:
		m.ResetShedId()
		return nil
	case abortion.FieldShedName:
		m.ResetShedName()
		return nil
	case abortion.FieldName:
		m.ResetName()
		return nil
	case abortion.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case abortion.FieldTimes:
		m.ResetTimes()
		return nil
	case abortion.FieldPregnantAt:
		m.ResetPregnantAt()
		return nil
	case abortion.FieldAbortionAt:
		m.ResetAbortionAt()
		return nil
	case abortion.FieldAbortionTypeId:
		m.ResetAbortionTypeId()
		return nil
	case abortion.FieldAbortionTypeName:
		m.ResetAbortionTypeName()
		return nil
	case abortion.FieldUserName:
		m.ResetUserName()
		return nil
	case abortion.FieldRemarks:
		m.ResetRemarks()
		return nil
	case abortion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case abortion.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case abortion.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Abortion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AbortionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AbortionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AbortionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AbortionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AbortionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AbortionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AbortionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Abortion unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AbortionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Abortion edge %s", name)
}

// AbortionReasonMutation represents an operation that mutate the AbortionReasons
// nodes in the graph.
type AbortionReasonMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	_order        *int
	add_order     *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AbortionReason, error)
}

var _ ent.Mutation = (*AbortionReasonMutation)(nil)

// abortionreasonOption allows to manage the mutation configuration using functional options.
type abortionreasonOption func(*AbortionReasonMutation)

// newAbortionReasonMutation creates new mutation for $n.Name.
func newAbortionReasonMutation(c config, op Op, opts ...abortionreasonOption) *AbortionReasonMutation {
	m := &AbortionReasonMutation{
		config:        c,
		op:            op,
		typ:           TypeAbortionReason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbortionReasonID sets the id field of the mutation.
func withAbortionReasonID(id int64) abortionreasonOption {
	return func(m *AbortionReasonMutation) {
		var (
			err   error
			once  sync.Once
			value *AbortionReason
		)
		m.oldValue = func(ctx context.Context) (*AbortionReason, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbortionReason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbortionReason sets the old AbortionReason of the mutation.
func withAbortionReason(node *AbortionReason) abortionreasonOption {
	return func(m *AbortionReasonMutation) {
		m.oldValue = func(context.Context) (*AbortionReason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbortionReasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbortionReasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AbortionReasonMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *AbortionReasonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AbortionReasonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AbortionReasonMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *AbortionReasonMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *AbortionReasonMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *AbortionReasonMutation) ResetCode() {
	m.code = nil
}

// SetTenantId sets the tenantId field.
func (m *AbortionReasonMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *AbortionReasonMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *AbortionReasonMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *AbortionReasonMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *AbortionReasonMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *AbortionReasonMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *AbortionReasonMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *AbortionReasonMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetOrder sets the order field.
func (m *AbortionReasonMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the order value in the mutation.
func (m *AbortionReasonMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old order value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to order.
func (m *AbortionReasonMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the order field in this mutation.
func (m *AbortionReasonMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder reset all changes of the "order" field.
func (m *AbortionReasonMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRemarks sets the remarks field.
func (m *AbortionReasonMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *AbortionReasonMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *AbortionReasonMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *AbortionReasonMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *AbortionReasonMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *AbortionReasonMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *AbortionReasonMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *AbortionReasonMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *AbortionReasonMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *AbortionReasonMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *AbortionReasonMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *AbortionReasonMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *AbortionReasonMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *AbortionReasonMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *AbortionReasonMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the AbortionReason.
// If the AbortionReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionReasonMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *AbortionReasonMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *AbortionReasonMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *AbortionReasonMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *AbortionReasonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AbortionReason).
func (m *AbortionReasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AbortionReasonMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, abortionreason.FieldName)
	}
	if m.code != nil {
		fields = append(fields, abortionreason.FieldCode)
	}
	if m.tenantId != nil {
		fields = append(fields, abortionreason.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, abortionreason.FieldTenantName)
	}
	if m._order != nil {
		fields = append(fields, abortionreason.FieldOrder)
	}
	if m.remarks != nil {
		fields = append(fields, abortionreason.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, abortionreason.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, abortionreason.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, abortionreason.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AbortionReasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abortionreason.FieldName:
		return m.Name()
	case abortionreason.FieldCode:
		return m.Code()
	case abortionreason.FieldTenantId:
		return m.TenantId()
	case abortionreason.FieldTenantName:
		return m.TenantName()
	case abortionreason.FieldOrder:
		return m.Order()
	case abortionreason.FieldRemarks:
		return m.Remarks()
	case abortionreason.FieldCreatedAt:
		return m.CreatedAt()
	case abortionreason.FieldUpdatedAt:
		return m.UpdatedAt()
	case abortionreason.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AbortionReasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abortionreason.FieldName:
		return m.OldName(ctx)
	case abortionreason.FieldCode:
		return m.OldCode(ctx)
	case abortionreason.FieldTenantId:
		return m.OldTenantId(ctx)
	case abortionreason.FieldTenantName:
		return m.OldTenantName(ctx)
	case abortionreason.FieldOrder:
		return m.OldOrder(ctx)
	case abortionreason.FieldRemarks:
		return m.OldRemarks(ctx)
	case abortionreason.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case abortionreason.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case abortionreason.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown AbortionReason field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionReasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abortionreason.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case abortionreason.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case abortionreason.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case abortionreason.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case abortionreason.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case abortionreason.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case abortionreason.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case abortionreason.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case abortionreason.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown AbortionReason field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AbortionReasonMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, abortionreason.FieldTenantId)
	}
	if m.add_order != nil {
		fields = append(fields, abortionreason.FieldOrder)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, abortionreason.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, abortionreason.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, abortionreason.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AbortionReasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case abortionreason.FieldTenantId:
		return m.AddedTenantId()
	case abortionreason.FieldOrder:
		return m.AddedOrder()
	case abortionreason.FieldCreatedAt:
		return m.AddedCreatedAt()
	case abortionreason.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case abortionreason.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionReasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case abortionreason.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case abortionreason.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case abortionreason.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case abortionreason.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case abortionreason.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown AbortionReason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AbortionReasonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AbortionReasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbortionReasonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AbortionReason nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AbortionReasonMutation) ResetField(name string) error {
	switch name {
	case abortionreason.FieldName:
		m.ResetName()
		return nil
	case abortionreason.FieldCode:
		m.ResetCode()
		return nil
	case abortionreason.FieldTenantId:
		m.ResetTenantId()
		return nil
	case abortionreason.FieldTenantName:
		m.ResetTenantName()
		return nil
	case abortionreason.FieldOrder:
		m.ResetOrder()
		return nil
	case abortionreason.FieldRemarks:
		m.ResetRemarks()
		return nil
	case abortionreason.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case abortionreason.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case abortionreason.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown AbortionReason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AbortionReasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AbortionReasonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AbortionReasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AbortionReasonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AbortionReasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AbortionReasonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AbortionReasonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AbortionReason unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AbortionReasonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AbortionReason edge %s", name)
}

// AbortionTypeMutation represents an operation that mutate the AbortionTypes
// nodes in the graph.
type AbortionTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AbortionType, error)
}

var _ ent.Mutation = (*AbortionTypeMutation)(nil)

// abortiontypeOption allows to manage the mutation configuration using functional options.
type abortiontypeOption func(*AbortionTypeMutation)

// newAbortionTypeMutation creates new mutation for $n.Name.
func newAbortionTypeMutation(c config, op Op, opts ...abortiontypeOption) *AbortionTypeMutation {
	m := &AbortionTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAbortionType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbortionTypeID sets the id field of the mutation.
func withAbortionTypeID(id int64) abortiontypeOption {
	return func(m *AbortionTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AbortionType
		)
		m.oldValue = func(ctx context.Context) (*AbortionType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbortionType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbortionType sets the old AbortionType of the mutation.
func withAbortionType(node *AbortionType) abortiontypeOption {
	return func(m *AbortionTypeMutation) {
		m.oldValue = func(context.Context) (*AbortionType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbortionTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbortionTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AbortionTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *AbortionTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *AbortionTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the AbortionType.
// If the AbortionType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AbortionTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *AbortionTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *AbortionTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AbortionType).
func (m *AbortionTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AbortionTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, abortiontype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AbortionTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case abortiontype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AbortionTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case abortiontype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown AbortionType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case abortiontype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown AbortionType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AbortionTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AbortionTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AbortionTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AbortionType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AbortionTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AbortionTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbortionTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AbortionType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AbortionTypeMutation) ResetField(name string) error {
	switch name {
	case abortiontype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown AbortionType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AbortionTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AbortionTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AbortionTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AbortionTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AbortionTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AbortionTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AbortionTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AbortionType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AbortionTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AbortionType edge %s", name)
}

// BirthSurroundingMutation represents an operation that mutate the BirthSurroundings
// nodes in the graph.
type BirthSurroundingMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	farmId             *int64
	addfarmId          *int64
	farmName           *string
	recordTime         *int64
	addrecordTime      *int64
	userId             *int64
	adduserId          *int64
	userName           *string
	temperature        *int64
	addtemperature     *int64
	humidity           *int64
	addhumidity        *int64
	breathRateId       *int64
	addbreathRateId    *int64
	breathRateName     *string
	windSpeed          *int64
	addwindSpeed       *int64
	windDirectionId    *int
	addwindDirectionId *int
	windDirection      *string
	locationChanges    *int64
	addlocationChanges *int64
	hairStateId        *int
	addhairStateId     *int
	hairStateName      *string
	soilDepth          *int
	addsoilDepth       *int
	sunExposure        *int
	addsunExposure     *int
	walkDistance       *int
	addwalkDistance    *int
	rained             *int
	addrained          *int
	thIndex            *float32
	addthIndex         *float32
	tenantId           *int64
	addtenantId        *int64
	tenantName         *string
	remarks            *string
	createdAt          *int64
	addcreatedAt       *int64
	updatedAt          *int64
	addupdatedAt       *int64
	deleted            *int
	adddeleted         *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*BirthSurrounding, error)
}

var _ ent.Mutation = (*BirthSurroundingMutation)(nil)

// birthsurroundingOption allows to manage the mutation configuration using functional options.
type birthsurroundingOption func(*BirthSurroundingMutation)

// newBirthSurroundingMutation creates new mutation for $n.Name.
func newBirthSurroundingMutation(c config, op Op, opts ...birthsurroundingOption) *BirthSurroundingMutation {
	m := &BirthSurroundingMutation{
		config:        c,
		op:            op,
		typ:           TypeBirthSurrounding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBirthSurroundingID sets the id field of the mutation.
func withBirthSurroundingID(id int64) birthsurroundingOption {
	return func(m *BirthSurroundingMutation) {
		var (
			err   error
			once  sync.Once
			value *BirthSurrounding
		)
		m.oldValue = func(ctx context.Context) (*BirthSurrounding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BirthSurrounding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBirthSurrounding sets the old BirthSurrounding of the mutation.
func withBirthSurrounding(node *BirthSurrounding) birthsurroundingOption {
	return func(m *BirthSurroundingMutation) {
		m.oldValue = func(context.Context) (*BirthSurrounding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BirthSurroundingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BirthSurroundingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BirthSurroundingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *BirthSurroundingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BirthSurroundingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BirthSurroundingMutation) ResetName() {
	m.name = nil
}

// SetFarmId sets the farmId field.
func (m *BirthSurroundingMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *BirthSurroundingMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *BirthSurroundingMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *BirthSurroundingMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *BirthSurroundingMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *BirthSurroundingMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *BirthSurroundingMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *BirthSurroundingMutation) ResetFarmName() {
	m.farmName = nil
}

// SetRecordTime sets the recordTime field.
func (m *BirthSurroundingMutation) SetRecordTime(i int64) {
	m.recordTime = &i
	m.addrecordTime = nil
}

// RecordTime returns the recordTime value in the mutation.
func (m *BirthSurroundingMutation) RecordTime() (r int64, exists bool) {
	v := m.recordTime
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordTime returns the old recordTime value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldRecordTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRecordTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRecordTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordTime: %w", err)
	}
	return oldValue.RecordTime, nil
}

// AddRecordTime adds i to recordTime.
func (m *BirthSurroundingMutation) AddRecordTime(i int64) {
	if m.addrecordTime != nil {
		*m.addrecordTime += i
	} else {
		m.addrecordTime = &i
	}
}

// AddedRecordTime returns the value that was added to the recordTime field in this mutation.
func (m *BirthSurroundingMutation) AddedRecordTime() (r int64, exists bool) {
	v := m.addrecordTime
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecordTime reset all changes of the "recordTime" field.
func (m *BirthSurroundingMutation) ResetRecordTime() {
	m.recordTime = nil
	m.addrecordTime = nil
}

// SetUserId sets the userId field.
func (m *BirthSurroundingMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the userId value in the mutation.
func (m *BirthSurroundingMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old userId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to userId.
func (m *BirthSurroundingMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the userId field in this mutation.
func (m *BirthSurroundingMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId reset all changes of the "userId" field.
func (m *BirthSurroundingMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetUserName sets the userName field.
func (m *BirthSurroundingMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *BirthSurroundingMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *BirthSurroundingMutation) ResetUserName() {
	m.userName = nil
}

// SetTemperature sets the temperature field.
func (m *BirthSurroundingMutation) SetTemperature(i int64) {
	m.temperature = &i
	m.addtemperature = nil
}

// Temperature returns the temperature value in the mutation.
func (m *BirthSurroundingMutation) Temperature() (r int64, exists bool) {
	v := m.temperature
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperature returns the old temperature value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldTemperature(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemperature is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemperature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperature: %w", err)
	}
	return oldValue.Temperature, nil
}

// AddTemperature adds i to temperature.
func (m *BirthSurroundingMutation) AddTemperature(i int64) {
	if m.addtemperature != nil {
		*m.addtemperature += i
	} else {
		m.addtemperature = &i
	}
}

// AddedTemperature returns the value that was added to the temperature field in this mutation.
func (m *BirthSurroundingMutation) AddedTemperature() (r int64, exists bool) {
	v := m.addtemperature
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemperature reset all changes of the "temperature" field.
func (m *BirthSurroundingMutation) ResetTemperature() {
	m.temperature = nil
	m.addtemperature = nil
}

// SetHumidity sets the humidity field.
func (m *BirthSurroundingMutation) SetHumidity(i int64) {
	m.humidity = &i
	m.addhumidity = nil
}

// Humidity returns the humidity value in the mutation.
func (m *BirthSurroundingMutation) Humidity() (r int64, exists bool) {
	v := m.humidity
	if v == nil {
		return
	}
	return *v, true
}

// OldHumidity returns the old humidity value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldHumidity(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHumidity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHumidity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHumidity: %w", err)
	}
	return oldValue.Humidity, nil
}

// AddHumidity adds i to humidity.
func (m *BirthSurroundingMutation) AddHumidity(i int64) {
	if m.addhumidity != nil {
		*m.addhumidity += i
	} else {
		m.addhumidity = &i
	}
}

// AddedHumidity returns the value that was added to the humidity field in this mutation.
func (m *BirthSurroundingMutation) AddedHumidity() (r int64, exists bool) {
	v := m.addhumidity
	if v == nil {
		return
	}
	return *v, true
}

// ResetHumidity reset all changes of the "humidity" field.
func (m *BirthSurroundingMutation) ResetHumidity() {
	m.humidity = nil
	m.addhumidity = nil
}

// SetBreathRateId sets the breathRateId field.
func (m *BirthSurroundingMutation) SetBreathRateId(i int64) {
	m.breathRateId = &i
	m.addbreathRateId = nil
}

// BreathRateId returns the breathRateId value in the mutation.
func (m *BirthSurroundingMutation) BreathRateId() (r int64, exists bool) {
	v := m.breathRateId
	if v == nil {
		return
	}
	return *v, true
}

// OldBreathRateId returns the old breathRateId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldBreathRateId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreathRateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreathRateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreathRateId: %w", err)
	}
	return oldValue.BreathRateId, nil
}

// AddBreathRateId adds i to breathRateId.
func (m *BirthSurroundingMutation) AddBreathRateId(i int64) {
	if m.addbreathRateId != nil {
		*m.addbreathRateId += i
	} else {
		m.addbreathRateId = &i
	}
}

// AddedBreathRateId returns the value that was added to the breathRateId field in this mutation.
func (m *BirthSurroundingMutation) AddedBreathRateId() (r int64, exists bool) {
	v := m.addbreathRateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreathRateId reset all changes of the "breathRateId" field.
func (m *BirthSurroundingMutation) ResetBreathRateId() {
	m.breathRateId = nil
	m.addbreathRateId = nil
}

// SetBreathRateName sets the breathRateName field.
func (m *BirthSurroundingMutation) SetBreathRateName(s string) {
	m.breathRateName = &s
}

// BreathRateName returns the breathRateName value in the mutation.
func (m *BirthSurroundingMutation) BreathRateName() (r string, exists bool) {
	v := m.breathRateName
	if v == nil {
		return
	}
	return *v, true
}

// OldBreathRateName returns the old breathRateName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldBreathRateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreathRateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreathRateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreathRateName: %w", err)
	}
	return oldValue.BreathRateName, nil
}

// ResetBreathRateName reset all changes of the "breathRateName" field.
func (m *BirthSurroundingMutation) ResetBreathRateName() {
	m.breathRateName = nil
}

// SetWindSpeed sets the windSpeed field.
func (m *BirthSurroundingMutation) SetWindSpeed(i int64) {
	m.windSpeed = &i
	m.addwindSpeed = nil
}

// WindSpeed returns the windSpeed value in the mutation.
func (m *BirthSurroundingMutation) WindSpeed() (r int64, exists bool) {
	v := m.windSpeed
	if v == nil {
		return
	}
	return *v, true
}

// OldWindSpeed returns the old windSpeed value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWindSpeed(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWindSpeed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWindSpeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindSpeed: %w", err)
	}
	return oldValue.WindSpeed, nil
}

// AddWindSpeed adds i to windSpeed.
func (m *BirthSurroundingMutation) AddWindSpeed(i int64) {
	if m.addwindSpeed != nil {
		*m.addwindSpeed += i
	} else {
		m.addwindSpeed = &i
	}
}

// AddedWindSpeed returns the value that was added to the windSpeed field in this mutation.
func (m *BirthSurroundingMutation) AddedWindSpeed() (r int64, exists bool) {
	v := m.addwindSpeed
	if v == nil {
		return
	}
	return *v, true
}

// ResetWindSpeed reset all changes of the "windSpeed" field.
func (m *BirthSurroundingMutation) ResetWindSpeed() {
	m.windSpeed = nil
	m.addwindSpeed = nil
}

// SetWindDirectionId sets the windDirectionId field.
func (m *BirthSurroundingMutation) SetWindDirectionId(i int) {
	m.windDirectionId = &i
	m.addwindDirectionId = nil
}

// WindDirectionId returns the windDirectionId value in the mutation.
func (m *BirthSurroundingMutation) WindDirectionId() (r int, exists bool) {
	v := m.windDirectionId
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirectionId returns the old windDirectionId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWindDirectionId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWindDirectionId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWindDirectionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirectionId: %w", err)
	}
	return oldValue.WindDirectionId, nil
}

// AddWindDirectionId adds i to windDirectionId.
func (m *BirthSurroundingMutation) AddWindDirectionId(i int) {
	if m.addwindDirectionId != nil {
		*m.addwindDirectionId += i
	} else {
		m.addwindDirectionId = &i
	}
}

// AddedWindDirectionId returns the value that was added to the windDirectionId field in this mutation.
func (m *BirthSurroundingMutation) AddedWindDirectionId() (r int, exists bool) {
	v := m.addwindDirectionId
	if v == nil {
		return
	}
	return *v, true
}

// ResetWindDirectionId reset all changes of the "windDirectionId" field.
func (m *BirthSurroundingMutation) ResetWindDirectionId() {
	m.windDirectionId = nil
	m.addwindDirectionId = nil
}

// SetWindDirection sets the windDirection field.
func (m *BirthSurroundingMutation) SetWindDirection(s string) {
	m.windDirection = &s
}

// WindDirection returns the windDirection value in the mutation.
func (m *BirthSurroundingMutation) WindDirection() (r string, exists bool) {
	v := m.windDirection
	if v == nil {
		return
	}
	return *v, true
}

// OldWindDirection returns the old windDirection value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWindDirection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWindDirection is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWindDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWindDirection: %w", err)
	}
	return oldValue.WindDirection, nil
}

// ResetWindDirection reset all changes of the "windDirection" field.
func (m *BirthSurroundingMutation) ResetWindDirection() {
	m.windDirection = nil
}

// SetLocationChanges sets the locationChanges field.
func (m *BirthSurroundingMutation) SetLocationChanges(i int64) {
	m.locationChanges = &i
	m.addlocationChanges = nil
}

// LocationChanges returns the locationChanges value in the mutation.
func (m *BirthSurroundingMutation) LocationChanges() (r int64, exists bool) {
	v := m.locationChanges
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationChanges returns the old locationChanges value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldLocationChanges(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLocationChanges is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLocationChanges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationChanges: %w", err)
	}
	return oldValue.LocationChanges, nil
}

// AddLocationChanges adds i to locationChanges.
func (m *BirthSurroundingMutation) AddLocationChanges(i int64) {
	if m.addlocationChanges != nil {
		*m.addlocationChanges += i
	} else {
		m.addlocationChanges = &i
	}
}

// AddedLocationChanges returns the value that was added to the locationChanges field in this mutation.
func (m *BirthSurroundingMutation) AddedLocationChanges() (r int64, exists bool) {
	v := m.addlocationChanges
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocationChanges reset all changes of the "locationChanges" field.
func (m *BirthSurroundingMutation) ResetLocationChanges() {
	m.locationChanges = nil
	m.addlocationChanges = nil
}

// SetHairStateId sets the hairStateId field.
func (m *BirthSurroundingMutation) SetHairStateId(i int) {
	m.hairStateId = &i
	m.addhairStateId = nil
}

// HairStateId returns the hairStateId value in the mutation.
func (m *BirthSurroundingMutation) HairStateId() (r int, exists bool) {
	v := m.hairStateId
	if v == nil {
		return
	}
	return *v, true
}

// OldHairStateId returns the old hairStateId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldHairStateId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairStateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairStateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairStateId: %w", err)
	}
	return oldValue.HairStateId, nil
}

// AddHairStateId adds i to hairStateId.
func (m *BirthSurroundingMutation) AddHairStateId(i int) {
	if m.addhairStateId != nil {
		*m.addhairStateId += i
	} else {
		m.addhairStateId = &i
	}
}

// AddedHairStateId returns the value that was added to the hairStateId field in this mutation.
func (m *BirthSurroundingMutation) AddedHairStateId() (r int, exists bool) {
	v := m.addhairStateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetHairStateId reset all changes of the "hairStateId" field.
func (m *BirthSurroundingMutation) ResetHairStateId() {
	m.hairStateId = nil
	m.addhairStateId = nil
}

// SetHairStateName sets the hairStateName field.
func (m *BirthSurroundingMutation) SetHairStateName(s string) {
	m.hairStateName = &s
}

// HairStateName returns the hairStateName value in the mutation.
func (m *BirthSurroundingMutation) HairStateName() (r string, exists bool) {
	v := m.hairStateName
	if v == nil {
		return
	}
	return *v, true
}

// OldHairStateName returns the old hairStateName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldHairStateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairStateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairStateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairStateName: %w", err)
	}
	return oldValue.HairStateName, nil
}

// ResetHairStateName reset all changes of the "hairStateName" field.
func (m *BirthSurroundingMutation) ResetHairStateName() {
	m.hairStateName = nil
}

// SetSoilDepth sets the soilDepth field.
func (m *BirthSurroundingMutation) SetSoilDepth(i int) {
	m.soilDepth = &i
	m.addsoilDepth = nil
}

// SoilDepth returns the soilDepth value in the mutation.
func (m *BirthSurroundingMutation) SoilDepth() (r int, exists bool) {
	v := m.soilDepth
	if v == nil {
		return
	}
	return *v, true
}

// OldSoilDepth returns the old soilDepth value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldSoilDepth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSoilDepth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSoilDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoilDepth: %w", err)
	}
	return oldValue.SoilDepth, nil
}

// AddSoilDepth adds i to soilDepth.
func (m *BirthSurroundingMutation) AddSoilDepth(i int) {
	if m.addsoilDepth != nil {
		*m.addsoilDepth += i
	} else {
		m.addsoilDepth = &i
	}
}

// AddedSoilDepth returns the value that was added to the soilDepth field in this mutation.
func (m *BirthSurroundingMutation) AddedSoilDepth() (r int, exists bool) {
	v := m.addsoilDepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoilDepth reset all changes of the "soilDepth" field.
func (m *BirthSurroundingMutation) ResetSoilDepth() {
	m.soilDepth = nil
	m.addsoilDepth = nil
}

// SetSunExposure sets the sunExposure field.
func (m *BirthSurroundingMutation) SetSunExposure(i int) {
	m.sunExposure = &i
	m.addsunExposure = nil
}

// SunExposure returns the sunExposure value in the mutation.
func (m *BirthSurroundingMutation) SunExposure() (r int, exists bool) {
	v := m.sunExposure
	if v == nil {
		return
	}
	return *v, true
}

// OldSunExposure returns the old sunExposure value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldSunExposure(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSunExposure is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSunExposure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSunExposure: %w", err)
	}
	return oldValue.SunExposure, nil
}

// AddSunExposure adds i to sunExposure.
func (m *BirthSurroundingMutation) AddSunExposure(i int) {
	if m.addsunExposure != nil {
		*m.addsunExposure += i
	} else {
		m.addsunExposure = &i
	}
}

// AddedSunExposure returns the value that was added to the sunExposure field in this mutation.
func (m *BirthSurroundingMutation) AddedSunExposure() (r int, exists bool) {
	v := m.addsunExposure
	if v == nil {
		return
	}
	return *v, true
}

// ResetSunExposure reset all changes of the "sunExposure" field.
func (m *BirthSurroundingMutation) ResetSunExposure() {
	m.sunExposure = nil
	m.addsunExposure = nil
}

// SetWalkDistance sets the walkDistance field.
func (m *BirthSurroundingMutation) SetWalkDistance(i int) {
	m.walkDistance = &i
	m.addwalkDistance = nil
}

// WalkDistance returns the walkDistance value in the mutation.
func (m *BirthSurroundingMutation) WalkDistance() (r int, exists bool) {
	v := m.walkDistance
	if v == nil {
		return
	}
	return *v, true
}

// OldWalkDistance returns the old walkDistance value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldWalkDistance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalkDistance is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalkDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalkDistance: %w", err)
	}
	return oldValue.WalkDistance, nil
}

// AddWalkDistance adds i to walkDistance.
func (m *BirthSurroundingMutation) AddWalkDistance(i int) {
	if m.addwalkDistance != nil {
		*m.addwalkDistance += i
	} else {
		m.addwalkDistance = &i
	}
}

// AddedWalkDistance returns the value that was added to the walkDistance field in this mutation.
func (m *BirthSurroundingMutation) AddedWalkDistance() (r int, exists bool) {
	v := m.addwalkDistance
	if v == nil {
		return
	}
	return *v, true
}

// ResetWalkDistance reset all changes of the "walkDistance" field.
func (m *BirthSurroundingMutation) ResetWalkDistance() {
	m.walkDistance = nil
	m.addwalkDistance = nil
}

// SetRained sets the rained field.
func (m *BirthSurroundingMutation) SetRained(i int) {
	m.rained = &i
	m.addrained = nil
}

// Rained returns the rained value in the mutation.
func (m *BirthSurroundingMutation) Rained() (r int, exists bool) {
	v := m.rained
	if v == nil {
		return
	}
	return *v, true
}

// OldRained returns the old rained value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldRained(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRained is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRained requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRained: %w", err)
	}
	return oldValue.Rained, nil
}

// AddRained adds i to rained.
func (m *BirthSurroundingMutation) AddRained(i int) {
	if m.addrained != nil {
		*m.addrained += i
	} else {
		m.addrained = &i
	}
}

// AddedRained returns the value that was added to the rained field in this mutation.
func (m *BirthSurroundingMutation) AddedRained() (r int, exists bool) {
	v := m.addrained
	if v == nil {
		return
	}
	return *v, true
}

// ResetRained reset all changes of the "rained" field.
func (m *BirthSurroundingMutation) ResetRained() {
	m.rained = nil
	m.addrained = nil
}

// SetThIndex sets the thIndex field.
func (m *BirthSurroundingMutation) SetThIndex(f float32) {
	m.thIndex = &f
	m.addthIndex = nil
}

// ThIndex returns the thIndex value in the mutation.
func (m *BirthSurroundingMutation) ThIndex() (r float32, exists bool) {
	v := m.thIndex
	if v == nil {
		return
	}
	return *v, true
}

// OldThIndex returns the old thIndex value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldThIndex(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldThIndex is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldThIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThIndex: %w", err)
	}
	return oldValue.ThIndex, nil
}

// AddThIndex adds f to thIndex.
func (m *BirthSurroundingMutation) AddThIndex(f float32) {
	if m.addthIndex != nil {
		*m.addthIndex += f
	} else {
		m.addthIndex = &f
	}
}

// AddedThIndex returns the value that was added to the thIndex field in this mutation.
func (m *BirthSurroundingMutation) AddedThIndex() (r float32, exists bool) {
	v := m.addthIndex
	if v == nil {
		return
	}
	return *v, true
}

// ResetThIndex reset all changes of the "thIndex" field.
func (m *BirthSurroundingMutation) ResetThIndex() {
	m.thIndex = nil
	m.addthIndex = nil
}

// SetTenantId sets the tenantId field.
func (m *BirthSurroundingMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *BirthSurroundingMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *BirthSurroundingMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *BirthSurroundingMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *BirthSurroundingMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *BirthSurroundingMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *BirthSurroundingMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *BirthSurroundingMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *BirthSurroundingMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *BirthSurroundingMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *BirthSurroundingMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *BirthSurroundingMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *BirthSurroundingMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *BirthSurroundingMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *BirthSurroundingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *BirthSurroundingMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *BirthSurroundingMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *BirthSurroundingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *BirthSurroundingMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *BirthSurroundingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *BirthSurroundingMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *BirthSurroundingMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *BirthSurroundingMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the BirthSurrounding.
// If the BirthSurrounding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BirthSurroundingMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *BirthSurroundingMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *BirthSurroundingMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *BirthSurroundingMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *BirthSurroundingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BirthSurrounding).
func (m *BirthSurroundingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BirthSurroundingMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m.name != nil {
		fields = append(fields, birthsurrounding.FieldName)
	}
	if m.farmId != nil {
		fields = append(fields, birthsurrounding.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, birthsurrounding.FieldFarmName)
	}
	if m.recordTime != nil {
		fields = append(fields, birthsurrounding.FieldRecordTime)
	}
	if m.userId != nil {
		fields = append(fields, birthsurrounding.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, birthsurrounding.FieldUserName)
	}
	if m.temperature != nil {
		fields = append(fields, birthsurrounding.FieldTemperature)
	}
	if m.humidity != nil {
		fields = append(fields, birthsurrounding.FieldHumidity)
	}
	if m.breathRateId != nil {
		fields = append(fields, birthsurrounding.FieldBreathRateId)
	}
	if m.breathRateName != nil {
		fields = append(fields, birthsurrounding.FieldBreathRateName)
	}
	if m.windSpeed != nil {
		fields = append(fields, birthsurrounding.FieldWindSpeed)
	}
	if m.windDirectionId != nil {
		fields = append(fields, birthsurrounding.FieldWindDirectionId)
	}
	if m.windDirection != nil {
		fields = append(fields, birthsurrounding.FieldWindDirection)
	}
	if m.locationChanges != nil {
		fields = append(fields, birthsurrounding.FieldLocationChanges)
	}
	if m.hairStateId != nil {
		fields = append(fields, birthsurrounding.FieldHairStateId)
	}
	if m.hairStateName != nil {
		fields = append(fields, birthsurrounding.FieldHairStateName)
	}
	if m.soilDepth != nil {
		fields = append(fields, birthsurrounding.FieldSoilDepth)
	}
	if m.sunExposure != nil {
		fields = append(fields, birthsurrounding.FieldSunExposure)
	}
	if m.walkDistance != nil {
		fields = append(fields, birthsurrounding.FieldWalkDistance)
	}
	if m.rained != nil {
		fields = append(fields, birthsurrounding.FieldRained)
	}
	if m.thIndex != nil {
		fields = append(fields, birthsurrounding.FieldThIndex)
	}
	if m.tenantId != nil {
		fields = append(fields, birthsurrounding.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, birthsurrounding.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, birthsurrounding.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, birthsurrounding.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, birthsurrounding.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, birthsurrounding.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BirthSurroundingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case birthsurrounding.FieldName:
		return m.Name()
	case birthsurrounding.FieldFarmId:
		return m.FarmId()
	case birthsurrounding.FieldFarmName:
		return m.FarmName()
	case birthsurrounding.FieldRecordTime:
		return m.RecordTime()
	case birthsurrounding.FieldUserId:
		return m.UserId()
	case birthsurrounding.FieldUserName:
		return m.UserName()
	case birthsurrounding.FieldTemperature:
		return m.Temperature()
	case birthsurrounding.FieldHumidity:
		return m.Humidity()
	case birthsurrounding.FieldBreathRateId:
		return m.BreathRateId()
	case birthsurrounding.FieldBreathRateName:
		return m.BreathRateName()
	case birthsurrounding.FieldWindSpeed:
		return m.WindSpeed()
	case birthsurrounding.FieldWindDirectionId:
		return m.WindDirectionId()
	case birthsurrounding.FieldWindDirection:
		return m.WindDirection()
	case birthsurrounding.FieldLocationChanges:
		return m.LocationChanges()
	case birthsurrounding.FieldHairStateId:
		return m.HairStateId()
	case birthsurrounding.FieldHairStateName:
		return m.HairStateName()
	case birthsurrounding.FieldSoilDepth:
		return m.SoilDepth()
	case birthsurrounding.FieldSunExposure:
		return m.SunExposure()
	case birthsurrounding.FieldWalkDistance:
		return m.WalkDistance()
	case birthsurrounding.FieldRained:
		return m.Rained()
	case birthsurrounding.FieldThIndex:
		return m.ThIndex()
	case birthsurrounding.FieldTenantId:
		return m.TenantId()
	case birthsurrounding.FieldTenantName:
		return m.TenantName()
	case birthsurrounding.FieldRemarks:
		return m.Remarks()
	case birthsurrounding.FieldCreatedAt:
		return m.CreatedAt()
	case birthsurrounding.FieldUpdatedAt:
		return m.UpdatedAt()
	case birthsurrounding.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BirthSurroundingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case birthsurrounding.FieldName:
		return m.OldName(ctx)
	case birthsurrounding.FieldFarmId:
		return m.OldFarmId(ctx)
	case birthsurrounding.FieldFarmName:
		return m.OldFarmName(ctx)
	case birthsurrounding.FieldRecordTime:
		return m.OldRecordTime(ctx)
	case birthsurrounding.FieldUserId:
		return m.OldUserId(ctx)
	case birthsurrounding.FieldUserName:
		return m.OldUserName(ctx)
	case birthsurrounding.FieldTemperature:
		return m.OldTemperature(ctx)
	case birthsurrounding.FieldHumidity:
		return m.OldHumidity(ctx)
	case birthsurrounding.FieldBreathRateId:
		return m.OldBreathRateId(ctx)
	case birthsurrounding.FieldBreathRateName:
		return m.OldBreathRateName(ctx)
	case birthsurrounding.FieldWindSpeed:
		return m.OldWindSpeed(ctx)
	case birthsurrounding.FieldWindDirectionId:
		return m.OldWindDirectionId(ctx)
	case birthsurrounding.FieldWindDirection:
		return m.OldWindDirection(ctx)
	case birthsurrounding.FieldLocationChanges:
		return m.OldLocationChanges(ctx)
	case birthsurrounding.FieldHairStateId:
		return m.OldHairStateId(ctx)
	case birthsurrounding.FieldHairStateName:
		return m.OldHairStateName(ctx)
	case birthsurrounding.FieldSoilDepth:
		return m.OldSoilDepth(ctx)
	case birthsurrounding.FieldSunExposure:
		return m.OldSunExposure(ctx)
	case birthsurrounding.FieldWalkDistance:
		return m.OldWalkDistance(ctx)
	case birthsurrounding.FieldRained:
		return m.OldRained(ctx)
	case birthsurrounding.FieldThIndex:
		return m.OldThIndex(ctx)
	case birthsurrounding.FieldTenantId:
		return m.OldTenantId(ctx)
	case birthsurrounding.FieldTenantName:
		return m.OldTenantName(ctx)
	case birthsurrounding.FieldRemarks:
		return m.OldRemarks(ctx)
	case birthsurrounding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case birthsurrounding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case birthsurrounding.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown BirthSurrounding field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BirthSurroundingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case birthsurrounding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case birthsurrounding.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case birthsurrounding.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case birthsurrounding.FieldRecordTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordTime(v)
		return nil
	case birthsurrounding.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case birthsurrounding.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case birthsurrounding.FieldTemperature:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperature(v)
		return nil
	case birthsurrounding.FieldHumidity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHumidity(v)
		return nil
	case birthsurrounding.FieldBreathRateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreathRateId(v)
		return nil
	case birthsurrounding.FieldBreathRateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreathRateName(v)
		return nil
	case birthsurrounding.FieldWindSpeed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindSpeed(v)
		return nil
	case birthsurrounding.FieldWindDirectionId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirectionId(v)
		return nil
	case birthsurrounding.FieldWindDirection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWindDirection(v)
		return nil
	case birthsurrounding.FieldLocationChanges:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationChanges(v)
		return nil
	case birthsurrounding.FieldHairStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairStateId(v)
		return nil
	case birthsurrounding.FieldHairStateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairStateName(v)
		return nil
	case birthsurrounding.FieldSoilDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoilDepth(v)
		return nil
	case birthsurrounding.FieldSunExposure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSunExposure(v)
		return nil
	case birthsurrounding.FieldWalkDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalkDistance(v)
		return nil
	case birthsurrounding.FieldRained:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRained(v)
		return nil
	case birthsurrounding.FieldThIndex:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThIndex(v)
		return nil
	case birthsurrounding.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case birthsurrounding.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case birthsurrounding.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case birthsurrounding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case birthsurrounding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case birthsurrounding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown BirthSurrounding field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BirthSurroundingMutation) AddedFields() []string {
	var fields []string
	if m.addfarmId != nil {
		fields = append(fields, birthsurrounding.FieldFarmId)
	}
	if m.addrecordTime != nil {
		fields = append(fields, birthsurrounding.FieldRecordTime)
	}
	if m.adduserId != nil {
		fields = append(fields, birthsurrounding.FieldUserId)
	}
	if m.addtemperature != nil {
		fields = append(fields, birthsurrounding.FieldTemperature)
	}
	if m.addhumidity != nil {
		fields = append(fields, birthsurrounding.FieldHumidity)
	}
	if m.addbreathRateId != nil {
		fields = append(fields, birthsurrounding.FieldBreathRateId)
	}
	if m.addwindSpeed != nil {
		fields = append(fields, birthsurrounding.FieldWindSpeed)
	}
	if m.addwindDirectionId != nil {
		fields = append(fields, birthsurrounding.FieldWindDirectionId)
	}
	if m.addlocationChanges != nil {
		fields = append(fields, birthsurrounding.FieldLocationChanges)
	}
	if m.addhairStateId != nil {
		fields = append(fields, birthsurrounding.FieldHairStateId)
	}
	if m.addsoilDepth != nil {
		fields = append(fields, birthsurrounding.FieldSoilDepth)
	}
	if m.addsunExposure != nil {
		fields = append(fields, birthsurrounding.FieldSunExposure)
	}
	if m.addwalkDistance != nil {
		fields = append(fields, birthsurrounding.FieldWalkDistance)
	}
	if m.addrained != nil {
		fields = append(fields, birthsurrounding.FieldRained)
	}
	if m.addthIndex != nil {
		fields = append(fields, birthsurrounding.FieldThIndex)
	}
	if m.addtenantId != nil {
		fields = append(fields, birthsurrounding.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, birthsurrounding.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, birthsurrounding.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, birthsurrounding.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BirthSurroundingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case birthsurrounding.FieldFarmId:
		return m.AddedFarmId()
	case birthsurrounding.FieldRecordTime:
		return m.AddedRecordTime()
	case birthsurrounding.FieldUserId:
		return m.AddedUserId()
	case birthsurrounding.FieldTemperature:
		return m.AddedTemperature()
	case birthsurrounding.FieldHumidity:
		return m.AddedHumidity()
	case birthsurrounding.FieldBreathRateId:
		return m.AddedBreathRateId()
	case birthsurrounding.FieldWindSpeed:
		return m.AddedWindSpeed()
	case birthsurrounding.FieldWindDirectionId:
		return m.AddedWindDirectionId()
	case birthsurrounding.FieldLocationChanges:
		return m.AddedLocationChanges()
	case birthsurrounding.FieldHairStateId:
		return m.AddedHairStateId()
	case birthsurrounding.FieldSoilDepth:
		return m.AddedSoilDepth()
	case birthsurrounding.FieldSunExposure:
		return m.AddedSunExposure()
	case birthsurrounding.FieldWalkDistance:
		return m.AddedWalkDistance()
	case birthsurrounding.FieldRained:
		return m.AddedRained()
	case birthsurrounding.FieldThIndex:
		return m.AddedThIndex()
	case birthsurrounding.FieldTenantId:
		return m.AddedTenantId()
	case birthsurrounding.FieldCreatedAt:
		return m.AddedCreatedAt()
	case birthsurrounding.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case birthsurrounding.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BirthSurroundingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case birthsurrounding.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case birthsurrounding.FieldRecordTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecordTime(v)
		return nil
	case birthsurrounding.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case birthsurrounding.FieldTemperature:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperature(v)
		return nil
	case birthsurrounding.FieldHumidity:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHumidity(v)
		return nil
	case birthsurrounding.FieldBreathRateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreathRateId(v)
		return nil
	case birthsurrounding.FieldWindSpeed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindSpeed(v)
		return nil
	case birthsurrounding.FieldWindDirectionId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWindDirectionId(v)
		return nil
	case birthsurrounding.FieldLocationChanges:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocationChanges(v)
		return nil
	case birthsurrounding.FieldHairStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHairStateId(v)
		return nil
	case birthsurrounding.FieldSoilDepth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoilDepth(v)
		return nil
	case birthsurrounding.FieldSunExposure:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSunExposure(v)
		return nil
	case birthsurrounding.FieldWalkDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWalkDistance(v)
		return nil
	case birthsurrounding.FieldRained:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRained(v)
		return nil
	case birthsurrounding.FieldThIndex:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThIndex(v)
		return nil
	case birthsurrounding.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case birthsurrounding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case birthsurrounding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case birthsurrounding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown BirthSurrounding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BirthSurroundingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BirthSurroundingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BirthSurroundingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BirthSurrounding nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BirthSurroundingMutation) ResetField(name string) error {
	switch name {
	case birthsurrounding.FieldName:
		m.ResetName()
		return nil
	case birthsurrounding.FieldFarmId:
		m.ResetFarmId()
		return nil
	case birthsurrounding.FieldFarmName:
		m.ResetFarmName()
		return nil
	case birthsurrounding.FieldRecordTime:
		m.ResetRecordTime()
		return nil
	case birthsurrounding.FieldUserId:
		m.ResetUserId()
		return nil
	case birthsurrounding.FieldUserName:
		m.ResetUserName()
		return nil
	case birthsurrounding.FieldTemperature:
		m.ResetTemperature()
		return nil
	case birthsurrounding.FieldHumidity:
		m.ResetHumidity()
		return nil
	case birthsurrounding.FieldBreathRateId:
		m.ResetBreathRateId()
		return nil
	case birthsurrounding.FieldBreathRateName:
		m.ResetBreathRateName()
		return nil
	case birthsurrounding.FieldWindSpeed:
		m.ResetWindSpeed()
		return nil
	case birthsurrounding.FieldWindDirectionId:
		m.ResetWindDirectionId()
		return nil
	case birthsurrounding.FieldWindDirection:
		m.ResetWindDirection()
		return nil
	case birthsurrounding.FieldLocationChanges:
		m.ResetLocationChanges()
		return nil
	case birthsurrounding.FieldHairStateId:
		m.ResetHairStateId()
		return nil
	case birthsurrounding.FieldHairStateName:
		m.ResetHairStateName()
		return nil
	case birthsurrounding.FieldSoilDepth:
		m.ResetSoilDepth()
		return nil
	case birthsurrounding.FieldSunExposure:
		m.ResetSunExposure()
		return nil
	case birthsurrounding.FieldWalkDistance:
		m.ResetWalkDistance()
		return nil
	case birthsurrounding.FieldRained:
		m.ResetRained()
		return nil
	case birthsurrounding.FieldThIndex:
		m.ResetThIndex()
		return nil
	case birthsurrounding.FieldTenantId:
		m.ResetTenantId()
		return nil
	case birthsurrounding.FieldTenantName:
		m.ResetTenantName()
		return nil
	case birthsurrounding.FieldRemarks:
		m.ResetRemarks()
		return nil
	case birthsurrounding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case birthsurrounding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case birthsurrounding.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown BirthSurrounding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BirthSurroundingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BirthSurroundingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BirthSurroundingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BirthSurroundingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BirthSurroundingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BirthSurroundingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BirthSurroundingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BirthSurrounding unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BirthSurroundingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BirthSurrounding edge %s", name)
}

// BreathRateMutation represents an operation that mutate the BreathRates
// nodes in the graph.
type BreathRateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BreathRate, error)
}

var _ ent.Mutation = (*BreathRateMutation)(nil)

// breathrateOption allows to manage the mutation configuration using functional options.
type breathrateOption func(*BreathRateMutation)

// newBreathRateMutation creates new mutation for $n.Name.
func newBreathRateMutation(c config, op Op, opts ...breathrateOption) *BreathRateMutation {
	m := &BreathRateMutation{
		config:        c,
		op:            op,
		typ:           TypeBreathRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBreathRateID sets the id field of the mutation.
func withBreathRateID(id int64) breathrateOption {
	return func(m *BreathRateMutation) {
		var (
			err   error
			once  sync.Once
			value *BreathRate
		)
		m.oldValue = func(ctx context.Context) (*BreathRate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BreathRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBreathRate sets the old BreathRate of the mutation.
func withBreathRate(node *BreathRate) breathrateOption {
	return func(m *BreathRateMutation) {
		m.oldValue = func(context.Context) (*BreathRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BreathRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BreathRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BreathRateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *BreathRateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BreathRateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the BreathRate.
// If the BreathRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreathRateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BreathRateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *BreathRateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BreathRate).
func (m *BreathRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BreathRateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, breathrate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BreathRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case breathrate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BreathRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case breathrate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown BreathRate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreathRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case breathrate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown BreathRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BreathRateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BreathRateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreathRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BreathRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BreathRateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BreathRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BreathRateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BreathRate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BreathRateMutation) ResetField(name string) error {
	switch name {
	case breathrate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown BreathRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BreathRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BreathRateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BreathRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BreathRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BreathRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BreathRateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BreathRateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BreathRate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BreathRateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BreathRate edge %s", name)
}

// BreedingMutation represents an operation that mutate the Breedings
// nodes in the graph.
type BreedingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	cattleId             *int64
	addcattleId          *int64
	tenantId             *int64
	addtenantId          *int64
	tenantName           *string
	farmId               *int64
	addfarmId            *int64
	farmName             *string
	shedId               *int64
	addshedId            *int64
	shedName             *string
	name                 *string
	earNumber            *string
	times                *int
	addtimes             *int
	breedingAt           *int64
	addbreedingAt        *int64
	breedingTypeId       *int
	addbreedingTypeId    *int
	breedingTypeName     *string
	semenFrozenTypeId    *int64
	addsemenFrozenTypeId *int64
	semenFrozenTypeName  *string
	bullId               *string
	count                *int
	addcount             *int
	userName             *string
	remarks              *string
	createdAt            *int64
	addcreatedAt         *int64
	updatedAt            *int64
	addupdatedAt         *int64
	deleted              *int
	adddeleted           *int
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Breeding, error)
}

var _ ent.Mutation = (*BreedingMutation)(nil)

// breedingOption allows to manage the mutation configuration using functional options.
type breedingOption func(*BreedingMutation)

// newBreedingMutation creates new mutation for $n.Name.
func newBreedingMutation(c config, op Op, opts ...breedingOption) *BreedingMutation {
	m := &BreedingMutation{
		config:        c,
		op:            op,
		typ:           TypeBreeding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBreedingID sets the id field of the mutation.
func withBreedingID(id int64) breedingOption {
	return func(m *BreedingMutation) {
		var (
			err   error
			once  sync.Once
			value *Breeding
		)
		m.oldValue = func(ctx context.Context) (*Breeding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Breeding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBreeding sets the old Breeding of the mutation.
func withBreeding(node *Breeding) breedingOption {
	return func(m *BreedingMutation) {
		m.oldValue = func(context.Context) (*Breeding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BreedingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BreedingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BreedingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *BreedingMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *BreedingMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *BreedingMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *BreedingMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *BreedingMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *BreedingMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *BreedingMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *BreedingMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *BreedingMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *BreedingMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *BreedingMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *BreedingMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *BreedingMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *BreedingMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *BreedingMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *BreedingMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *BreedingMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *BreedingMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *BreedingMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *BreedingMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *BreedingMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *BreedingMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *BreedingMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *BreedingMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *BreedingMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *BreedingMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *BreedingMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *BreedingMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *BreedingMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *BreedingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BreedingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *BreedingMutation) ClearName() {
	m.name = nil
	m.clearedFields[breeding.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *BreedingMutation) NameCleared() bool {
	_, ok := m.clearedFields[breeding.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *BreedingMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, breeding.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *BreedingMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *BreedingMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *BreedingMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *BreedingMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *BreedingMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *BreedingMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *BreedingMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *BreedingMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetBreedingAt sets the breedingAt field.
func (m *BreedingMutation) SetBreedingAt(i int64) {
	m.breedingAt = &i
	m.addbreedingAt = nil
}

// BreedingAt returns the breedingAt value in the mutation.
func (m *BreedingMutation) BreedingAt() (r int64, exists bool) {
	v := m.breedingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingAt returns the old breedingAt value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBreedingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingAt: %w", err)
	}
	return oldValue.BreedingAt, nil
}

// AddBreedingAt adds i to breedingAt.
func (m *BreedingMutation) AddBreedingAt(i int64) {
	if m.addbreedingAt != nil {
		*m.addbreedingAt += i
	} else {
		m.addbreedingAt = &i
	}
}

// AddedBreedingAt returns the value that was added to the breedingAt field in this mutation.
func (m *BreedingMutation) AddedBreedingAt() (r int64, exists bool) {
	v := m.addbreedingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingAt reset all changes of the "breedingAt" field.
func (m *BreedingMutation) ResetBreedingAt() {
	m.breedingAt = nil
	m.addbreedingAt = nil
}

// SetBreedingTypeId sets the breedingTypeId field.
func (m *BreedingMutation) SetBreedingTypeId(i int) {
	m.breedingTypeId = &i
	m.addbreedingTypeId = nil
}

// BreedingTypeId returns the breedingTypeId value in the mutation.
func (m *BreedingMutation) BreedingTypeId() (r int, exists bool) {
	v := m.breedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeId returns the old breedingTypeId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBreedingTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeId: %w", err)
	}
	return oldValue.BreedingTypeId, nil
}

// AddBreedingTypeId adds i to breedingTypeId.
func (m *BreedingMutation) AddBreedingTypeId(i int) {
	if m.addbreedingTypeId != nil {
		*m.addbreedingTypeId += i
	} else {
		m.addbreedingTypeId = &i
	}
}

// AddedBreedingTypeId returns the value that was added to the breedingTypeId field in this mutation.
func (m *BreedingMutation) AddedBreedingTypeId() (r int, exists bool) {
	v := m.addbreedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingTypeId reset all changes of the "breedingTypeId" field.
func (m *BreedingMutation) ResetBreedingTypeId() {
	m.breedingTypeId = nil
	m.addbreedingTypeId = nil
}

// SetBreedingTypeName sets the breedingTypeName field.
func (m *BreedingMutation) SetBreedingTypeName(s string) {
	m.breedingTypeName = &s
}

// BreedingTypeName returns the breedingTypeName value in the mutation.
func (m *BreedingMutation) BreedingTypeName() (r string, exists bool) {
	v := m.breedingTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeName returns the old breedingTypeName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBreedingTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeName: %w", err)
	}
	return oldValue.BreedingTypeName, nil
}

// ResetBreedingTypeName reset all changes of the "breedingTypeName" field.
func (m *BreedingMutation) ResetBreedingTypeName() {
	m.breedingTypeName = nil
}

// SetSemenFrozenTypeId sets the semenFrozenTypeId field.
func (m *BreedingMutation) SetSemenFrozenTypeId(i int64) {
	m.semenFrozenTypeId = &i
	m.addsemenFrozenTypeId = nil
}

// SemenFrozenTypeId returns the semenFrozenTypeId value in the mutation.
func (m *BreedingMutation) SemenFrozenTypeId() (r int64, exists bool) {
	v := m.semenFrozenTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldSemenFrozenTypeId returns the old semenFrozenTypeId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldSemenFrozenTypeId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemenFrozenTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemenFrozenTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemenFrozenTypeId: %w", err)
	}
	return oldValue.SemenFrozenTypeId, nil
}

// AddSemenFrozenTypeId adds i to semenFrozenTypeId.
func (m *BreedingMutation) AddSemenFrozenTypeId(i int64) {
	if m.addsemenFrozenTypeId != nil {
		*m.addsemenFrozenTypeId += i
	} else {
		m.addsemenFrozenTypeId = &i
	}
}

// AddedSemenFrozenTypeId returns the value that was added to the semenFrozenTypeId field in this mutation.
func (m *BreedingMutation) AddedSemenFrozenTypeId() (r int64, exists bool) {
	v := m.addsemenFrozenTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetSemenFrozenTypeId reset all changes of the "semenFrozenTypeId" field.
func (m *BreedingMutation) ResetSemenFrozenTypeId() {
	m.semenFrozenTypeId = nil
	m.addsemenFrozenTypeId = nil
}

// SetSemenFrozenTypeName sets the semenFrozenTypeName field.
func (m *BreedingMutation) SetSemenFrozenTypeName(s string) {
	m.semenFrozenTypeName = &s
}

// SemenFrozenTypeName returns the semenFrozenTypeName value in the mutation.
func (m *BreedingMutation) SemenFrozenTypeName() (r string, exists bool) {
	v := m.semenFrozenTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldSemenFrozenTypeName returns the old semenFrozenTypeName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldSemenFrozenTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSemenFrozenTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSemenFrozenTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSemenFrozenTypeName: %w", err)
	}
	return oldValue.SemenFrozenTypeName, nil
}

// ResetSemenFrozenTypeName reset all changes of the "semenFrozenTypeName" field.
func (m *BreedingMutation) ResetSemenFrozenTypeName() {
	m.semenFrozenTypeName = nil
}

// SetBullId sets the bullId field.
func (m *BreedingMutation) SetBullId(s string) {
	m.bullId = &s
}

// BullId returns the bullId value in the mutation.
func (m *BreedingMutation) BullId() (r string, exists bool) {
	v := m.bullId
	if v == nil {
		return
	}
	return *v, true
}

// OldBullId returns the old bullId value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldBullId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBullId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBullId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBullId: %w", err)
	}
	return oldValue.BullId, nil
}

// ResetBullId reset all changes of the "bullId" field.
func (m *BreedingMutation) ResetBullId() {
	m.bullId = nil
}

// SetCount sets the count field.
func (m *BreedingMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *BreedingMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to count.
func (m *BreedingMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *BreedingMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *BreedingMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetUserName sets the userName field.
func (m *BreedingMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *BreedingMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *BreedingMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *BreedingMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *BreedingMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *BreedingMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *BreedingMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *BreedingMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *BreedingMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *BreedingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *BreedingMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *BreedingMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *BreedingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *BreedingMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *BreedingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *BreedingMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *BreedingMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *BreedingMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Breeding.
// If the Breeding object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *BreedingMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *BreedingMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *BreedingMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *BreedingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Breeding).
func (m *BreedingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BreedingMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.cattleId != nil {
		fields = append(fields, breeding.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, breeding.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, breeding.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, breeding.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, breeding.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, breeding.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, breeding.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, breeding.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, breeding.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, breeding.FieldTimes)
	}
	if m.breedingAt != nil {
		fields = append(fields, breeding.FieldBreedingAt)
	}
	if m.breedingTypeId != nil {
		fields = append(fields, breeding.FieldBreedingTypeId)
	}
	if m.breedingTypeName != nil {
		fields = append(fields, breeding.FieldBreedingTypeName)
	}
	if m.semenFrozenTypeId != nil {
		fields = append(fields, breeding.FieldSemenFrozenTypeId)
	}
	if m.semenFrozenTypeName != nil {
		fields = append(fields, breeding.FieldSemenFrozenTypeName)
	}
	if m.bullId != nil {
		fields = append(fields, breeding.FieldBullId)
	}
	if m.count != nil {
		fields = append(fields, breeding.FieldCount)
	}
	if m.userName != nil {
		fields = append(fields, breeding.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, breeding.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, breeding.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, breeding.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, breeding.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BreedingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case breeding.FieldCattleId:
		return m.CattleId()
	case breeding.FieldTenantId:
		return m.TenantId()
	case breeding.FieldTenantName:
		return m.TenantName()
	case breeding.FieldFarmId:
		return m.FarmId()
	case breeding.FieldFarmName:
		return m.FarmName()
	case breeding.FieldShedId:
		return m.ShedId()
	case breeding.FieldShedName:
		return m.ShedName()
	case breeding.FieldName:
		return m.Name()
	case breeding.FieldEarNumber:
		return m.EarNumber()
	case breeding.FieldTimes:
		return m.Times()
	case breeding.FieldBreedingAt:
		return m.BreedingAt()
	case breeding.FieldBreedingTypeId:
		return m.BreedingTypeId()
	case breeding.FieldBreedingTypeName:
		return m.BreedingTypeName()
	case breeding.FieldSemenFrozenTypeId:
		return m.SemenFrozenTypeId()
	case breeding.FieldSemenFrozenTypeName:
		return m.SemenFrozenTypeName()
	case breeding.FieldBullId:
		return m.BullId()
	case breeding.FieldCount:
		return m.Count()
	case breeding.FieldUserName:
		return m.UserName()
	case breeding.FieldRemarks:
		return m.Remarks()
	case breeding.FieldCreatedAt:
		return m.CreatedAt()
	case breeding.FieldUpdatedAt:
		return m.UpdatedAt()
	case breeding.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BreedingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case breeding.FieldCattleId:
		return m.OldCattleId(ctx)
	case breeding.FieldTenantId:
		return m.OldTenantId(ctx)
	case breeding.FieldTenantName:
		return m.OldTenantName(ctx)
	case breeding.FieldFarmId:
		return m.OldFarmId(ctx)
	case breeding.FieldFarmName:
		return m.OldFarmName(ctx)
	case breeding.FieldShedId:
		return m.OldShedId(ctx)
	case breeding.FieldShedName:
		return m.OldShedName(ctx)
	case breeding.FieldName:
		return m.OldName(ctx)
	case breeding.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case breeding.FieldTimes:
		return m.OldTimes(ctx)
	case breeding.FieldBreedingAt:
		return m.OldBreedingAt(ctx)
	case breeding.FieldBreedingTypeId:
		return m.OldBreedingTypeId(ctx)
	case breeding.FieldBreedingTypeName:
		return m.OldBreedingTypeName(ctx)
	case breeding.FieldSemenFrozenTypeId:
		return m.OldSemenFrozenTypeId(ctx)
	case breeding.FieldSemenFrozenTypeName:
		return m.OldSemenFrozenTypeName(ctx)
	case breeding.FieldBullId:
		return m.OldBullId(ctx)
	case breeding.FieldCount:
		return m.OldCount(ctx)
	case breeding.FieldUserName:
		return m.OldUserName(ctx)
	case breeding.FieldRemarks:
		return m.OldRemarks(ctx)
	case breeding.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case breeding.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case breeding.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Breeding field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case breeding.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case breeding.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case breeding.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case breeding.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case breeding.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case breeding.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case breeding.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case breeding.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case breeding.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case breeding.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case breeding.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingAt(v)
		return nil
	case breeding.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeId(v)
		return nil
	case breeding.FieldBreedingTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeName(v)
		return nil
	case breeding.FieldSemenFrozenTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemenFrozenTypeId(v)
		return nil
	case breeding.FieldSemenFrozenTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSemenFrozenTypeName(v)
		return nil
	case breeding.FieldBullId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBullId(v)
		return nil
	case breeding.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case breeding.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case breeding.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case breeding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case breeding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case breeding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Breeding field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BreedingMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, breeding.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, breeding.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, breeding.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, breeding.FieldShedId)
	}
	if m.addtimes != nil {
		fields = append(fields, breeding.FieldTimes)
	}
	if m.addbreedingAt != nil {
		fields = append(fields, breeding.FieldBreedingAt)
	}
	if m.addbreedingTypeId != nil {
		fields = append(fields, breeding.FieldBreedingTypeId)
	}
	if m.addsemenFrozenTypeId != nil {
		fields = append(fields, breeding.FieldSemenFrozenTypeId)
	}
	if m.addcount != nil {
		fields = append(fields, breeding.FieldCount)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, breeding.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, breeding.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, breeding.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BreedingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case breeding.FieldCattleId:
		return m.AddedCattleId()
	case breeding.FieldTenantId:
		return m.AddedTenantId()
	case breeding.FieldFarmId:
		return m.AddedFarmId()
	case breeding.FieldShedId:
		return m.AddedShedId()
	case breeding.FieldTimes:
		return m.AddedTimes()
	case breeding.FieldBreedingAt:
		return m.AddedBreedingAt()
	case breeding.FieldBreedingTypeId:
		return m.AddedBreedingTypeId()
	case breeding.FieldSemenFrozenTypeId:
		return m.AddedSemenFrozenTypeId()
	case breeding.FieldCount:
		return m.AddedCount()
	case breeding.FieldCreatedAt:
		return m.AddedCreatedAt()
	case breeding.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case breeding.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case breeding.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case breeding.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case breeding.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case breeding.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case breeding.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case breeding.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingAt(v)
		return nil
	case breeding.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingTypeId(v)
		return nil
	case breeding.FieldSemenFrozenTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSemenFrozenTypeId(v)
		return nil
	case breeding.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case breeding.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case breeding.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case breeding.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Breeding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BreedingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(breeding.FieldName) {
		fields = append(fields, breeding.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BreedingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BreedingMutation) ClearField(name string) error {
	switch name {
	case breeding.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Breeding nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BreedingMutation) ResetField(name string) error {
	switch name {
	case breeding.FieldCattleId:
		m.ResetCattleId()
		return nil
	case breeding.FieldTenantId:
		m.ResetTenantId()
		return nil
	case breeding.FieldTenantName:
		m.ResetTenantName()
		return nil
	case breeding.FieldFarmId:
		m.ResetFarmId()
		return nil
	case breeding.FieldFarmName:
		m.ResetFarmName()
		return nil
	case breeding.FieldShedId:
		m.ResetShedId()
		return nil
	case breeding.FieldShedName:
		m.ResetShedName()
		return nil
	case breeding.FieldName:
		m.ResetName()
		return nil
	case breeding.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case breeding.FieldTimes:
		m.ResetTimes()
		return nil
	case breeding.FieldBreedingAt:
		m.ResetBreedingAt()
		return nil
	case breeding.FieldBreedingTypeId:
		m.ResetBreedingTypeId()
		return nil
	case breeding.FieldBreedingTypeName:
		m.ResetBreedingTypeName()
		return nil
	case breeding.FieldSemenFrozenTypeId:
		m.ResetSemenFrozenTypeId()
		return nil
	case breeding.FieldSemenFrozenTypeName:
		m.ResetSemenFrozenTypeName()
		return nil
	case breeding.FieldBullId:
		m.ResetBullId()
		return nil
	case breeding.FieldCount:
		m.ResetCount()
		return nil
	case breeding.FieldUserName:
		m.ResetUserName()
		return nil
	case breeding.FieldRemarks:
		m.ResetRemarks()
		return nil
	case breeding.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case breeding.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case breeding.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Breeding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BreedingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BreedingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BreedingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BreedingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BreedingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BreedingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BreedingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Breeding unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BreedingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Breeding edge %s", name)
}

// BreedingTypeMutation represents an operation that mutate the BreedingTypes
// nodes in the graph.
type BreedingTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BreedingType, error)
}

var _ ent.Mutation = (*BreedingTypeMutation)(nil)

// breedingtypeOption allows to manage the mutation configuration using functional options.
type breedingtypeOption func(*BreedingTypeMutation)

// newBreedingTypeMutation creates new mutation for $n.Name.
func newBreedingTypeMutation(c config, op Op, opts ...breedingtypeOption) *BreedingTypeMutation {
	m := &BreedingTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBreedingType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBreedingTypeID sets the id field of the mutation.
func withBreedingTypeID(id int64) breedingtypeOption {
	return func(m *BreedingTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *BreedingType
		)
		m.oldValue = func(ctx context.Context) (*BreedingType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BreedingType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBreedingType sets the old BreedingType of the mutation.
func withBreedingType(node *BreedingType) breedingtypeOption {
	return func(m *BreedingTypeMutation) {
		m.oldValue = func(context.Context) (*BreedingType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BreedingTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BreedingTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BreedingTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *BreedingTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *BreedingTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the BreedingType.
// If the BreedingType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BreedingTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *BreedingTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *BreedingTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BreedingType).
func (m *BreedingTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BreedingTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, breedingtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BreedingTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case breedingtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BreedingTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case breedingtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown BreedingType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case breedingtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown BreedingType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BreedingTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BreedingTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BreedingTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BreedingType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BreedingTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BreedingTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BreedingTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BreedingType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BreedingTypeMutation) ResetField(name string) error {
	switch name {
	case breedingtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown BreedingType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BreedingTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BreedingTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BreedingTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BreedingTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BreedingTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BreedingTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BreedingTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BreedingType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BreedingTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BreedingType edge %s", name)
}

// CalveMutation represents an operation that mutate the Calves
// nodes in the graph.
type CalveMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	cattleId           *int64
	addcattleId        *int64
	tenantId           *int64
	addtenantId        *int64
	tenantName         *string
	farmId             *int64
	addfarmId          *int64
	farmName           *string
	shedId             *int64
	addshedId          *int64
	shedName           *string
	name               *string
	earNumber          *string
	times              *int
	addtimes           *int
	pregnantAt         *int64
	addpregnantAt      *int64
	calveAt            *int64
	addcalveAt         *int64
	calveTypeId        *int
	addcalveTypeId     *int
	calveTypeName      *string
	calveCate          *int
	addcalveCate       *int
	calveCountId       *int
	addcalveCountId    *int
	calveCountName     *string
	complexity         *int
	addcomplexity      *int
	userName           *string
	babyStatus         *int
	addbabyStatus      *int
	babyGender         *int
	addbabyGender      *int
	babyEarNumber      *int
	addbabyEarNumber   *int
	babyBreedId        *int
	addbabyBreedId     *int
	babyBreedName      *string
	babyHairColorId    *int
	addbabyHairColorId *int
	babyHairColorName  *string
	babyWeight         *float32
	addbabyWeight      *float32
	babyShedId         *int
	addbabyShedId      *int
	babyShedName       *string
	remarks            *string
	createdAt          *int64
	addcreatedAt       *int64
	updatedAt          *int64
	addupdatedAt       *int64
	deleted            *int
	adddeleted         *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Calve, error)
}

var _ ent.Mutation = (*CalveMutation)(nil)

// calveOption allows to manage the mutation configuration using functional options.
type calveOption func(*CalveMutation)

// newCalveMutation creates new mutation for $n.Name.
func newCalveMutation(c config, op Op, opts ...calveOption) *CalveMutation {
	m := &CalveMutation{
		config:        c,
		op:            op,
		typ:           TypeCalve,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalveID sets the id field of the mutation.
func withCalveID(id int64) calveOption {
	return func(m *CalveMutation) {
		var (
			err   error
			once  sync.Once
			value *Calve
		)
		m.oldValue = func(ctx context.Context) (*Calve, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Calve.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalve sets the old Calve of the mutation.
func withCalve(node *Calve) calveOption {
	return func(m *CalveMutation) {
		m.oldValue = func(context.Context) (*Calve, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CalveMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *CalveMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *CalveMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *CalveMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *CalveMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *CalveMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *CalveMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CalveMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CalveMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CalveMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CalveMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CalveMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CalveMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CalveMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *CalveMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *CalveMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *CalveMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *CalveMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *CalveMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *CalveMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *CalveMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *CalveMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *CalveMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *CalveMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *CalveMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *CalveMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *CalveMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *CalveMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CalveMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CalveMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *CalveMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CalveMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CalveMutation) ClearName() {
	m.name = nil
	m.clearedFields[calve.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CalveMutation) NameCleared() bool {
	_, ok := m.clearedFields[calve.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CalveMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, calve.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CalveMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CalveMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CalveMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *CalveMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *CalveMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *CalveMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *CalveMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *CalveMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetPregnantAt sets the pregnantAt field.
func (m *CalveMutation) SetPregnantAt(i int64) {
	m.pregnantAt = &i
	m.addpregnantAt = nil
}

// PregnantAt returns the pregnantAt value in the mutation.
func (m *CalveMutation) PregnantAt() (r int64, exists bool) {
	v := m.pregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnantAt returns the old pregnantAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldPregnantAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnantAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnantAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnantAt: %w", err)
	}
	return oldValue.PregnantAt, nil
}

// AddPregnantAt adds i to pregnantAt.
func (m *CalveMutation) AddPregnantAt(i int64) {
	if m.addpregnantAt != nil {
		*m.addpregnantAt += i
	} else {
		m.addpregnantAt = &i
	}
}

// AddedPregnantAt returns the value that was added to the pregnantAt field in this mutation.
func (m *CalveMutation) AddedPregnantAt() (r int64, exists bool) {
	v := m.addpregnantAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnantAt reset all changes of the "pregnantAt" field.
func (m *CalveMutation) ResetPregnantAt() {
	m.pregnantAt = nil
	m.addpregnantAt = nil
}

// SetCalveAt sets the calveAt field.
func (m *CalveMutation) SetCalveAt(i int64) {
	m.calveAt = &i
	m.addcalveAt = nil
}

// CalveAt returns the calveAt value in the mutation.
func (m *CalveMutation) CalveAt() (r int64, exists bool) {
	v := m.calveAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveAt returns the old calveAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveAt: %w", err)
	}
	return oldValue.CalveAt, nil
}

// AddCalveAt adds i to calveAt.
func (m *CalveMutation) AddCalveAt(i int64) {
	if m.addcalveAt != nil {
		*m.addcalveAt += i
	} else {
		m.addcalveAt = &i
	}
}

// AddedCalveAt returns the value that was added to the calveAt field in this mutation.
func (m *CalveMutation) AddedCalveAt() (r int64, exists bool) {
	v := m.addcalveAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveAt reset all changes of the "calveAt" field.
func (m *CalveMutation) ResetCalveAt() {
	m.calveAt = nil
	m.addcalveAt = nil
}

// SetCalveTypeId sets the calveTypeId field.
func (m *CalveMutation) SetCalveTypeId(i int) {
	m.calveTypeId = &i
	m.addcalveTypeId = nil
}

// CalveTypeId returns the calveTypeId value in the mutation.
func (m *CalveMutation) CalveTypeId() (r int, exists bool) {
	v := m.calveTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveTypeId returns the old calveTypeId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveTypeId: %w", err)
	}
	return oldValue.CalveTypeId, nil
}

// AddCalveTypeId adds i to calveTypeId.
func (m *CalveMutation) AddCalveTypeId(i int) {
	if m.addcalveTypeId != nil {
		*m.addcalveTypeId += i
	} else {
		m.addcalveTypeId = &i
	}
}

// AddedCalveTypeId returns the value that was added to the calveTypeId field in this mutation.
func (m *CalveMutation) AddedCalveTypeId() (r int, exists bool) {
	v := m.addcalveTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveTypeId reset all changes of the "calveTypeId" field.
func (m *CalveMutation) ResetCalveTypeId() {
	m.calveTypeId = nil
	m.addcalveTypeId = nil
}

// SetCalveTypeName sets the calveTypeName field.
func (m *CalveMutation) SetCalveTypeName(s string) {
	m.calveTypeName = &s
}

// CalveTypeName returns the calveTypeName value in the mutation.
func (m *CalveMutation) CalveTypeName() (r string, exists bool) {
	v := m.calveTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveTypeName returns the old calveTypeName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveTypeName: %w", err)
	}
	return oldValue.CalveTypeName, nil
}

// ResetCalveTypeName reset all changes of the "calveTypeName" field.
func (m *CalveMutation) ResetCalveTypeName() {
	m.calveTypeName = nil
}

// SetCalveCate sets the calveCate field.
func (m *CalveMutation) SetCalveCate(i int) {
	m.calveCate = &i
	m.addcalveCate = nil
}

// CalveCate returns the calveCate value in the mutation.
func (m *CalveMutation) CalveCate() (r int, exists bool) {
	v := m.calveCate
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveCate returns the old calveCate value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveCate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveCate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveCate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveCate: %w", err)
	}
	return oldValue.CalveCate, nil
}

// AddCalveCate adds i to calveCate.
func (m *CalveMutation) AddCalveCate(i int) {
	if m.addcalveCate != nil {
		*m.addcalveCate += i
	} else {
		m.addcalveCate = &i
	}
}

// AddedCalveCate returns the value that was added to the calveCate field in this mutation.
func (m *CalveMutation) AddedCalveCate() (r int, exists bool) {
	v := m.addcalveCate
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveCate reset all changes of the "calveCate" field.
func (m *CalveMutation) ResetCalveCate() {
	m.calveCate = nil
	m.addcalveCate = nil
}

// SetCalveCountId sets the calveCountId field.
func (m *CalveMutation) SetCalveCountId(i int) {
	m.calveCountId = &i
	m.addcalveCountId = nil
}

// CalveCountId returns the calveCountId value in the mutation.
func (m *CalveMutation) CalveCountId() (r int, exists bool) {
	v := m.calveCountId
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveCountId returns the old calveCountId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveCountId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveCountId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveCountId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveCountId: %w", err)
	}
	return oldValue.CalveCountId, nil
}

// AddCalveCountId adds i to calveCountId.
func (m *CalveMutation) AddCalveCountId(i int) {
	if m.addcalveCountId != nil {
		*m.addcalveCountId += i
	} else {
		m.addcalveCountId = &i
	}
}

// AddedCalveCountId returns the value that was added to the calveCountId field in this mutation.
func (m *CalveMutation) AddedCalveCountId() (r int, exists bool) {
	v := m.addcalveCountId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCalveCountId reset all changes of the "calveCountId" field.
func (m *CalveMutation) ResetCalveCountId() {
	m.calveCountId = nil
	m.addcalveCountId = nil
}

// SetCalveCountName sets the calveCountName field.
func (m *CalveMutation) SetCalveCountName(s string) {
	m.calveCountName = &s
}

// CalveCountName returns the calveCountName value in the mutation.
func (m *CalveMutation) CalveCountName() (r string, exists bool) {
	v := m.calveCountName
	if v == nil {
		return
	}
	return *v, true
}

// OldCalveCountName returns the old calveCountName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCalveCountName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCalveCountName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCalveCountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalveCountName: %w", err)
	}
	return oldValue.CalveCountName, nil
}

// ResetCalveCountName reset all changes of the "calveCountName" field.
func (m *CalveMutation) ResetCalveCountName() {
	m.calveCountName = nil
}

// SetComplexity sets the complexity field.
func (m *CalveMutation) SetComplexity(i int) {
	m.complexity = &i
	m.addcomplexity = nil
}

// Complexity returns the complexity value in the mutation.
func (m *CalveMutation) Complexity() (r int, exists bool) {
	v := m.complexity
	if v == nil {
		return
	}
	return *v, true
}

// OldComplexity returns the old complexity value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldComplexity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldComplexity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldComplexity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplexity: %w", err)
	}
	return oldValue.Complexity, nil
}

// AddComplexity adds i to complexity.
func (m *CalveMutation) AddComplexity(i int) {
	if m.addcomplexity != nil {
		*m.addcomplexity += i
	} else {
		m.addcomplexity = &i
	}
}

// AddedComplexity returns the value that was added to the complexity field in this mutation.
func (m *CalveMutation) AddedComplexity() (r int, exists bool) {
	v := m.addcomplexity
	if v == nil {
		return
	}
	return *v, true
}

// ResetComplexity reset all changes of the "complexity" field.
func (m *CalveMutation) ResetComplexity() {
	m.complexity = nil
	m.addcomplexity = nil
}

// SetUserName sets the userName field.
func (m *CalveMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CalveMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CalveMutation) ResetUserName() {
	m.userName = nil
}

// SetBabyStatus sets the babyStatus field.
func (m *CalveMutation) SetBabyStatus(i int) {
	m.babyStatus = &i
	m.addbabyStatus = nil
}

// BabyStatus returns the babyStatus value in the mutation.
func (m *CalveMutation) BabyStatus() (r int, exists bool) {
	v := m.babyStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyStatus returns the old babyStatus value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyStatus: %w", err)
	}
	return oldValue.BabyStatus, nil
}

// AddBabyStatus adds i to babyStatus.
func (m *CalveMutation) AddBabyStatus(i int) {
	if m.addbabyStatus != nil {
		*m.addbabyStatus += i
	} else {
		m.addbabyStatus = &i
	}
}

// AddedBabyStatus returns the value that was added to the babyStatus field in this mutation.
func (m *CalveMutation) AddedBabyStatus() (r int, exists bool) {
	v := m.addbabyStatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyStatus reset all changes of the "babyStatus" field.
func (m *CalveMutation) ResetBabyStatus() {
	m.babyStatus = nil
	m.addbabyStatus = nil
}

// SetBabyGender sets the babyGender field.
func (m *CalveMutation) SetBabyGender(i int) {
	m.babyGender = &i
	m.addbabyGender = nil
}

// BabyGender returns the babyGender value in the mutation.
func (m *CalveMutation) BabyGender() (r int, exists bool) {
	v := m.babyGender
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyGender returns the old babyGender value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyGender(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyGender: %w", err)
	}
	return oldValue.BabyGender, nil
}

// AddBabyGender adds i to babyGender.
func (m *CalveMutation) AddBabyGender(i int) {
	if m.addbabyGender != nil {
		*m.addbabyGender += i
	} else {
		m.addbabyGender = &i
	}
}

// AddedBabyGender returns the value that was added to the babyGender field in this mutation.
func (m *CalveMutation) AddedBabyGender() (r int, exists bool) {
	v := m.addbabyGender
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyGender reset all changes of the "babyGender" field.
func (m *CalveMutation) ResetBabyGender() {
	m.babyGender = nil
	m.addbabyGender = nil
}

// SetBabyEarNumber sets the babyEarNumber field.
func (m *CalveMutation) SetBabyEarNumber(i int) {
	m.babyEarNumber = &i
	m.addbabyEarNumber = nil
}

// BabyEarNumber returns the babyEarNumber value in the mutation.
func (m *CalveMutation) BabyEarNumber() (r int, exists bool) {
	v := m.babyEarNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyEarNumber returns the old babyEarNumber value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyEarNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyEarNumber: %w", err)
	}
	return oldValue.BabyEarNumber, nil
}

// AddBabyEarNumber adds i to babyEarNumber.
func (m *CalveMutation) AddBabyEarNumber(i int) {
	if m.addbabyEarNumber != nil {
		*m.addbabyEarNumber += i
	} else {
		m.addbabyEarNumber = &i
	}
}

// AddedBabyEarNumber returns the value that was added to the babyEarNumber field in this mutation.
func (m *CalveMutation) AddedBabyEarNumber() (r int, exists bool) {
	v := m.addbabyEarNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyEarNumber reset all changes of the "babyEarNumber" field.
func (m *CalveMutation) ResetBabyEarNumber() {
	m.babyEarNumber = nil
	m.addbabyEarNumber = nil
}

// SetBabyBreedId sets the babyBreedId field.
func (m *CalveMutation) SetBabyBreedId(i int) {
	m.babyBreedId = &i
	m.addbabyBreedId = nil
}

// BabyBreedId returns the babyBreedId value in the mutation.
func (m *CalveMutation) BabyBreedId() (r int, exists bool) {
	v := m.babyBreedId
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyBreedId returns the old babyBreedId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyBreedId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyBreedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyBreedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyBreedId: %w", err)
	}
	return oldValue.BabyBreedId, nil
}

// AddBabyBreedId adds i to babyBreedId.
func (m *CalveMutation) AddBabyBreedId(i int) {
	if m.addbabyBreedId != nil {
		*m.addbabyBreedId += i
	} else {
		m.addbabyBreedId = &i
	}
}

// AddedBabyBreedId returns the value that was added to the babyBreedId field in this mutation.
func (m *CalveMutation) AddedBabyBreedId() (r int, exists bool) {
	v := m.addbabyBreedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyBreedId reset all changes of the "babyBreedId" field.
func (m *CalveMutation) ResetBabyBreedId() {
	m.babyBreedId = nil
	m.addbabyBreedId = nil
}

// SetBabyBreedName sets the babyBreedName field.
func (m *CalveMutation) SetBabyBreedName(s string) {
	m.babyBreedName = &s
}

// BabyBreedName returns the babyBreedName value in the mutation.
func (m *CalveMutation) BabyBreedName() (r string, exists bool) {
	v := m.babyBreedName
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyBreedName returns the old babyBreedName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyBreedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyBreedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyBreedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyBreedName: %w", err)
	}
	return oldValue.BabyBreedName, nil
}

// ResetBabyBreedName reset all changes of the "babyBreedName" field.
func (m *CalveMutation) ResetBabyBreedName() {
	m.babyBreedName = nil
}

// SetBabyHairColorId sets the babyHairColorId field.
func (m *CalveMutation) SetBabyHairColorId(i int) {
	m.babyHairColorId = &i
	m.addbabyHairColorId = nil
}

// BabyHairColorId returns the babyHairColorId value in the mutation.
func (m *CalveMutation) BabyHairColorId() (r int, exists bool) {
	v := m.babyHairColorId
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyHairColorId returns the old babyHairColorId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyHairColorId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyHairColorId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyHairColorId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyHairColorId: %w", err)
	}
	return oldValue.BabyHairColorId, nil
}

// AddBabyHairColorId adds i to babyHairColorId.
func (m *CalveMutation) AddBabyHairColorId(i int) {
	if m.addbabyHairColorId != nil {
		*m.addbabyHairColorId += i
	} else {
		m.addbabyHairColorId = &i
	}
}

// AddedBabyHairColorId returns the value that was added to the babyHairColorId field in this mutation.
func (m *CalveMutation) AddedBabyHairColorId() (r int, exists bool) {
	v := m.addbabyHairColorId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyHairColorId reset all changes of the "babyHairColorId" field.
func (m *CalveMutation) ResetBabyHairColorId() {
	m.babyHairColorId = nil
	m.addbabyHairColorId = nil
}

// SetBabyHairColorName sets the babyHairColorName field.
func (m *CalveMutation) SetBabyHairColorName(s string) {
	m.babyHairColorName = &s
}

// BabyHairColorName returns the babyHairColorName value in the mutation.
func (m *CalveMutation) BabyHairColorName() (r string, exists bool) {
	v := m.babyHairColorName
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyHairColorName returns the old babyHairColorName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyHairColorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyHairColorName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyHairColorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyHairColorName: %w", err)
	}
	return oldValue.BabyHairColorName, nil
}

// ResetBabyHairColorName reset all changes of the "babyHairColorName" field.
func (m *CalveMutation) ResetBabyHairColorName() {
	m.babyHairColorName = nil
}

// SetBabyWeight sets the babyWeight field.
func (m *CalveMutation) SetBabyWeight(f float32) {
	m.babyWeight = &f
	m.addbabyWeight = nil
}

// BabyWeight returns the babyWeight value in the mutation.
func (m *CalveMutation) BabyWeight() (r float32, exists bool) {
	v := m.babyWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyWeight returns the old babyWeight value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyWeight: %w", err)
	}
	return oldValue.BabyWeight, nil
}

// AddBabyWeight adds f to babyWeight.
func (m *CalveMutation) AddBabyWeight(f float32) {
	if m.addbabyWeight != nil {
		*m.addbabyWeight += f
	} else {
		m.addbabyWeight = &f
	}
}

// AddedBabyWeight returns the value that was added to the babyWeight field in this mutation.
func (m *CalveMutation) AddedBabyWeight() (r float32, exists bool) {
	v := m.addbabyWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyWeight reset all changes of the "babyWeight" field.
func (m *CalveMutation) ResetBabyWeight() {
	m.babyWeight = nil
	m.addbabyWeight = nil
}

// SetBabyShedId sets the babyShedId field.
func (m *CalveMutation) SetBabyShedId(i int) {
	m.babyShedId = &i
	m.addbabyShedId = nil
}

// BabyShedId returns the babyShedId value in the mutation.
func (m *CalveMutation) BabyShedId() (r int, exists bool) {
	v := m.babyShedId
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyShedId returns the old babyShedId value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyShedId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyShedId: %w", err)
	}
	return oldValue.BabyShedId, nil
}

// AddBabyShedId adds i to babyShedId.
func (m *CalveMutation) AddBabyShedId(i int) {
	if m.addbabyShedId != nil {
		*m.addbabyShedId += i
	} else {
		m.addbabyShedId = &i
	}
}

// AddedBabyShedId returns the value that was added to the babyShedId field in this mutation.
func (m *CalveMutation) AddedBabyShedId() (r int, exists bool) {
	v := m.addbabyShedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBabyShedId reset all changes of the "babyShedId" field.
func (m *CalveMutation) ResetBabyShedId() {
	m.babyShedId = nil
	m.addbabyShedId = nil
}

// SetBabyShedName sets the babyShedName field.
func (m *CalveMutation) SetBabyShedName(s string) {
	m.babyShedName = &s
}

// BabyShedName returns the babyShedName value in the mutation.
func (m *CalveMutation) BabyShedName() (r string, exists bool) {
	v := m.babyShedName
	if v == nil {
		return
	}
	return *v, true
}

// OldBabyShedName returns the old babyShedName value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldBabyShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBabyShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBabyShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBabyShedName: %w", err)
	}
	return oldValue.BabyShedName, nil
}

// ResetBabyShedName reset all changes of the "babyShedName" field.
func (m *CalveMutation) ResetBabyShedName() {
	m.babyShedName = nil
}

// SetRemarks sets the remarks field.
func (m *CalveMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CalveMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CalveMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CalveMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CalveMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CalveMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CalveMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CalveMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CalveMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CalveMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CalveMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CalveMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CalveMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CalveMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CalveMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Calve.
// If the Calve object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CalveMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CalveMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CalveMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CalveMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Calve).
func (m *CalveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CalveMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.cattleId != nil {
		fields = append(fields, calve.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, calve.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, calve.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, calve.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, calve.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, calve.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, calve.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, calve.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, calve.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, calve.FieldTimes)
	}
	if m.pregnantAt != nil {
		fields = append(fields, calve.FieldPregnantAt)
	}
	if m.calveAt != nil {
		fields = append(fields, calve.FieldCalveAt)
	}
	if m.calveTypeId != nil {
		fields = append(fields, calve.FieldCalveTypeId)
	}
	if m.calveTypeName != nil {
		fields = append(fields, calve.FieldCalveTypeName)
	}
	if m.calveCate != nil {
		fields = append(fields, calve.FieldCalveCate)
	}
	if m.calveCountId != nil {
		fields = append(fields, calve.FieldCalveCountId)
	}
	if m.calveCountName != nil {
		fields = append(fields, calve.FieldCalveCountName)
	}
	if m.complexity != nil {
		fields = append(fields, calve.FieldComplexity)
	}
	if m.userName != nil {
		fields = append(fields, calve.FieldUserName)
	}
	if m.babyStatus != nil {
		fields = append(fields, calve.FieldBabyStatus)
	}
	if m.babyGender != nil {
		fields = append(fields, calve.FieldBabyGender)
	}
	if m.babyEarNumber != nil {
		fields = append(fields, calve.FieldBabyEarNumber)
	}
	if m.babyBreedId != nil {
		fields = append(fields, calve.FieldBabyBreedId)
	}
	if m.babyBreedName != nil {
		fields = append(fields, calve.FieldBabyBreedName)
	}
	if m.babyHairColorId != nil {
		fields = append(fields, calve.FieldBabyHairColorId)
	}
	if m.babyHairColorName != nil {
		fields = append(fields, calve.FieldBabyHairColorName)
	}
	if m.babyWeight != nil {
		fields = append(fields, calve.FieldBabyWeight)
	}
	if m.babyShedId != nil {
		fields = append(fields, calve.FieldBabyShedId)
	}
	if m.babyShedName != nil {
		fields = append(fields, calve.FieldBabyShedName)
	}
	if m.remarks != nil {
		fields = append(fields, calve.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, calve.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, calve.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, calve.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CalveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calve.FieldCattleId:
		return m.CattleId()
	case calve.FieldTenantId:
		return m.TenantId()
	case calve.FieldTenantName:
		return m.TenantName()
	case calve.FieldFarmId:
		return m.FarmId()
	case calve.FieldFarmName:
		return m.FarmName()
	case calve.FieldShedId:
		return m.ShedId()
	case calve.FieldShedName:
		return m.ShedName()
	case calve.FieldName:
		return m.Name()
	case calve.FieldEarNumber:
		return m.EarNumber()
	case calve.FieldTimes:
		return m.Times()
	case calve.FieldPregnantAt:
		return m.PregnantAt()
	case calve.FieldCalveAt:
		return m.CalveAt()
	case calve.FieldCalveTypeId:
		return m.CalveTypeId()
	case calve.FieldCalveTypeName:
		return m.CalveTypeName()
	case calve.FieldCalveCate:
		return m.CalveCate()
	case calve.FieldCalveCountId:
		return m.CalveCountId()
	case calve.FieldCalveCountName:
		return m.CalveCountName()
	case calve.FieldComplexity:
		return m.Complexity()
	case calve.FieldUserName:
		return m.UserName()
	case calve.FieldBabyStatus:
		return m.BabyStatus()
	case calve.FieldBabyGender:
		return m.BabyGender()
	case calve.FieldBabyEarNumber:
		return m.BabyEarNumber()
	case calve.FieldBabyBreedId:
		return m.BabyBreedId()
	case calve.FieldBabyBreedName:
		return m.BabyBreedName()
	case calve.FieldBabyHairColorId:
		return m.BabyHairColorId()
	case calve.FieldBabyHairColorName:
		return m.BabyHairColorName()
	case calve.FieldBabyWeight:
		return m.BabyWeight()
	case calve.FieldBabyShedId:
		return m.BabyShedId()
	case calve.FieldBabyShedName:
		return m.BabyShedName()
	case calve.FieldRemarks:
		return m.Remarks()
	case calve.FieldCreatedAt:
		return m.CreatedAt()
	case calve.FieldUpdatedAt:
		return m.UpdatedAt()
	case calve.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CalveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calve.FieldCattleId:
		return m.OldCattleId(ctx)
	case calve.FieldTenantId:
		return m.OldTenantId(ctx)
	case calve.FieldTenantName:
		return m.OldTenantName(ctx)
	case calve.FieldFarmId:
		return m.OldFarmId(ctx)
	case calve.FieldFarmName:
		return m.OldFarmName(ctx)
	case calve.FieldShedId:
		return m.OldShedId(ctx)
	case calve.FieldShedName:
		return m.OldShedName(ctx)
	case calve.FieldName:
		return m.OldName(ctx)
	case calve.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case calve.FieldTimes:
		return m.OldTimes(ctx)
	case calve.FieldPregnantAt:
		return m.OldPregnantAt(ctx)
	case calve.FieldCalveAt:
		return m.OldCalveAt(ctx)
	case calve.FieldCalveTypeId:
		return m.OldCalveTypeId(ctx)
	case calve.FieldCalveTypeName:
		return m.OldCalveTypeName(ctx)
	case calve.FieldCalveCate:
		return m.OldCalveCate(ctx)
	case calve.FieldCalveCountId:
		return m.OldCalveCountId(ctx)
	case calve.FieldCalveCountName:
		return m.OldCalveCountName(ctx)
	case calve.FieldComplexity:
		return m.OldComplexity(ctx)
	case calve.FieldUserName:
		return m.OldUserName(ctx)
	case calve.FieldBabyStatus:
		return m.OldBabyStatus(ctx)
	case calve.FieldBabyGender:
		return m.OldBabyGender(ctx)
	case calve.FieldBabyEarNumber:
		return m.OldBabyEarNumber(ctx)
	case calve.FieldBabyBreedId:
		return m.OldBabyBreedId(ctx)
	case calve.FieldBabyBreedName:
		return m.OldBabyBreedName(ctx)
	case calve.FieldBabyHairColorId:
		return m.OldBabyHairColorId(ctx)
	case calve.FieldBabyHairColorName:
		return m.OldBabyHairColorName(ctx)
	case calve.FieldBabyWeight:
		return m.OldBabyWeight(ctx)
	case calve.FieldBabyShedId:
		return m.OldBabyShedId(ctx)
	case calve.FieldBabyShedName:
		return m.OldBabyShedName(ctx)
	case calve.FieldRemarks:
		return m.OldRemarks(ctx)
	case calve.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case calve.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case calve.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Calve field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calve.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case calve.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case calve.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case calve.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case calve.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case calve.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case calve.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case calve.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case calve.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case calve.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case calve.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnantAt(v)
		return nil
	case calve.FieldCalveAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveAt(v)
		return nil
	case calve.FieldCalveTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveTypeId(v)
		return nil
	case calve.FieldCalveTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveTypeName(v)
		return nil
	case calve.FieldCalveCate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveCate(v)
		return nil
	case calve.FieldCalveCountId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveCountId(v)
		return nil
	case calve.FieldCalveCountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalveCountName(v)
		return nil
	case calve.FieldComplexity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplexity(v)
		return nil
	case calve.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case calve.FieldBabyStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyStatus(v)
		return nil
	case calve.FieldBabyGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyGender(v)
		return nil
	case calve.FieldBabyEarNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyEarNumber(v)
		return nil
	case calve.FieldBabyBreedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyBreedId(v)
		return nil
	case calve.FieldBabyBreedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyBreedName(v)
		return nil
	case calve.FieldBabyHairColorId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyHairColorId(v)
		return nil
	case calve.FieldBabyHairColorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyHairColorName(v)
		return nil
	case calve.FieldBabyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyWeight(v)
		return nil
	case calve.FieldBabyShedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyShedId(v)
		return nil
	case calve.FieldBabyShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBabyShedName(v)
		return nil
	case calve.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case calve.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case calve.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case calve.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Calve field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CalveMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, calve.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, calve.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, calve.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, calve.FieldShedId)
	}
	if m.addtimes != nil {
		fields = append(fields, calve.FieldTimes)
	}
	if m.addpregnantAt != nil {
		fields = append(fields, calve.FieldPregnantAt)
	}
	if m.addcalveAt != nil {
		fields = append(fields, calve.FieldCalveAt)
	}
	if m.addcalveTypeId != nil {
		fields = append(fields, calve.FieldCalveTypeId)
	}
	if m.addcalveCate != nil {
		fields = append(fields, calve.FieldCalveCate)
	}
	if m.addcalveCountId != nil {
		fields = append(fields, calve.FieldCalveCountId)
	}
	if m.addcomplexity != nil {
		fields = append(fields, calve.FieldComplexity)
	}
	if m.addbabyStatus != nil {
		fields = append(fields, calve.FieldBabyStatus)
	}
	if m.addbabyGender != nil {
		fields = append(fields, calve.FieldBabyGender)
	}
	if m.addbabyEarNumber != nil {
		fields = append(fields, calve.FieldBabyEarNumber)
	}
	if m.addbabyBreedId != nil {
		fields = append(fields, calve.FieldBabyBreedId)
	}
	if m.addbabyHairColorId != nil {
		fields = append(fields, calve.FieldBabyHairColorId)
	}
	if m.addbabyWeight != nil {
		fields = append(fields, calve.FieldBabyWeight)
	}
	if m.addbabyShedId != nil {
		fields = append(fields, calve.FieldBabyShedId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, calve.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, calve.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, calve.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CalveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case calve.FieldCattleId:
		return m.AddedCattleId()
	case calve.FieldTenantId:
		return m.AddedTenantId()
	case calve.FieldFarmId:
		return m.AddedFarmId()
	case calve.FieldShedId:
		return m.AddedShedId()
	case calve.FieldTimes:
		return m.AddedTimes()
	case calve.FieldPregnantAt:
		return m.AddedPregnantAt()
	case calve.FieldCalveAt:
		return m.AddedCalveAt()
	case calve.FieldCalveTypeId:
		return m.AddedCalveTypeId()
	case calve.FieldCalveCate:
		return m.AddedCalveCate()
	case calve.FieldCalveCountId:
		return m.AddedCalveCountId()
	case calve.FieldComplexity:
		return m.AddedComplexity()
	case calve.FieldBabyStatus:
		return m.AddedBabyStatus()
	case calve.FieldBabyGender:
		return m.AddedBabyGender()
	case calve.FieldBabyEarNumber:
		return m.AddedBabyEarNumber()
	case calve.FieldBabyBreedId:
		return m.AddedBabyBreedId()
	case calve.FieldBabyHairColorId:
		return m.AddedBabyHairColorId()
	case calve.FieldBabyWeight:
		return m.AddedBabyWeight()
	case calve.FieldBabyShedId:
		return m.AddedBabyShedId()
	case calve.FieldCreatedAt:
		return m.AddedCreatedAt()
	case calve.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case calve.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveMutation) AddField(name string, value ent.Value) error {
	switch name {
	case calve.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case calve.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case calve.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case calve.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case calve.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case calve.FieldPregnantAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnantAt(v)
		return nil
	case calve.FieldCalveAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveAt(v)
		return nil
	case calve.FieldCalveTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveTypeId(v)
		return nil
	case calve.FieldCalveCate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveCate(v)
		return nil
	case calve.FieldCalveCountId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCalveCountId(v)
		return nil
	case calve.FieldComplexity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddComplexity(v)
		return nil
	case calve.FieldBabyStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyStatus(v)
		return nil
	case calve.FieldBabyGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyGender(v)
		return nil
	case calve.FieldBabyEarNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyEarNumber(v)
		return nil
	case calve.FieldBabyBreedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyBreedId(v)
		return nil
	case calve.FieldBabyHairColorId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyHairColorId(v)
		return nil
	case calve.FieldBabyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyWeight(v)
		return nil
	case calve.FieldBabyShedId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBabyShedId(v)
		return nil
	case calve.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case calve.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case calve.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Calve numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CalveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(calve.FieldName) {
		fields = append(fields, calve.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CalveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalveMutation) ClearField(name string) error {
	switch name {
	case calve.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Calve nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CalveMutation) ResetField(name string) error {
	switch name {
	case calve.FieldCattleId:
		m.ResetCattleId()
		return nil
	case calve.FieldTenantId:
		m.ResetTenantId()
		return nil
	case calve.FieldTenantName:
		m.ResetTenantName()
		return nil
	case calve.FieldFarmId:
		m.ResetFarmId()
		return nil
	case calve.FieldFarmName:
		m.ResetFarmName()
		return nil
	case calve.FieldShedId:
		m.ResetShedId()
		return nil
	case calve.FieldShedName:
		m.ResetShedName()
		return nil
	case calve.FieldName:
		m.ResetName()
		return nil
	case calve.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case calve.FieldTimes:
		m.ResetTimes()
		return nil
	case calve.FieldPregnantAt:
		m.ResetPregnantAt()
		return nil
	case calve.FieldCalveAt:
		m.ResetCalveAt()
		return nil
	case calve.FieldCalveTypeId:
		m.ResetCalveTypeId()
		return nil
	case calve.FieldCalveTypeName:
		m.ResetCalveTypeName()
		return nil
	case calve.FieldCalveCate:
		m.ResetCalveCate()
		return nil
	case calve.FieldCalveCountId:
		m.ResetCalveCountId()
		return nil
	case calve.FieldCalveCountName:
		m.ResetCalveCountName()
		return nil
	case calve.FieldComplexity:
		m.ResetComplexity()
		return nil
	case calve.FieldUserName:
		m.ResetUserName()
		return nil
	case calve.FieldBabyStatus:
		m.ResetBabyStatus()
		return nil
	case calve.FieldBabyGender:
		m.ResetBabyGender()
		return nil
	case calve.FieldBabyEarNumber:
		m.ResetBabyEarNumber()
		return nil
	case calve.FieldBabyBreedId:
		m.ResetBabyBreedId()
		return nil
	case calve.FieldBabyBreedName:
		m.ResetBabyBreedName()
		return nil
	case calve.FieldBabyHairColorId:
		m.ResetBabyHairColorId()
		return nil
	case calve.FieldBabyHairColorName:
		m.ResetBabyHairColorName()
		return nil
	case calve.FieldBabyWeight:
		m.ResetBabyWeight()
		return nil
	case calve.FieldBabyShedId:
		m.ResetBabyShedId()
		return nil
	case calve.FieldBabyShedName:
		m.ResetBabyShedName()
		return nil
	case calve.FieldRemarks:
		m.ResetRemarks()
		return nil
	case calve.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case calve.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case calve.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Calve field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CalveMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CalveMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CalveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CalveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CalveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CalveMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CalveMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Calve unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CalveMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Calve edge %s", name)
}

// CalveCountMutation represents an operation that mutate the CalveCounts
// nodes in the graph.
type CalveCountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CalveCount, error)
}

var _ ent.Mutation = (*CalveCountMutation)(nil)

// calvecountOption allows to manage the mutation configuration using functional options.
type calvecountOption func(*CalveCountMutation)

// newCalveCountMutation creates new mutation for $n.Name.
func newCalveCountMutation(c config, op Op, opts ...calvecountOption) *CalveCountMutation {
	m := &CalveCountMutation{
		config:        c,
		op:            op,
		typ:           TypeCalveCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalveCountID sets the id field of the mutation.
func withCalveCountID(id int64) calvecountOption {
	return func(m *CalveCountMutation) {
		var (
			err   error
			once  sync.Once
			value *CalveCount
		)
		m.oldValue = func(ctx context.Context) (*CalveCount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CalveCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalveCount sets the old CalveCount of the mutation.
func withCalveCount(node *CalveCount) calvecountOption {
	return func(m *CalveCountMutation) {
		m.oldValue = func(context.Context) (*CalveCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalveCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalveCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CalveCountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CalveCountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CalveCountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CalveCount.
// If the CalveCount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveCountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CalveCountMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CalveCountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CalveCount).
func (m *CalveCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CalveCountMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, calvecount.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CalveCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calvecount.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CalveCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calvecount.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CalveCount field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calvecount.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CalveCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CalveCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CalveCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CalveCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CalveCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CalveCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalveCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CalveCount nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CalveCountMutation) ResetField(name string) error {
	switch name {
	case calvecount.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CalveCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CalveCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CalveCountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CalveCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CalveCountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CalveCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CalveCountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CalveCountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CalveCount unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CalveCountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CalveCount edge %s", name)
}

// CalveTypeMutation represents an operation that mutate the CalveTypes
// nodes in the graph.
type CalveTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CalveType, error)
}

var _ ent.Mutation = (*CalveTypeMutation)(nil)

// calvetypeOption allows to manage the mutation configuration using functional options.
type calvetypeOption func(*CalveTypeMutation)

// newCalveTypeMutation creates new mutation for $n.Name.
func newCalveTypeMutation(c config, op Op, opts ...calvetypeOption) *CalveTypeMutation {
	m := &CalveTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCalveType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalveTypeID sets the id field of the mutation.
func withCalveTypeID(id int64) calvetypeOption {
	return func(m *CalveTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CalveType
		)
		m.oldValue = func(ctx context.Context) (*CalveType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CalveType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalveType sets the old CalveType of the mutation.
func withCalveType(node *CalveType) calvetypeOption {
	return func(m *CalveTypeMutation) {
		m.oldValue = func(context.Context) (*CalveType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalveTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalveTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CalveTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CalveTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CalveTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CalveType.
// If the CalveType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CalveTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CalveTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CalveTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CalveType).
func (m *CalveTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CalveTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, calvetype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CalveTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calvetype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CalveTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calvetype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CalveType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calvetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CalveType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CalveTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CalveTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CalveTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CalveType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CalveTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CalveTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalveTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CalveType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CalveTypeMutation) ResetField(name string) error {
	switch name {
	case calvetype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CalveType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CalveTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CalveTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CalveTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CalveTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CalveTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CalveTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CalveTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CalveType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CalveTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CalveType edge %s", name)
}

// CategoryMutation represents an operation that mutate the Categories
// nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Category, error)
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows to manage the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for $n.Name.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the id field of the mutation.
func withCategoryID(id int64) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Category.
// If the Category object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Category edge %s", name)
}

// CattleMutation represents an operation that mutate the Cattles
// nodes in the graph.
type CattleMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	alive                  *int
	addalive               *int
	health                 *int
	addhealth              *int
	reproductiveStateId    *int
	addreproductiveStateId *int
	reproductiveStateName  *string
	name                   *string
	farmId                 *int64
	addfarmId              *int64
	farmName               *string
	shedId                 *int64
	addshedId              *int64
	shedName               *string
	shedTypeId             *int64
	addshedTypeId          *int64
	shedTypeName           *string
	earNumber              *string
	electronicEarNumber    *string
	pedometer              *string
	genderId               *int
	addgenderId            *int
	genderName             *string
	birthday               *int64
	addbirthday            *int64
	joinedAt               *int64
	addjoinedAt            *int64
	cateId                 *int
	addcateId              *int
	cateName               *string
	_type                  *int
	add_type               *int
	typeName               *string
	weight                 *int32
	addweight              *int32
	from                   *string
	breed                  *string
	joinedTypeId           *int
	addjoinedTypeId        *int
	joinedTypeName         *string
	mother                 *string
	father                 *string
	grandfather            *string
	ownerId                *int64
	addownerId             *int64
	ownerName              *string
	hairColorId            *int64
	addhairColorId         *int64
	hairColorName          *string
	pregnantTimes          *int
	addpregnantTimes       *int
	lastCalvingAt          *int64
	addlastCalvingAt       *int64
	breedingAt             *int64
	addbreedingAt          *int64
	breedingTypeId         *int
	addbreedingTypeId      *int
	breedingTypeName       *string
	bullId                 *int64
	addbullId              *int64
	pregnancyCheckAt       *int64
	addpregnancyCheckAt    *int64
	tenantId               *int64
	addtenantId            *int64
	tenantName             *string
	createdAt              *int64
	addcreatedAt           *int64
	updatedAt              *int64
	addupdatedAt           *int64
	deleted                *int
	adddeleted             *int
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*Cattle, error)
}

var _ ent.Mutation = (*CattleMutation)(nil)

// cattleOption allows to manage the mutation configuration using functional options.
type cattleOption func(*CattleMutation)

// newCattleMutation creates new mutation for $n.Name.
func newCattleMutation(c config, op Op, opts ...cattleOption) *CattleMutation {
	m := &CattleMutation{
		config:        c,
		op:            op,
		typ:           TypeCattle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleID sets the id field of the mutation.
func withCattleID(id int64) cattleOption {
	return func(m *CattleMutation) {
		var (
			err   error
			once  sync.Once
			value *Cattle
		)
		m.oldValue = func(ctx context.Context) (*Cattle, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cattle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattle sets the old Cattle of the mutation.
func withCattle(node *Cattle) cattleOption {
	return func(m *CattleMutation) {
		m.oldValue = func(context.Context) (*Cattle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAlive sets the alive field.
func (m *CattleMutation) SetAlive(i int) {
	m.alive = &i
	m.addalive = nil
}

// Alive returns the alive value in the mutation.
func (m *CattleMutation) Alive() (r int, exists bool) {
	v := m.alive
	if v == nil {
		return
	}
	return *v, true
}

// OldAlive returns the old alive value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldAlive(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAlive is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAlive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlive: %w", err)
	}
	return oldValue.Alive, nil
}

// AddAlive adds i to alive.
func (m *CattleMutation) AddAlive(i int) {
	if m.addalive != nil {
		*m.addalive += i
	} else {
		m.addalive = &i
	}
}

// AddedAlive returns the value that was added to the alive field in this mutation.
func (m *CattleMutation) AddedAlive() (r int, exists bool) {
	v := m.addalive
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlive reset all changes of the "alive" field.
func (m *CattleMutation) ResetAlive() {
	m.alive = nil
	m.addalive = nil
}

// SetHealth sets the health field.
func (m *CattleMutation) SetHealth(i int) {
	m.health = &i
	m.addhealth = nil
}

// Health returns the health value in the mutation.
func (m *CattleMutation) Health() (r int, exists bool) {
	v := m.health
	if v == nil {
		return
	}
	return *v, true
}

// OldHealth returns the old health value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldHealth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHealth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHealth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealth: %w", err)
	}
	return oldValue.Health, nil
}

// AddHealth adds i to health.
func (m *CattleMutation) AddHealth(i int) {
	if m.addhealth != nil {
		*m.addhealth += i
	} else {
		m.addhealth = &i
	}
}

// AddedHealth returns the value that was added to the health field in this mutation.
func (m *CattleMutation) AddedHealth() (r int, exists bool) {
	v := m.addhealth
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealth reset all changes of the "health" field.
func (m *CattleMutation) ResetHealth() {
	m.health = nil
	m.addhealth = nil
}

// SetReproductiveStateId sets the reproductiveStateId field.
func (m *CattleMutation) SetReproductiveStateId(i int) {
	m.reproductiveStateId = &i
	m.addreproductiveStateId = nil
}

// ReproductiveStateId returns the reproductiveStateId value in the mutation.
func (m *CattleMutation) ReproductiveStateId() (r int, exists bool) {
	v := m.reproductiveStateId
	if v == nil {
		return
	}
	return *v, true
}

// OldReproductiveStateId returns the old reproductiveStateId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldReproductiveStateId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReproductiveStateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReproductiveStateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReproductiveStateId: %w", err)
	}
	return oldValue.ReproductiveStateId, nil
}

// AddReproductiveStateId adds i to reproductiveStateId.
func (m *CattleMutation) AddReproductiveStateId(i int) {
	if m.addreproductiveStateId != nil {
		*m.addreproductiveStateId += i
	} else {
		m.addreproductiveStateId = &i
	}
}

// AddedReproductiveStateId returns the value that was added to the reproductiveStateId field in this mutation.
func (m *CattleMutation) AddedReproductiveStateId() (r int, exists bool) {
	v := m.addreproductiveStateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetReproductiveStateId reset all changes of the "reproductiveStateId" field.
func (m *CattleMutation) ResetReproductiveStateId() {
	m.reproductiveStateId = nil
	m.addreproductiveStateId = nil
}

// SetReproductiveStateName sets the reproductiveStateName field.
func (m *CattleMutation) SetReproductiveStateName(s string) {
	m.reproductiveStateName = &s
}

// ReproductiveStateName returns the reproductiveStateName value in the mutation.
func (m *CattleMutation) ReproductiveStateName() (r string, exists bool) {
	v := m.reproductiveStateName
	if v == nil {
		return
	}
	return *v, true
}

// OldReproductiveStateName returns the old reproductiveStateName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldReproductiveStateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReproductiveStateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReproductiveStateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReproductiveStateName: %w", err)
	}
	return oldValue.ReproductiveStateName, nil
}

// ResetReproductiveStateName reset all changes of the "reproductiveStateName" field.
func (m *CattleMutation) ResetReproductiveStateName() {
	m.reproductiveStateName = nil
}

// SetName sets the name field.
func (m *CattleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattle.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattle.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattle.FieldName)
}

// SetFarmId sets the farmId field.
func (m *CattleMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *CattleMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *CattleMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *CattleMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *CattleMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *CattleMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *CattleMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *CattleMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *CattleMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *CattleMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *CattleMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *CattleMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *CattleMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *CattleMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleMutation) ResetShedName() {
	m.shedName = nil
}

// SetShedTypeId sets the shedTypeId field.
func (m *CattleMutation) SetShedTypeId(i int64) {
	m.shedTypeId = &i
	m.addshedTypeId = nil
}

// ShedTypeId returns the shedTypeId value in the mutation.
func (m *CattleMutation) ShedTypeId() (r int64, exists bool) {
	v := m.shedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeId returns the old shedTypeId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedTypeId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeId: %w", err)
	}
	return oldValue.ShedTypeId, nil
}

// AddShedTypeId adds i to shedTypeId.
func (m *CattleMutation) AddShedTypeId(i int64) {
	if m.addshedTypeId != nil {
		*m.addshedTypeId += i
	} else {
		m.addshedTypeId = &i
	}
}

// AddedShedTypeId returns the value that was added to the shedTypeId field in this mutation.
func (m *CattleMutation) AddedShedTypeId() (r int64, exists bool) {
	v := m.addshedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedTypeId reset all changes of the "shedTypeId" field.
func (m *CattleMutation) ResetShedTypeId() {
	m.shedTypeId = nil
	m.addshedTypeId = nil
}

// SetShedTypeName sets the shedTypeName field.
func (m *CattleMutation) SetShedTypeName(s string) {
	m.shedTypeName = &s
}

// ShedTypeName returns the shedTypeName value in the mutation.
func (m *CattleMutation) ShedTypeName() (r string, exists bool) {
	v := m.shedTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeName returns the old shedTypeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldShedTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeName: %w", err)
	}
	return oldValue.ShedTypeName, nil
}

// ResetShedTypeName reset all changes of the "shedTypeName" field.
func (m *CattleMutation) ResetShedTypeName() {
	m.shedTypeName = nil
}

// SetEarNumber sets the earNumber field.
func (m *CattleMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetElectronicEarNumber sets the electronicEarNumber field.
func (m *CattleMutation) SetElectronicEarNumber(s string) {
	m.electronicEarNumber = &s
}

// ElectronicEarNumber returns the electronicEarNumber value in the mutation.
func (m *CattleMutation) ElectronicEarNumber() (r string, exists bool) {
	v := m.electronicEarNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldElectronicEarNumber returns the old electronicEarNumber value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldElectronicEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldElectronicEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldElectronicEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectronicEarNumber: %w", err)
	}
	return oldValue.ElectronicEarNumber, nil
}

// ResetElectronicEarNumber reset all changes of the "electronicEarNumber" field.
func (m *CattleMutation) ResetElectronicEarNumber() {
	m.electronicEarNumber = nil
}

// SetPedometer sets the pedometer field.
func (m *CattleMutation) SetPedometer(s string) {
	m.pedometer = &s
}

// Pedometer returns the pedometer value in the mutation.
func (m *CattleMutation) Pedometer() (r string, exists bool) {
	v := m.pedometer
	if v == nil {
		return
	}
	return *v, true
}

// OldPedometer returns the old pedometer value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldPedometer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPedometer is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPedometer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPedometer: %w", err)
	}
	return oldValue.Pedometer, nil
}

// ResetPedometer reset all changes of the "pedometer" field.
func (m *CattleMutation) ResetPedometer() {
	m.pedometer = nil
}

// SetGenderId sets the genderId field.
func (m *CattleMutation) SetGenderId(i int) {
	m.genderId = &i
	m.addgenderId = nil
}

// GenderId returns the genderId value in the mutation.
func (m *CattleMutation) GenderId() (r int, exists bool) {
	v := m.genderId
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderId returns the old genderId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldGenderId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderId: %w", err)
	}
	return oldValue.GenderId, nil
}

// AddGenderId adds i to genderId.
func (m *CattleMutation) AddGenderId(i int) {
	if m.addgenderId != nil {
		*m.addgenderId += i
	} else {
		m.addgenderId = &i
	}
}

// AddedGenderId returns the value that was added to the genderId field in this mutation.
func (m *CattleMutation) AddedGenderId() (r int, exists bool) {
	v := m.addgenderId
	if v == nil {
		return
	}
	return *v, true
}

// ResetGenderId reset all changes of the "genderId" field.
func (m *CattleMutation) ResetGenderId() {
	m.genderId = nil
	m.addgenderId = nil
}

// SetGenderName sets the genderName field.
func (m *CattleMutation) SetGenderName(s string) {
	m.genderName = &s
}

// GenderName returns the genderName value in the mutation.
func (m *CattleMutation) GenderName() (r string, exists bool) {
	v := m.genderName
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderName returns the old genderName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldGenderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderName: %w", err)
	}
	return oldValue.GenderName, nil
}

// ResetGenderName reset all changes of the "genderName" field.
func (m *CattleMutation) ResetGenderName() {
	m.genderName = nil
}

// SetBirthday sets the birthday field.
func (m *CattleMutation) SetBirthday(i int64) {
	m.birthday = &i
	m.addbirthday = nil
}

// Birthday returns the birthday value in the mutation.
func (m *CattleMutation) Birthday() (r int64, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old birthday value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBirthday(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds i to birthday.
func (m *CattleMutation) AddBirthday(i int64) {
	if m.addbirthday != nil {
		*m.addbirthday += i
	} else {
		m.addbirthday = &i
	}
}

// AddedBirthday returns the value that was added to the birthday field in this mutation.
func (m *CattleMutation) AddedBirthday() (r int64, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday reset all changes of the "birthday" field.
func (m *CattleMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetJoinedAt sets the joinedAt field.
func (m *CattleMutation) SetJoinedAt(i int64) {
	m.joinedAt = &i
	m.addjoinedAt = nil
}

// JoinedAt returns the joinedAt value in the mutation.
func (m *CattleMutation) JoinedAt() (r int64, exists bool) {
	v := m.joinedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old joinedAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldJoinedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// AddJoinedAt adds i to joinedAt.
func (m *CattleMutation) AddJoinedAt(i int64) {
	if m.addjoinedAt != nil {
		*m.addjoinedAt += i
	} else {
		m.addjoinedAt = &i
	}
}

// AddedJoinedAt returns the value that was added to the joinedAt field in this mutation.
func (m *CattleMutation) AddedJoinedAt() (r int64, exists bool) {
	v := m.addjoinedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetJoinedAt reset all changes of the "joinedAt" field.
func (m *CattleMutation) ResetJoinedAt() {
	m.joinedAt = nil
	m.addjoinedAt = nil
}

// SetCateId sets the cateId field.
func (m *CattleMutation) SetCateId(i int) {
	m.cateId = &i
	m.addcateId = nil
}

// CateId returns the cateId value in the mutation.
func (m *CattleMutation) CateId() (r int, exists bool) {
	v := m.cateId
	if v == nil {
		return
	}
	return *v, true
}

// OldCateId returns the old cateId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldCateId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCateId: %w", err)
	}
	return oldValue.CateId, nil
}

// AddCateId adds i to cateId.
func (m *CattleMutation) AddCateId(i int) {
	if m.addcateId != nil {
		*m.addcateId += i
	} else {
		m.addcateId = &i
	}
}

// AddedCateId returns the value that was added to the cateId field in this mutation.
func (m *CattleMutation) AddedCateId() (r int, exists bool) {
	v := m.addcateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCateId reset all changes of the "cateId" field.
func (m *CattleMutation) ResetCateId() {
	m.cateId = nil
	m.addcateId = nil
}

// SetCateName sets the cateName field.
func (m *CattleMutation) SetCateName(s string) {
	m.cateName = &s
}

// CateName returns the cateName value in the mutation.
func (m *CattleMutation) CateName() (r string, exists bool) {
	v := m.cateName
	if v == nil {
		return
	}
	return *v, true
}

// OldCateName returns the old cateName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldCateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCateName: %w", err)
	}
	return oldValue.CateName, nil
}

// ResetCateName reset all changes of the "cateName" field.
func (m *CattleMutation) ResetCateName() {
	m.cateName = nil
}

// SetType sets the type field.
func (m *CattleMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *CattleMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *CattleMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *CattleMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *CattleMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetTypeName sets the typeName field.
func (m *CattleMutation) SetTypeName(s string) {
	m.typeName = &s
}

// TypeName returns the typeName value in the mutation.
func (m *CattleMutation) TypeName() (r string, exists bool) {
	v := m.typeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old typeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName reset all changes of the "typeName" field.
func (m *CattleMutation) ResetTypeName() {
	m.typeName = nil
}

// SetWeight sets the weight field.
func (m *CattleMutation) SetWeight(i int32) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *CattleMutation) Weight() (r int32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldWeight(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *CattleMutation) AddWeight(i int32) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *CattleMutation) AddedWeight() (r int32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *CattleMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetFrom sets the from field.
func (m *CattleMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the from value in the mutation.
func (m *CattleMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old from value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFrom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom reset all changes of the "from" field.
func (m *CattleMutation) ResetFrom() {
	m.from = nil
}

// SetBreed sets the breed field.
func (m *CattleMutation) SetBreed(s string) {
	m.breed = &s
}

// Breed returns the breed value in the mutation.
func (m *CattleMutation) Breed() (r string, exists bool) {
	v := m.breed
	if v == nil {
		return
	}
	return *v, true
}

// OldBreed returns the old breed value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreed: %w", err)
	}
	return oldValue.Breed, nil
}

// ResetBreed reset all changes of the "breed" field.
func (m *CattleMutation) ResetBreed() {
	m.breed = nil
}

// SetJoinedTypeId sets the joinedTypeId field.
func (m *CattleMutation) SetJoinedTypeId(i int) {
	m.joinedTypeId = &i
	m.addjoinedTypeId = nil
}

// JoinedTypeId returns the joinedTypeId value in the mutation.
func (m *CattleMutation) JoinedTypeId() (r int, exists bool) {
	v := m.joinedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedTypeId returns the old joinedTypeId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldJoinedTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedTypeId: %w", err)
	}
	return oldValue.JoinedTypeId, nil
}

// AddJoinedTypeId adds i to joinedTypeId.
func (m *CattleMutation) AddJoinedTypeId(i int) {
	if m.addjoinedTypeId != nil {
		*m.addjoinedTypeId += i
	} else {
		m.addjoinedTypeId = &i
	}
}

// AddedJoinedTypeId returns the value that was added to the joinedTypeId field in this mutation.
func (m *CattleMutation) AddedJoinedTypeId() (r int, exists bool) {
	v := m.addjoinedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetJoinedTypeId reset all changes of the "joinedTypeId" field.
func (m *CattleMutation) ResetJoinedTypeId() {
	m.joinedTypeId = nil
	m.addjoinedTypeId = nil
}

// SetJoinedTypeName sets the joinedTypeName field.
func (m *CattleMutation) SetJoinedTypeName(s string) {
	m.joinedTypeName = &s
}

// JoinedTypeName returns the joinedTypeName value in the mutation.
func (m *CattleMutation) JoinedTypeName() (r string, exists bool) {
	v := m.joinedTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedTypeName returns the old joinedTypeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldJoinedTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedTypeName: %w", err)
	}
	return oldValue.JoinedTypeName, nil
}

// ResetJoinedTypeName reset all changes of the "joinedTypeName" field.
func (m *CattleMutation) ResetJoinedTypeName() {
	m.joinedTypeName = nil
}

// SetMother sets the mother field.
func (m *CattleMutation) SetMother(s string) {
	m.mother = &s
}

// Mother returns the mother value in the mutation.
func (m *CattleMutation) Mother() (r string, exists bool) {
	v := m.mother
	if v == nil {
		return
	}
	return *v, true
}

// OldMother returns the old mother value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldMother(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMother is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMother requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMother: %w", err)
	}
	return oldValue.Mother, nil
}

// ResetMother reset all changes of the "mother" field.
func (m *CattleMutation) ResetMother() {
	m.mother = nil
}

// SetFather sets the father field.
func (m *CattleMutation) SetFather(s string) {
	m.father = &s
}

// Father returns the father value in the mutation.
func (m *CattleMutation) Father() (r string, exists bool) {
	v := m.father
	if v == nil {
		return
	}
	return *v, true
}

// OldFather returns the old father value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldFather(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFather is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFather: %w", err)
	}
	return oldValue.Father, nil
}

// ResetFather reset all changes of the "father" field.
func (m *CattleMutation) ResetFather() {
	m.father = nil
}

// SetGrandfather sets the grandfather field.
func (m *CattleMutation) SetGrandfather(s string) {
	m.grandfather = &s
}

// Grandfather returns the grandfather value in the mutation.
func (m *CattleMutation) Grandfather() (r string, exists bool) {
	v := m.grandfather
	if v == nil {
		return
	}
	return *v, true
}

// OldGrandfather returns the old grandfather value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldGrandfather(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGrandfather is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGrandfather requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrandfather: %w", err)
	}
	return oldValue.Grandfather, nil
}

// ResetGrandfather reset all changes of the "grandfather" field.
func (m *CattleMutation) ResetGrandfather() {
	m.grandfather = nil
}

// SetOwnerId sets the ownerId field.
func (m *CattleMutation) SetOwnerId(i int64) {
	m.ownerId = &i
	m.addownerId = nil
}

// OwnerId returns the ownerId value in the mutation.
func (m *CattleMutation) OwnerId() (r int64, exists bool) {
	v := m.ownerId
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerId returns the old ownerId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldOwnerId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerId: %w", err)
	}
	return oldValue.OwnerId, nil
}

// AddOwnerId adds i to ownerId.
func (m *CattleMutation) AddOwnerId(i int64) {
	if m.addownerId != nil {
		*m.addownerId += i
	} else {
		m.addownerId = &i
	}
}

// AddedOwnerId returns the value that was added to the ownerId field in this mutation.
func (m *CattleMutation) AddedOwnerId() (r int64, exists bool) {
	v := m.addownerId
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwnerId reset all changes of the "ownerId" field.
func (m *CattleMutation) ResetOwnerId() {
	m.ownerId = nil
	m.addownerId = nil
}

// SetOwnerName sets the ownerName field.
func (m *CattleMutation) SetOwnerName(s string) {
	m.ownerName = &s
}

// OwnerName returns the ownerName value in the mutation.
func (m *CattleMutation) OwnerName() (r string, exists bool) {
	v := m.ownerName
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerName returns the old ownerName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldOwnerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOwnerName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOwnerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerName: %w", err)
	}
	return oldValue.OwnerName, nil
}

// ResetOwnerName reset all changes of the "ownerName" field.
func (m *CattleMutation) ResetOwnerName() {
	m.ownerName = nil
}

// SetHairColorId sets the hairColorId field.
func (m *CattleMutation) SetHairColorId(i int64) {
	m.hairColorId = &i
	m.addhairColorId = nil
}

// HairColorId returns the hairColorId value in the mutation.
func (m *CattleMutation) HairColorId() (r int64, exists bool) {
	v := m.hairColorId
	if v == nil {
		return
	}
	return *v, true
}

// OldHairColorId returns the old hairColorId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldHairColorId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairColorId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairColorId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairColorId: %w", err)
	}
	return oldValue.HairColorId, nil
}

// AddHairColorId adds i to hairColorId.
func (m *CattleMutation) AddHairColorId(i int64) {
	if m.addhairColorId != nil {
		*m.addhairColorId += i
	} else {
		m.addhairColorId = &i
	}
}

// AddedHairColorId returns the value that was added to the hairColorId field in this mutation.
func (m *CattleMutation) AddedHairColorId() (r int64, exists bool) {
	v := m.addhairColorId
	if v == nil {
		return
	}
	return *v, true
}

// ResetHairColorId reset all changes of the "hairColorId" field.
func (m *CattleMutation) ResetHairColorId() {
	m.hairColorId = nil
	m.addhairColorId = nil
}

// SetHairColorName sets the hairColorName field.
func (m *CattleMutation) SetHairColorName(s string) {
	m.hairColorName = &s
}

// HairColorName returns the hairColorName value in the mutation.
func (m *CattleMutation) HairColorName() (r string, exists bool) {
	v := m.hairColorName
	if v == nil {
		return
	}
	return *v, true
}

// OldHairColorName returns the old hairColorName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldHairColorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHairColorName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHairColorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHairColorName: %w", err)
	}
	return oldValue.HairColorName, nil
}

// ResetHairColorName reset all changes of the "hairColorName" field.
func (m *CattleMutation) ResetHairColorName() {
	m.hairColorName = nil
}

// SetPregnantTimes sets the pregnantTimes field.
func (m *CattleMutation) SetPregnantTimes(i int) {
	m.pregnantTimes = &i
	m.addpregnantTimes = nil
}

// PregnantTimes returns the pregnantTimes value in the mutation.
func (m *CattleMutation) PregnantTimes() (r int, exists bool) {
	v := m.pregnantTimes
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnantTimes returns the old pregnantTimes value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldPregnantTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnantTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnantTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnantTimes: %w", err)
	}
	return oldValue.PregnantTimes, nil
}

// AddPregnantTimes adds i to pregnantTimes.
func (m *CattleMutation) AddPregnantTimes(i int) {
	if m.addpregnantTimes != nil {
		*m.addpregnantTimes += i
	} else {
		m.addpregnantTimes = &i
	}
}

// AddedPregnantTimes returns the value that was added to the pregnantTimes field in this mutation.
func (m *CattleMutation) AddedPregnantTimes() (r int, exists bool) {
	v := m.addpregnantTimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnantTimes reset all changes of the "pregnantTimes" field.
func (m *CattleMutation) ResetPregnantTimes() {
	m.pregnantTimes = nil
	m.addpregnantTimes = nil
}

// SetLastCalvingAt sets the lastCalvingAt field.
func (m *CattleMutation) SetLastCalvingAt(i int64) {
	m.lastCalvingAt = &i
	m.addlastCalvingAt = nil
}

// LastCalvingAt returns the lastCalvingAt value in the mutation.
func (m *CattleMutation) LastCalvingAt() (r int64, exists bool) {
	v := m.lastCalvingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCalvingAt returns the old lastCalvingAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldLastCalvingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastCalvingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastCalvingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCalvingAt: %w", err)
	}
	return oldValue.LastCalvingAt, nil
}

// AddLastCalvingAt adds i to lastCalvingAt.
func (m *CattleMutation) AddLastCalvingAt(i int64) {
	if m.addlastCalvingAt != nil {
		*m.addlastCalvingAt += i
	} else {
		m.addlastCalvingAt = &i
	}
}

// AddedLastCalvingAt returns the value that was added to the lastCalvingAt field in this mutation.
func (m *CattleMutation) AddedLastCalvingAt() (r int64, exists bool) {
	v := m.addlastCalvingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastCalvingAt reset all changes of the "lastCalvingAt" field.
func (m *CattleMutation) ResetLastCalvingAt() {
	m.lastCalvingAt = nil
	m.addlastCalvingAt = nil
}

// SetBreedingAt sets the breedingAt field.
func (m *CattleMutation) SetBreedingAt(i int64) {
	m.breedingAt = &i
	m.addbreedingAt = nil
}

// BreedingAt returns the breedingAt value in the mutation.
func (m *CattleMutation) BreedingAt() (r int64, exists bool) {
	v := m.breedingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingAt returns the old breedingAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreedingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingAt: %w", err)
	}
	return oldValue.BreedingAt, nil
}

// AddBreedingAt adds i to breedingAt.
func (m *CattleMutation) AddBreedingAt(i int64) {
	if m.addbreedingAt != nil {
		*m.addbreedingAt += i
	} else {
		m.addbreedingAt = &i
	}
}

// AddedBreedingAt returns the value that was added to the breedingAt field in this mutation.
func (m *CattleMutation) AddedBreedingAt() (r int64, exists bool) {
	v := m.addbreedingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingAt reset all changes of the "breedingAt" field.
func (m *CattleMutation) ResetBreedingAt() {
	m.breedingAt = nil
	m.addbreedingAt = nil
}

// SetBreedingTypeId sets the breedingTypeId field.
func (m *CattleMutation) SetBreedingTypeId(i int) {
	m.breedingTypeId = &i
	m.addbreedingTypeId = nil
}

// BreedingTypeId returns the breedingTypeId value in the mutation.
func (m *CattleMutation) BreedingTypeId() (r int, exists bool) {
	v := m.breedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeId returns the old breedingTypeId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreedingTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeId: %w", err)
	}
	return oldValue.BreedingTypeId, nil
}

// AddBreedingTypeId adds i to breedingTypeId.
func (m *CattleMutation) AddBreedingTypeId(i int) {
	if m.addbreedingTypeId != nil {
		*m.addbreedingTypeId += i
	} else {
		m.addbreedingTypeId = &i
	}
}

// AddedBreedingTypeId returns the value that was added to the breedingTypeId field in this mutation.
func (m *CattleMutation) AddedBreedingTypeId() (r int, exists bool) {
	v := m.addbreedingTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingTypeId reset all changes of the "breedingTypeId" field.
func (m *CattleMutation) ResetBreedingTypeId() {
	m.breedingTypeId = nil
	m.addbreedingTypeId = nil
}

// SetBreedingTypeName sets the breedingTypeName field.
func (m *CattleMutation) SetBreedingTypeName(s string) {
	m.breedingTypeName = &s
}

// BreedingTypeName returns the breedingTypeName value in the mutation.
func (m *CattleMutation) BreedingTypeName() (r string, exists bool) {
	v := m.breedingTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingTypeName returns the old breedingTypeName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBreedingTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingTypeName: %w", err)
	}
	return oldValue.BreedingTypeName, nil
}

// ResetBreedingTypeName reset all changes of the "breedingTypeName" field.
func (m *CattleMutation) ResetBreedingTypeName() {
	m.breedingTypeName = nil
}

// SetBullId sets the bullId field.
func (m *CattleMutation) SetBullId(i int64) {
	m.bullId = &i
	m.addbullId = nil
}

// BullId returns the bullId value in the mutation.
func (m *CattleMutation) BullId() (r int64, exists bool) {
	v := m.bullId
	if v == nil {
		return
	}
	return *v, true
}

// OldBullId returns the old bullId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldBullId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBullId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBullId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBullId: %w", err)
	}
	return oldValue.BullId, nil
}

// AddBullId adds i to bullId.
func (m *CattleMutation) AddBullId(i int64) {
	if m.addbullId != nil {
		*m.addbullId += i
	} else {
		m.addbullId = &i
	}
}

// AddedBullId returns the value that was added to the bullId field in this mutation.
func (m *CattleMutation) AddedBullId() (r int64, exists bool) {
	v := m.addbullId
	if v == nil {
		return
	}
	return *v, true
}

// ResetBullId reset all changes of the "bullId" field.
func (m *CattleMutation) ResetBullId() {
	m.bullId = nil
	m.addbullId = nil
}

// SetPregnancyCheckAt sets the pregnancyCheckAt field.
func (m *CattleMutation) SetPregnancyCheckAt(i int64) {
	m.pregnancyCheckAt = &i
	m.addpregnancyCheckAt = nil
}

// PregnancyCheckAt returns the pregnancyCheckAt value in the mutation.
func (m *CattleMutation) PregnancyCheckAt() (r int64, exists bool) {
	v := m.pregnancyCheckAt
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyCheckAt returns the old pregnancyCheckAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldPregnancyCheckAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyCheckAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyCheckAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyCheckAt: %w", err)
	}
	return oldValue.PregnancyCheckAt, nil
}

// AddPregnancyCheckAt adds i to pregnancyCheckAt.
func (m *CattleMutation) AddPregnancyCheckAt(i int64) {
	if m.addpregnancyCheckAt != nil {
		*m.addpregnancyCheckAt += i
	} else {
		m.addpregnancyCheckAt = &i
	}
}

// AddedPregnancyCheckAt returns the value that was added to the pregnancyCheckAt field in this mutation.
func (m *CattleMutation) AddedPregnancyCheckAt() (r int64, exists bool) {
	v := m.addpregnancyCheckAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyCheckAt reset all changes of the "pregnancyCheckAt" field.
func (m *CattleMutation) ResetPregnancyCheckAt() {
	m.pregnancyCheckAt = nil
	m.addpregnancyCheckAt = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Cattle.
// If the Cattle object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cattle).
func (m *CattleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleMutation) Fields() []string {
	fields := make([]string, 0, 46)
	if m.alive != nil {
		fields = append(fields, cattle.FieldAlive)
	}
	if m.health != nil {
		fields = append(fields, cattle.FieldHealth)
	}
	if m.reproductiveStateId != nil {
		fields = append(fields, cattle.FieldReproductiveStateId)
	}
	if m.reproductiveStateName != nil {
		fields = append(fields, cattle.FieldReproductiveStateName)
	}
	if m.name != nil {
		fields = append(fields, cattle.FieldName)
	}
	if m.farmId != nil {
		fields = append(fields, cattle.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, cattle.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, cattle.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, cattle.FieldShedName)
	}
	if m.shedTypeId != nil {
		fields = append(fields, cattle.FieldShedTypeId)
	}
	if m.shedTypeName != nil {
		fields = append(fields, cattle.FieldShedTypeName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattle.FieldEarNumber)
	}
	if m.electronicEarNumber != nil {
		fields = append(fields, cattle.FieldElectronicEarNumber)
	}
	if m.pedometer != nil {
		fields = append(fields, cattle.FieldPedometer)
	}
	if m.genderId != nil {
		fields = append(fields, cattle.FieldGenderId)
	}
	if m.genderName != nil {
		fields = append(fields, cattle.FieldGenderName)
	}
	if m.birthday != nil {
		fields = append(fields, cattle.FieldBirthday)
	}
	if m.joinedAt != nil {
		fields = append(fields, cattle.FieldJoinedAt)
	}
	if m.cateId != nil {
		fields = append(fields, cattle.FieldCateId)
	}
	if m.cateName != nil {
		fields = append(fields, cattle.FieldCateName)
	}
	if m._type != nil {
		fields = append(fields, cattle.FieldType)
	}
	if m.typeName != nil {
		fields = append(fields, cattle.FieldTypeName)
	}
	if m.weight != nil {
		fields = append(fields, cattle.FieldWeight)
	}
	if m.from != nil {
		fields = append(fields, cattle.FieldFrom)
	}
	if m.breed != nil {
		fields = append(fields, cattle.FieldBreed)
	}
	if m.joinedTypeId != nil {
		fields = append(fields, cattle.FieldJoinedTypeId)
	}
	if m.joinedTypeName != nil {
		fields = append(fields, cattle.FieldJoinedTypeName)
	}
	if m.mother != nil {
		fields = append(fields, cattle.FieldMother)
	}
	if m.father != nil {
		fields = append(fields, cattle.FieldFather)
	}
	if m.grandfather != nil {
		fields = append(fields, cattle.FieldGrandfather)
	}
	if m.ownerId != nil {
		fields = append(fields, cattle.FieldOwnerId)
	}
	if m.ownerName != nil {
		fields = append(fields, cattle.FieldOwnerName)
	}
	if m.hairColorId != nil {
		fields = append(fields, cattle.FieldHairColorId)
	}
	if m.hairColorName != nil {
		fields = append(fields, cattle.FieldHairColorName)
	}
	if m.pregnantTimes != nil {
		fields = append(fields, cattle.FieldPregnantTimes)
	}
	if m.lastCalvingAt != nil {
		fields = append(fields, cattle.FieldLastCalvingAt)
	}
	if m.breedingAt != nil {
		fields = append(fields, cattle.FieldBreedingAt)
	}
	if m.breedingTypeId != nil {
		fields = append(fields, cattle.FieldBreedingTypeId)
	}
	if m.breedingTypeName != nil {
		fields = append(fields, cattle.FieldBreedingTypeName)
	}
	if m.bullId != nil {
		fields = append(fields, cattle.FieldBullId)
	}
	if m.pregnancyCheckAt != nil {
		fields = append(fields, cattle.FieldPregnancyCheckAt)
	}
	if m.tenantId != nil {
		fields = append(fields, cattle.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattle.FieldTenantName)
	}
	if m.createdAt != nil {
		fields = append(fields, cattle.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattle.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattle.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattle.FieldAlive:
		return m.Alive()
	case cattle.FieldHealth:
		return m.Health()
	case cattle.FieldReproductiveStateId:
		return m.ReproductiveStateId()
	case cattle.FieldReproductiveStateName:
		return m.ReproductiveStateName()
	case cattle.FieldName:
		return m.Name()
	case cattle.FieldFarmId:
		return m.FarmId()
	case cattle.FieldFarmName:
		return m.FarmName()
	case cattle.FieldShedId:
		return m.ShedId()
	case cattle.FieldShedName:
		return m.ShedName()
	case cattle.FieldShedTypeId:
		return m.ShedTypeId()
	case cattle.FieldShedTypeName:
		return m.ShedTypeName()
	case cattle.FieldEarNumber:
		return m.EarNumber()
	case cattle.FieldElectronicEarNumber:
		return m.ElectronicEarNumber()
	case cattle.FieldPedometer:
		return m.Pedometer()
	case cattle.FieldGenderId:
		return m.GenderId()
	case cattle.FieldGenderName:
		return m.GenderName()
	case cattle.FieldBirthday:
		return m.Birthday()
	case cattle.FieldJoinedAt:
		return m.JoinedAt()
	case cattle.FieldCateId:
		return m.CateId()
	case cattle.FieldCateName:
		return m.CateName()
	case cattle.FieldType:
		return m.GetType()
	case cattle.FieldTypeName:
		return m.TypeName()
	case cattle.FieldWeight:
		return m.Weight()
	case cattle.FieldFrom:
		return m.From()
	case cattle.FieldBreed:
		return m.Breed()
	case cattle.FieldJoinedTypeId:
		return m.JoinedTypeId()
	case cattle.FieldJoinedTypeName:
		return m.JoinedTypeName()
	case cattle.FieldMother:
		return m.Mother()
	case cattle.FieldFather:
		return m.Father()
	case cattle.FieldGrandfather:
		return m.Grandfather()
	case cattle.FieldOwnerId:
		return m.OwnerId()
	case cattle.FieldOwnerName:
		return m.OwnerName()
	case cattle.FieldHairColorId:
		return m.HairColorId()
	case cattle.FieldHairColorName:
		return m.HairColorName()
	case cattle.FieldPregnantTimes:
		return m.PregnantTimes()
	case cattle.FieldLastCalvingAt:
		return m.LastCalvingAt()
	case cattle.FieldBreedingAt:
		return m.BreedingAt()
	case cattle.FieldBreedingTypeId:
		return m.BreedingTypeId()
	case cattle.FieldBreedingTypeName:
		return m.BreedingTypeName()
	case cattle.FieldBullId:
		return m.BullId()
	case cattle.FieldPregnancyCheckAt:
		return m.PregnancyCheckAt()
	case cattle.FieldTenantId:
		return m.TenantId()
	case cattle.FieldTenantName:
		return m.TenantName()
	case cattle.FieldCreatedAt:
		return m.CreatedAt()
	case cattle.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattle.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattle.FieldAlive:
		return m.OldAlive(ctx)
	case cattle.FieldHealth:
		return m.OldHealth(ctx)
	case cattle.FieldReproductiveStateId:
		return m.OldReproductiveStateId(ctx)
	case cattle.FieldReproductiveStateName:
		return m.OldReproductiveStateName(ctx)
	case cattle.FieldName:
		return m.OldName(ctx)
	case cattle.FieldFarmId:
		return m.OldFarmId(ctx)
	case cattle.FieldFarmName:
		return m.OldFarmName(ctx)
	case cattle.FieldShedId:
		return m.OldShedId(ctx)
	case cattle.FieldShedName:
		return m.OldShedName(ctx)
	case cattle.FieldShedTypeId:
		return m.OldShedTypeId(ctx)
	case cattle.FieldShedTypeName:
		return m.OldShedTypeName(ctx)
	case cattle.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattle.FieldElectronicEarNumber:
		return m.OldElectronicEarNumber(ctx)
	case cattle.FieldPedometer:
		return m.OldPedometer(ctx)
	case cattle.FieldGenderId:
		return m.OldGenderId(ctx)
	case cattle.FieldGenderName:
		return m.OldGenderName(ctx)
	case cattle.FieldBirthday:
		return m.OldBirthday(ctx)
	case cattle.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case cattle.FieldCateId:
		return m.OldCateId(ctx)
	case cattle.FieldCateName:
		return m.OldCateName(ctx)
	case cattle.FieldType:
		return m.OldType(ctx)
	case cattle.FieldTypeName:
		return m.OldTypeName(ctx)
	case cattle.FieldWeight:
		return m.OldWeight(ctx)
	case cattle.FieldFrom:
		return m.OldFrom(ctx)
	case cattle.FieldBreed:
		return m.OldBreed(ctx)
	case cattle.FieldJoinedTypeId:
		return m.OldJoinedTypeId(ctx)
	case cattle.FieldJoinedTypeName:
		return m.OldJoinedTypeName(ctx)
	case cattle.FieldMother:
		return m.OldMother(ctx)
	case cattle.FieldFather:
		return m.OldFather(ctx)
	case cattle.FieldGrandfather:
		return m.OldGrandfather(ctx)
	case cattle.FieldOwnerId:
		return m.OldOwnerId(ctx)
	case cattle.FieldOwnerName:
		return m.OldOwnerName(ctx)
	case cattle.FieldHairColorId:
		return m.OldHairColorId(ctx)
	case cattle.FieldHairColorName:
		return m.OldHairColorName(ctx)
	case cattle.FieldPregnantTimes:
		return m.OldPregnantTimes(ctx)
	case cattle.FieldLastCalvingAt:
		return m.OldLastCalvingAt(ctx)
	case cattle.FieldBreedingAt:
		return m.OldBreedingAt(ctx)
	case cattle.FieldBreedingTypeId:
		return m.OldBreedingTypeId(ctx)
	case cattle.FieldBreedingTypeName:
		return m.OldBreedingTypeName(ctx)
	case cattle.FieldBullId:
		return m.OldBullId(ctx)
	case cattle.FieldPregnancyCheckAt:
		return m.OldPregnancyCheckAt(ctx)
	case cattle.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattle.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattle.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Cattle field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattle.FieldAlive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlive(v)
		return nil
	case cattle.FieldHealth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealth(v)
		return nil
	case cattle.FieldReproductiveStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReproductiveStateId(v)
		return nil
	case cattle.FieldReproductiveStateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReproductiveStateName(v)
		return nil
	case cattle.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattle.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case cattle.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case cattle.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case cattle.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattle.FieldShedTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeId(v)
		return nil
	case cattle.FieldShedTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeName(v)
		return nil
	case cattle.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattle.FieldElectronicEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectronicEarNumber(v)
		return nil
	case cattle.FieldPedometer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPedometer(v)
		return nil
	case cattle.FieldGenderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderId(v)
		return nil
	case cattle.FieldGenderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderName(v)
		return nil
	case cattle.FieldBirthday:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case cattle.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case cattle.FieldCateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCateId(v)
		return nil
	case cattle.FieldCateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCateName(v)
		return nil
	case cattle.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case cattle.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case cattle.FieldWeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case cattle.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case cattle.FieldBreed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreed(v)
		return nil
	case cattle.FieldJoinedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedTypeId(v)
		return nil
	case cattle.FieldJoinedTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedTypeName(v)
		return nil
	case cattle.FieldMother:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMother(v)
		return nil
	case cattle.FieldFather:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFather(v)
		return nil
	case cattle.FieldGrandfather:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrandfather(v)
		return nil
	case cattle.FieldOwnerId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerId(v)
		return nil
	case cattle.FieldOwnerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerName(v)
		return nil
	case cattle.FieldHairColorId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairColorId(v)
		return nil
	case cattle.FieldHairColorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHairColorName(v)
		return nil
	case cattle.FieldPregnantTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnantTimes(v)
		return nil
	case cattle.FieldLastCalvingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCalvingAt(v)
		return nil
	case cattle.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingAt(v)
		return nil
	case cattle.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeId(v)
		return nil
	case cattle.FieldBreedingTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingTypeName(v)
		return nil
	case cattle.FieldBullId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBullId(v)
		return nil
	case cattle.FieldPregnancyCheckAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyCheckAt(v)
		return nil
	case cattle.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattle.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattle.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattle.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattle.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Cattle field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleMutation) AddedFields() []string {
	var fields []string
	if m.addalive != nil {
		fields = append(fields, cattle.FieldAlive)
	}
	if m.addhealth != nil {
		fields = append(fields, cattle.FieldHealth)
	}
	if m.addreproductiveStateId != nil {
		fields = append(fields, cattle.FieldReproductiveStateId)
	}
	if m.addfarmId != nil {
		fields = append(fields, cattle.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, cattle.FieldShedId)
	}
	if m.addshedTypeId != nil {
		fields = append(fields, cattle.FieldShedTypeId)
	}
	if m.addgenderId != nil {
		fields = append(fields, cattle.FieldGenderId)
	}
	if m.addbirthday != nil {
		fields = append(fields, cattle.FieldBirthday)
	}
	if m.addjoinedAt != nil {
		fields = append(fields, cattle.FieldJoinedAt)
	}
	if m.addcateId != nil {
		fields = append(fields, cattle.FieldCateId)
	}
	if m.add_type != nil {
		fields = append(fields, cattle.FieldType)
	}
	if m.addweight != nil {
		fields = append(fields, cattle.FieldWeight)
	}
	if m.addjoinedTypeId != nil {
		fields = append(fields, cattle.FieldJoinedTypeId)
	}
	if m.addownerId != nil {
		fields = append(fields, cattle.FieldOwnerId)
	}
	if m.addhairColorId != nil {
		fields = append(fields, cattle.FieldHairColorId)
	}
	if m.addpregnantTimes != nil {
		fields = append(fields, cattle.FieldPregnantTimes)
	}
	if m.addlastCalvingAt != nil {
		fields = append(fields, cattle.FieldLastCalvingAt)
	}
	if m.addbreedingAt != nil {
		fields = append(fields, cattle.FieldBreedingAt)
	}
	if m.addbreedingTypeId != nil {
		fields = append(fields, cattle.FieldBreedingTypeId)
	}
	if m.addbullId != nil {
		fields = append(fields, cattle.FieldBullId)
	}
	if m.addpregnancyCheckAt != nil {
		fields = append(fields, cattle.FieldPregnancyCheckAt)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattle.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattle.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattle.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattle.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattle.FieldAlive:
		return m.AddedAlive()
	case cattle.FieldHealth:
		return m.AddedHealth()
	case cattle.FieldReproductiveStateId:
		return m.AddedReproductiveStateId()
	case cattle.FieldFarmId:
		return m.AddedFarmId()
	case cattle.FieldShedId:
		return m.AddedShedId()
	case cattle.FieldShedTypeId:
		return m.AddedShedTypeId()
	case cattle.FieldGenderId:
		return m.AddedGenderId()
	case cattle.FieldBirthday:
		return m.AddedBirthday()
	case cattle.FieldJoinedAt:
		return m.AddedJoinedAt()
	case cattle.FieldCateId:
		return m.AddedCateId()
	case cattle.FieldType:
		return m.AddedType()
	case cattle.FieldWeight:
		return m.AddedWeight()
	case cattle.FieldJoinedTypeId:
		return m.AddedJoinedTypeId()
	case cattle.FieldOwnerId:
		return m.AddedOwnerId()
	case cattle.FieldHairColorId:
		return m.AddedHairColorId()
	case cattle.FieldPregnantTimes:
		return m.AddedPregnantTimes()
	case cattle.FieldLastCalvingAt:
		return m.AddedLastCalvingAt()
	case cattle.FieldBreedingAt:
		return m.AddedBreedingAt()
	case cattle.FieldBreedingTypeId:
		return m.AddedBreedingTypeId()
	case cattle.FieldBullId:
		return m.AddedBullId()
	case cattle.FieldPregnancyCheckAt:
		return m.AddedPregnancyCheckAt()
	case cattle.FieldTenantId:
		return m.AddedTenantId()
	case cattle.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattle.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattle.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattle.FieldAlive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlive(v)
		return nil
	case cattle.FieldHealth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealth(v)
		return nil
	case cattle.FieldReproductiveStateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReproductiveStateId(v)
		return nil
	case cattle.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case cattle.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case cattle.FieldShedTypeId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedTypeId(v)
		return nil
	case cattle.FieldGenderId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGenderId(v)
		return nil
	case cattle.FieldBirthday:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	case cattle.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinedAt(v)
		return nil
	case cattle.FieldCateId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCateId(v)
		return nil
	case cattle.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case cattle.FieldWeight:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case cattle.FieldJoinedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinedTypeId(v)
		return nil
	case cattle.FieldOwnerId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerId(v)
		return nil
	case cattle.FieldHairColorId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHairColorId(v)
		return nil
	case cattle.FieldPregnantTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnantTimes(v)
		return nil
	case cattle.FieldLastCalvingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastCalvingAt(v)
		return nil
	case cattle.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingAt(v)
		return nil
	case cattle.FieldBreedingTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingTypeId(v)
		return nil
	case cattle.FieldBullId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBullId(v)
		return nil
	case cattle.FieldPregnancyCheckAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyCheckAt(v)
		return nil
	case cattle.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattle.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattle.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattle.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Cattle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattle.FieldName) {
		fields = append(fields, cattle.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleMutation) ClearField(name string) error {
	switch name {
	case cattle.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Cattle nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleMutation) ResetField(name string) error {
	switch name {
	case cattle.FieldAlive:
		m.ResetAlive()
		return nil
	case cattle.FieldHealth:
		m.ResetHealth()
		return nil
	case cattle.FieldReproductiveStateId:
		m.ResetReproductiveStateId()
		return nil
	case cattle.FieldReproductiveStateName:
		m.ResetReproductiveStateName()
		return nil
	case cattle.FieldName:
		m.ResetName()
		return nil
	case cattle.FieldFarmId:
		m.ResetFarmId()
		return nil
	case cattle.FieldFarmName:
		m.ResetFarmName()
		return nil
	case cattle.FieldShedId:
		m.ResetShedId()
		return nil
	case cattle.FieldShedName:
		m.ResetShedName()
		return nil
	case cattle.FieldShedTypeId:
		m.ResetShedTypeId()
		return nil
	case cattle.FieldShedTypeName:
		m.ResetShedTypeName()
		return nil
	case cattle.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattle.FieldElectronicEarNumber:
		m.ResetElectronicEarNumber()
		return nil
	case cattle.FieldPedometer:
		m.ResetPedometer()
		return nil
	case cattle.FieldGenderId:
		m.ResetGenderId()
		return nil
	case cattle.FieldGenderName:
		m.ResetGenderName()
		return nil
	case cattle.FieldBirthday:
		m.ResetBirthday()
		return nil
	case cattle.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case cattle.FieldCateId:
		m.ResetCateId()
		return nil
	case cattle.FieldCateName:
		m.ResetCateName()
		return nil
	case cattle.FieldType:
		m.ResetType()
		return nil
	case cattle.FieldTypeName:
		m.ResetTypeName()
		return nil
	case cattle.FieldWeight:
		m.ResetWeight()
		return nil
	case cattle.FieldFrom:
		m.ResetFrom()
		return nil
	case cattle.FieldBreed:
		m.ResetBreed()
		return nil
	case cattle.FieldJoinedTypeId:
		m.ResetJoinedTypeId()
		return nil
	case cattle.FieldJoinedTypeName:
		m.ResetJoinedTypeName()
		return nil
	case cattle.FieldMother:
		m.ResetMother()
		return nil
	case cattle.FieldFather:
		m.ResetFather()
		return nil
	case cattle.FieldGrandfather:
		m.ResetGrandfather()
		return nil
	case cattle.FieldOwnerId:
		m.ResetOwnerId()
		return nil
	case cattle.FieldOwnerName:
		m.ResetOwnerName()
		return nil
	case cattle.FieldHairColorId:
		m.ResetHairColorId()
		return nil
	case cattle.FieldHairColorName:
		m.ResetHairColorName()
		return nil
	case cattle.FieldPregnantTimes:
		m.ResetPregnantTimes()
		return nil
	case cattle.FieldLastCalvingAt:
		m.ResetLastCalvingAt()
		return nil
	case cattle.FieldBreedingAt:
		m.ResetBreedingAt()
		return nil
	case cattle.FieldBreedingTypeId:
		m.ResetBreedingTypeId()
		return nil
	case cattle.FieldBreedingTypeName:
		m.ResetBreedingTypeName()
		return nil
	case cattle.FieldBullId:
		m.ResetBullId()
		return nil
	case cattle.FieldPregnancyCheckAt:
		m.ResetPregnancyCheckAt()
		return nil
	case cattle.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattle.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattle.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Cattle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Cattle unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Cattle edge %s", name)
}

// CattleBreedMutation represents an operation that mutate the CattleBreeds
// nodes in the graph.
type CattleBreedMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	_order        *int
	add_order     *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleBreed, error)
}

var _ ent.Mutation = (*CattleBreedMutation)(nil)

// cattlebreedOption allows to manage the mutation configuration using functional options.
type cattlebreedOption func(*CattleBreedMutation)

// newCattleBreedMutation creates new mutation for $n.Name.
func newCattleBreedMutation(c config, op Op, opts ...cattlebreedOption) *CattleBreedMutation {
	m := &CattleBreedMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleBreed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleBreedID sets the id field of the mutation.
func withCattleBreedID(id int64) cattlebreedOption {
	return func(m *CattleBreedMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleBreed
		)
		m.oldValue = func(ctx context.Context) (*CattleBreed, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleBreed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleBreed sets the old CattleBreed of the mutation.
func withCattleBreed(node *CattleBreed) cattlebreedOption {
	return func(m *CattleBreedMutation) {
		m.oldValue = func(context.Context) (*CattleBreed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleBreedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleBreedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleBreedMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleBreedMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleBreedMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleBreedMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *CattleBreedMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *CattleBreedMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *CattleBreedMutation) ResetCode() {
	m.code = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleBreedMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleBreedMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleBreedMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleBreedMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleBreedMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleBreedMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleBreedMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleBreedMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetOrder sets the order field.
func (m *CattleBreedMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the order value in the mutation.
func (m *CattleBreedMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old order value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to order.
func (m *CattleBreedMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the order field in this mutation.
func (m *CattleBreedMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder reset all changes of the "order" field.
func (m *CattleBreedMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRemarks sets the remarks field.
func (m *CattleBreedMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleBreedMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleBreedMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleBreedMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleBreedMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleBreedMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleBreedMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleBreedMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleBreedMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleBreedMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleBreedMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleBreedMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleBreedMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleBreedMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleBreedMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleBreed.
// If the CattleBreed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleBreedMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleBreedMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleBreedMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleBreedMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleBreedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleBreed).
func (m *CattleBreedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleBreedMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, cattlebreed.FieldName)
	}
	if m.code != nil {
		fields = append(fields, cattlebreed.FieldCode)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlebreed.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlebreed.FieldTenantName)
	}
	if m._order != nil {
		fields = append(fields, cattlebreed.FieldOrder)
	}
	if m.remarks != nil {
		fields = append(fields, cattlebreed.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlebreed.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlebreed.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlebreed.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleBreedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlebreed.FieldName:
		return m.Name()
	case cattlebreed.FieldCode:
		return m.Code()
	case cattlebreed.FieldTenantId:
		return m.TenantId()
	case cattlebreed.FieldTenantName:
		return m.TenantName()
	case cattlebreed.FieldOrder:
		return m.Order()
	case cattlebreed.FieldRemarks:
		return m.Remarks()
	case cattlebreed.FieldCreatedAt:
		return m.CreatedAt()
	case cattlebreed.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlebreed.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleBreedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlebreed.FieldName:
		return m.OldName(ctx)
	case cattlebreed.FieldCode:
		return m.OldCode(ctx)
	case cattlebreed.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlebreed.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlebreed.FieldOrder:
		return m.OldOrder(ctx)
	case cattlebreed.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlebreed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlebreed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlebreed.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleBreed field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleBreedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlebreed.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlebreed.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case cattlebreed.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlebreed.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlebreed.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case cattlebreed.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlebreed.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlebreed.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlebreed.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleBreed field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleBreedMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, cattlebreed.FieldTenantId)
	}
	if m.add_order != nil {
		fields = append(fields, cattlebreed.FieldOrder)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlebreed.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlebreed.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlebreed.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleBreedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlebreed.FieldTenantId:
		return m.AddedTenantId()
	case cattlebreed.FieldOrder:
		return m.AddedOrder()
	case cattlebreed.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlebreed.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlebreed.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleBreedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlebreed.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlebreed.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case cattlebreed.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlebreed.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlebreed.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleBreed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleBreedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleBreedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleBreedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleBreed nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleBreedMutation) ResetField(name string) error {
	switch name {
	case cattlebreed.FieldName:
		m.ResetName()
		return nil
	case cattlebreed.FieldCode:
		m.ResetCode()
		return nil
	case cattlebreed.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlebreed.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlebreed.FieldOrder:
		m.ResetOrder()
		return nil
	case cattlebreed.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlebreed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlebreed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlebreed.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleBreed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleBreedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleBreedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleBreedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleBreedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleBreedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleBreedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleBreedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleBreed unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleBreedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleBreed edge %s", name)
}

// CattleCateMutation represents an operation that mutate the CattleCates
// nodes in the graph.
type CattleCateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	genderIds     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleCate, error)
}

var _ ent.Mutation = (*CattleCateMutation)(nil)

// cattlecateOption allows to manage the mutation configuration using functional options.
type cattlecateOption func(*CattleCateMutation)

// newCattleCateMutation creates new mutation for $n.Name.
func newCattleCateMutation(c config, op Op, opts ...cattlecateOption) *CattleCateMutation {
	m := &CattleCateMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleCate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleCateID sets the id field of the mutation.
func withCattleCateID(id int64) cattlecateOption {
	return func(m *CattleCateMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleCate
		)
		m.oldValue = func(ctx context.Context) (*CattleCate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleCate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleCate sets the old CattleCate of the mutation.
func withCattleCate(node *CattleCate) cattlecateOption {
	return func(m *CattleCateMutation) {
		m.oldValue = func(context.Context) (*CattleCate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleCateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleCateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleCateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleCateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleCateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleCate.
// If the CattleCate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleCateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleCateMutation) ResetName() {
	m.name = nil
}

// SetGenderIds sets the genderIds field.
func (m *CattleCateMutation) SetGenderIds(s string) {
	m.genderIds = &s
}

// GenderIds returns the genderIds value in the mutation.
func (m *CattleCateMutation) GenderIds() (r string, exists bool) {
	v := m.genderIds
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderIds returns the old genderIds value of the CattleCate.
// If the CattleCate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleCateMutation) OldGenderIds(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGenderIds is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGenderIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderIds: %w", err)
	}
	return oldValue.GenderIds, nil
}

// ResetGenderIds reset all changes of the "genderIds" field.
func (m *CattleCateMutation) ResetGenderIds() {
	m.genderIds = nil
}

// Op returns the operation name.
func (m *CattleCateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleCate).
func (m *CattleCateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleCateMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, cattlecate.FieldName)
	}
	if m.genderIds != nil {
		fields = append(fields, cattlecate.FieldGenderIds)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleCateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlecate.FieldName:
		return m.Name()
	case cattlecate.FieldGenderIds:
		return m.GenderIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleCateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlecate.FieldName:
		return m.OldName(ctx)
	case cattlecate.FieldGenderIds:
		return m.OldGenderIds(ctx)
	}
	return nil, fmt.Errorf("unknown CattleCate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleCateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlecate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlecate.FieldGenderIds:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderIds(v)
		return nil
	}
	return fmt.Errorf("unknown CattleCate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleCateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleCateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleCateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleCate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleCateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleCateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleCateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleCate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleCateMutation) ResetField(name string) error {
	switch name {
	case cattlecate.FieldName:
		m.ResetName()
		return nil
	case cattlecate.FieldGenderIds:
		m.ResetGenderIds()
		return nil
	}
	return fmt.Errorf("unknown CattleCate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleCateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleCateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleCateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleCateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleCateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleCateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleCateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleCate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleCateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleCate edge %s", name)
}

// CattleDieMutation represents an operation that mutate the CattleDies
// nodes in the graph.
type CattleDieMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	cattleId       *int64
	addcattleId    *int64
	tenantId       *int64
	addtenantId    *int64
	tenantName     *string
	farmId         *int64
	addfarmId      *int64
	farmName       *string
	shedId         *int64
	addshedId      *int64
	shedName       *string
	earNumber      *string
	date           *int64
	adddate        *int64
	userName       *string
	reasonId       *int
	addreasonId    *int
	reasonName     *string
	insured        *int
	addinsured     *int
	insuredCode    *string
	insuredCompany *string
	weight         *int64
	addweight      *int64
	handleMethod   *string
	declared       *int
	adddeclared    *int
	dUserName      *string
	remarks        *string
	createdAt      *int64
	addcreatedAt   *int64
	updatedAt      *int64
	addupdatedAt   *int64
	deleted        *int
	adddeleted     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CattleDie, error)
}

var _ ent.Mutation = (*CattleDieMutation)(nil)

// cattledieOption allows to manage the mutation configuration using functional options.
type cattledieOption func(*CattleDieMutation)

// newCattleDieMutation creates new mutation for $n.Name.
func newCattleDieMutation(c config, op Op, opts ...cattledieOption) *CattleDieMutation {
	m := &CattleDieMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleDie,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleDieID sets the id field of the mutation.
func withCattleDieID(id int64) cattledieOption {
	return func(m *CattleDieMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleDie
		)
		m.oldValue = func(ctx context.Context) (*CattleDie, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleDie.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleDie sets the old CattleDie of the mutation.
func withCattleDie(node *CattleDie) cattledieOption {
	return func(m *CattleDieMutation) {
		m.oldValue = func(context.Context) (*CattleDie, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleDieMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleDieMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleDieMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *CattleDieMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *CattleDieMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *CattleDieMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *CattleDieMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *CattleDieMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleDieMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleDieMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleDieMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleDieMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleDieMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleDieMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleDieMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleDieMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *CattleDieMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *CattleDieMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *CattleDieMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *CattleDieMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *CattleDieMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *CattleDieMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *CattleDieMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *CattleDieMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *CattleDieMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *CattleDieMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *CattleDieMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *CattleDieMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *CattleDieMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *CattleDieMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleDieMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleDieMutation) ResetShedName() {
	m.shedName = nil
}

// SetEarNumber sets the earNumber field.
func (m *CattleDieMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleDieMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleDieMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetDate sets the date field.
func (m *CattleDieMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *CattleDieMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *CattleDieMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *CattleDieMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *CattleDieMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetUserName sets the userName field.
func (m *CattleDieMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CattleDieMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CattleDieMutation) ResetUserName() {
	m.userName = nil
}

// SetReasonId sets the reasonId field.
func (m *CattleDieMutation) SetReasonId(i int) {
	m.reasonId = &i
	m.addreasonId = nil
}

// ReasonId returns the reasonId value in the mutation.
func (m *CattleDieMutation) ReasonId() (r int, exists bool) {
	v := m.reasonId
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonId returns the old reasonId value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldReasonId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReasonId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReasonId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonId: %w", err)
	}
	return oldValue.ReasonId, nil
}

// AddReasonId adds i to reasonId.
func (m *CattleDieMutation) AddReasonId(i int) {
	if m.addreasonId != nil {
		*m.addreasonId += i
	} else {
		m.addreasonId = &i
	}
}

// AddedReasonId returns the value that was added to the reasonId field in this mutation.
func (m *CattleDieMutation) AddedReasonId() (r int, exists bool) {
	v := m.addreasonId
	if v == nil {
		return
	}
	return *v, true
}

// ResetReasonId reset all changes of the "reasonId" field.
func (m *CattleDieMutation) ResetReasonId() {
	m.reasonId = nil
	m.addreasonId = nil
}

// SetReasonName sets the reasonName field.
func (m *CattleDieMutation) SetReasonName(s string) {
	m.reasonName = &s
}

// ReasonName returns the reasonName value in the mutation.
func (m *CattleDieMutation) ReasonName() (r string, exists bool) {
	v := m.reasonName
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonName returns the old reasonName value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldReasonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReasonName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReasonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonName: %w", err)
	}
	return oldValue.ReasonName, nil
}

// ResetReasonName reset all changes of the "reasonName" field.
func (m *CattleDieMutation) ResetReasonName() {
	m.reasonName = nil
}

// SetInsured sets the insured field.
func (m *CattleDieMutation) SetInsured(i int) {
	m.insured = &i
	m.addinsured = nil
}

// Insured returns the insured value in the mutation.
func (m *CattleDieMutation) Insured() (r int, exists bool) {
	v := m.insured
	if v == nil {
		return
	}
	return *v, true
}

// OldInsured returns the old insured value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldInsured(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsured is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsured: %w", err)
	}
	return oldValue.Insured, nil
}

// AddInsured adds i to insured.
func (m *CattleDieMutation) AddInsured(i int) {
	if m.addinsured != nil {
		*m.addinsured += i
	} else {
		m.addinsured = &i
	}
}

// AddedInsured returns the value that was added to the insured field in this mutation.
func (m *CattleDieMutation) AddedInsured() (r int, exists bool) {
	v := m.addinsured
	if v == nil {
		return
	}
	return *v, true
}

// ResetInsured reset all changes of the "insured" field.
func (m *CattleDieMutation) ResetInsured() {
	m.insured = nil
	m.addinsured = nil
}

// SetInsuredCode sets the insuredCode field.
func (m *CattleDieMutation) SetInsuredCode(s string) {
	m.insuredCode = &s
}

// InsuredCode returns the insuredCode value in the mutation.
func (m *CattleDieMutation) InsuredCode() (r string, exists bool) {
	v := m.insuredCode
	if v == nil {
		return
	}
	return *v, true
}

// OldInsuredCode returns the old insuredCode value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldInsuredCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsuredCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsuredCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsuredCode: %w", err)
	}
	return oldValue.InsuredCode, nil
}

// ResetInsuredCode reset all changes of the "insuredCode" field.
func (m *CattleDieMutation) ResetInsuredCode() {
	m.insuredCode = nil
}

// SetInsuredCompany sets the insuredCompany field.
func (m *CattleDieMutation) SetInsuredCompany(s string) {
	m.insuredCompany = &s
}

// InsuredCompany returns the insuredCompany value in the mutation.
func (m *CattleDieMutation) InsuredCompany() (r string, exists bool) {
	v := m.insuredCompany
	if v == nil {
		return
	}
	return *v, true
}

// OldInsuredCompany returns the old insuredCompany value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldInsuredCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInsuredCompany is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInsuredCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsuredCompany: %w", err)
	}
	return oldValue.InsuredCompany, nil
}

// ResetInsuredCompany reset all changes of the "insuredCompany" field.
func (m *CattleDieMutation) ResetInsuredCompany() {
	m.insuredCompany = nil
}

// SetWeight sets the weight field.
func (m *CattleDieMutation) SetWeight(i int64) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *CattleDieMutation) Weight() (r int64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldWeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *CattleDieMutation) AddWeight(i int64) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *CattleDieMutation) AddedWeight() (r int64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *CattleDieMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetHandleMethod sets the handleMethod field.
func (m *CattleDieMutation) SetHandleMethod(s string) {
	m.handleMethod = &s
}

// HandleMethod returns the handleMethod value in the mutation.
func (m *CattleDieMutation) HandleMethod() (r string, exists bool) {
	v := m.handleMethod
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleMethod returns the old handleMethod value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldHandleMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHandleMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHandleMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleMethod: %w", err)
	}
	return oldValue.HandleMethod, nil
}

// ResetHandleMethod reset all changes of the "handleMethod" field.
func (m *CattleDieMutation) ResetHandleMethod() {
	m.handleMethod = nil
}

// SetDeclared sets the declared field.
func (m *CattleDieMutation) SetDeclared(i int) {
	m.declared = &i
	m.adddeclared = nil
}

// Declared returns the declared value in the mutation.
func (m *CattleDieMutation) Declared() (r int, exists bool) {
	v := m.declared
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclared returns the old declared value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldDeclared(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeclared is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeclared requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclared: %w", err)
	}
	return oldValue.Declared, nil
}

// AddDeclared adds i to declared.
func (m *CattleDieMutation) AddDeclared(i int) {
	if m.adddeclared != nil {
		*m.adddeclared += i
	} else {
		m.adddeclared = &i
	}
}

// AddedDeclared returns the value that was added to the declared field in this mutation.
func (m *CattleDieMutation) AddedDeclared() (r int, exists bool) {
	v := m.adddeclared
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeclared reset all changes of the "declared" field.
func (m *CattleDieMutation) ResetDeclared() {
	m.declared = nil
	m.adddeclared = nil
}

// SetDUserName sets the dUserName field.
func (m *CattleDieMutation) SetDUserName(s string) {
	m.dUserName = &s
}

// DUserName returns the dUserName value in the mutation.
func (m *CattleDieMutation) DUserName() (r string, exists bool) {
	v := m.dUserName
	if v == nil {
		return
	}
	return *v, true
}

// OldDUserName returns the old dUserName value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldDUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDUserName: %w", err)
	}
	return oldValue.DUserName, nil
}

// ResetDUserName reset all changes of the "dUserName" field.
func (m *CattleDieMutation) ResetDUserName() {
	m.dUserName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleDieMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleDieMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleDieMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleDieMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleDieMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleDieMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleDieMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleDieMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleDieMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleDieMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleDieMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleDieMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleDieMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleDieMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleDieMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleDie.
// If the CattleDie object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleDieMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleDieMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleDieMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleDieMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleDieMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleDie).
func (m *CattleDieMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleDieMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.cattleId != nil {
		fields = append(fields, cattledie.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, cattledie.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattledie.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, cattledie.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, cattledie.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, cattledie.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, cattledie.FieldShedName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattledie.FieldEarNumber)
	}
	if m.date != nil {
		fields = append(fields, cattledie.FieldDate)
	}
	if m.userName != nil {
		fields = append(fields, cattledie.FieldUserName)
	}
	if m.reasonId != nil {
		fields = append(fields, cattledie.FieldReasonId)
	}
	if m.reasonName != nil {
		fields = append(fields, cattledie.FieldReasonName)
	}
	if m.insured != nil {
		fields = append(fields, cattledie.FieldInsured)
	}
	if m.insuredCode != nil {
		fields = append(fields, cattledie.FieldInsuredCode)
	}
	if m.insuredCompany != nil {
		fields = append(fields, cattledie.FieldInsuredCompany)
	}
	if m.weight != nil {
		fields = append(fields, cattledie.FieldWeight)
	}
	if m.handleMethod != nil {
		fields = append(fields, cattledie.FieldHandleMethod)
	}
	if m.declared != nil {
		fields = append(fields, cattledie.FieldDeclared)
	}
	if m.dUserName != nil {
		fields = append(fields, cattledie.FieldDUserName)
	}
	if m.remarks != nil {
		fields = append(fields, cattledie.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattledie.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattledie.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattledie.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleDieMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattledie.FieldCattleId:
		return m.CattleId()
	case cattledie.FieldTenantId:
		return m.TenantId()
	case cattledie.FieldTenantName:
		return m.TenantName()
	case cattledie.FieldFarmId:
		return m.FarmId()
	case cattledie.FieldFarmName:
		return m.FarmName()
	case cattledie.FieldShedId:
		return m.ShedId()
	case cattledie.FieldShedName:
		return m.ShedName()
	case cattledie.FieldEarNumber:
		return m.EarNumber()
	case cattledie.FieldDate:
		return m.Date()
	case cattledie.FieldUserName:
		return m.UserName()
	case cattledie.FieldReasonId:
		return m.ReasonId()
	case cattledie.FieldReasonName:
		return m.ReasonName()
	case cattledie.FieldInsured:
		return m.Insured()
	case cattledie.FieldInsuredCode:
		return m.InsuredCode()
	case cattledie.FieldInsuredCompany:
		return m.InsuredCompany()
	case cattledie.FieldWeight:
		return m.Weight()
	case cattledie.FieldHandleMethod:
		return m.HandleMethod()
	case cattledie.FieldDeclared:
		return m.Declared()
	case cattledie.FieldDUserName:
		return m.DUserName()
	case cattledie.FieldRemarks:
		return m.Remarks()
	case cattledie.FieldCreatedAt:
		return m.CreatedAt()
	case cattledie.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattledie.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleDieMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattledie.FieldCattleId:
		return m.OldCattleId(ctx)
	case cattledie.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattledie.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattledie.FieldFarmId:
		return m.OldFarmId(ctx)
	case cattledie.FieldFarmName:
		return m.OldFarmName(ctx)
	case cattledie.FieldShedId:
		return m.OldShedId(ctx)
	case cattledie.FieldShedName:
		return m.OldShedName(ctx)
	case cattledie.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattledie.FieldDate:
		return m.OldDate(ctx)
	case cattledie.FieldUserName:
		return m.OldUserName(ctx)
	case cattledie.FieldReasonId:
		return m.OldReasonId(ctx)
	case cattledie.FieldReasonName:
		return m.OldReasonName(ctx)
	case cattledie.FieldInsured:
		return m.OldInsured(ctx)
	case cattledie.FieldInsuredCode:
		return m.OldInsuredCode(ctx)
	case cattledie.FieldInsuredCompany:
		return m.OldInsuredCompany(ctx)
	case cattledie.FieldWeight:
		return m.OldWeight(ctx)
	case cattledie.FieldHandleMethod:
		return m.OldHandleMethod(ctx)
	case cattledie.FieldDeclared:
		return m.OldDeclared(ctx)
	case cattledie.FieldDUserName:
		return m.OldDUserName(ctx)
	case cattledie.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattledie.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattledie.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattledie.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleDie field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleDieMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattledie.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case cattledie.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattledie.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattledie.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case cattledie.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case cattledie.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case cattledie.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattledie.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattledie.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case cattledie.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case cattledie.FieldReasonId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonId(v)
		return nil
	case cattledie.FieldReasonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonName(v)
		return nil
	case cattledie.FieldInsured:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsured(v)
		return nil
	case cattledie.FieldInsuredCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsuredCode(v)
		return nil
	case cattledie.FieldInsuredCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsuredCompany(v)
		return nil
	case cattledie.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case cattledie.FieldHandleMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleMethod(v)
		return nil
	case cattledie.FieldDeclared:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclared(v)
		return nil
	case cattledie.FieldDUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDUserName(v)
		return nil
	case cattledie.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattledie.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattledie.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattledie.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleDie field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleDieMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, cattledie.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattledie.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, cattledie.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, cattledie.FieldShedId)
	}
	if m.adddate != nil {
		fields = append(fields, cattledie.FieldDate)
	}
	if m.addreasonId != nil {
		fields = append(fields, cattledie.FieldReasonId)
	}
	if m.addinsured != nil {
		fields = append(fields, cattledie.FieldInsured)
	}
	if m.addweight != nil {
		fields = append(fields, cattledie.FieldWeight)
	}
	if m.adddeclared != nil {
		fields = append(fields, cattledie.FieldDeclared)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattledie.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattledie.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattledie.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleDieMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattledie.FieldCattleId:
		return m.AddedCattleId()
	case cattledie.FieldTenantId:
		return m.AddedTenantId()
	case cattledie.FieldFarmId:
		return m.AddedFarmId()
	case cattledie.FieldShedId:
		return m.AddedShedId()
	case cattledie.FieldDate:
		return m.AddedDate()
	case cattledie.FieldReasonId:
		return m.AddedReasonId()
	case cattledie.FieldInsured:
		return m.AddedInsured()
	case cattledie.FieldWeight:
		return m.AddedWeight()
	case cattledie.FieldDeclared:
		return m.AddedDeclared()
	case cattledie.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattledie.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattledie.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleDieMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattledie.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case cattledie.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattledie.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case cattledie.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case cattledie.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case cattledie.FieldReasonId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReasonId(v)
		return nil
	case cattledie.FieldInsured:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInsured(v)
		return nil
	case cattledie.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case cattledie.FieldDeclared:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeclared(v)
		return nil
	case cattledie.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattledie.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattledie.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleDie numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleDieMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleDieMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleDieMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleDie nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleDieMutation) ResetField(name string) error {
	switch name {
	case cattledie.FieldCattleId:
		m.ResetCattleId()
		return nil
	case cattledie.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattledie.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattledie.FieldFarmId:
		m.ResetFarmId()
		return nil
	case cattledie.FieldFarmName:
		m.ResetFarmName()
		return nil
	case cattledie.FieldShedId:
		m.ResetShedId()
		return nil
	case cattledie.FieldShedName:
		m.ResetShedName()
		return nil
	case cattledie.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattledie.FieldDate:
		m.ResetDate()
		return nil
	case cattledie.FieldUserName:
		m.ResetUserName()
		return nil
	case cattledie.FieldReasonId:
		m.ResetReasonId()
		return nil
	case cattledie.FieldReasonName:
		m.ResetReasonName()
		return nil
	case cattledie.FieldInsured:
		m.ResetInsured()
		return nil
	case cattledie.FieldInsuredCode:
		m.ResetInsuredCode()
		return nil
	case cattledie.FieldInsuredCompany:
		m.ResetInsuredCompany()
		return nil
	case cattledie.FieldWeight:
		m.ResetWeight()
		return nil
	case cattledie.FieldHandleMethod:
		m.ResetHandleMethod()
		return nil
	case cattledie.FieldDeclared:
		m.ResetDeclared()
		return nil
	case cattledie.FieldDUserName:
		m.ResetDUserName()
		return nil
	case cattledie.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattledie.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattledie.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattledie.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleDie field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleDieMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleDieMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleDieMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleDieMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleDieMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleDieMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleDieMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleDie unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleDieMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleDie edge %s", name)
}

// CattleGenderMutation represents an operation that mutate the CattleGenders
// nodes in the graph.
type CattleGenderMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleGender, error)
}

var _ ent.Mutation = (*CattleGenderMutation)(nil)

// cattlegenderOption allows to manage the mutation configuration using functional options.
type cattlegenderOption func(*CattleGenderMutation)

// newCattleGenderMutation creates new mutation for $n.Name.
func newCattleGenderMutation(c config, op Op, opts ...cattlegenderOption) *CattleGenderMutation {
	m := &CattleGenderMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGenderID sets the id field of the mutation.
func withCattleGenderID(id int64) cattlegenderOption {
	return func(m *CattleGenderMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGender
		)
		m.oldValue = func(ctx context.Context) (*CattleGender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGender sets the old CattleGender of the mutation.
func withCattleGender(node *CattleGender) cattlegenderOption {
	return func(m *CattleGenderMutation) {
		m.oldValue = func(context.Context) (*CattleGender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGenderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleGenderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGenderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGender.
// If the CattleGender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGenderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleGenderMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleGenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGender).
func (m *CattleGenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattlegender.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegender.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegender.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegender.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleGender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleGender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGenderMutation) ResetField(name string) error {
	switch name {
	case cattlegender.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleGender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGenderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGenderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGenderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGenderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGenderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGender edge %s", name)
}

// CattleGroupMutation represents an operation that mutate the CattleGroups
// nodes in the graph.
type CattleGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	earNumber     *string
	date          *int64
	adddate       *int64
	toShed        *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleGroup, error)
}

var _ ent.Mutation = (*CattleGroupMutation)(nil)

// cattlegroupOption allows to manage the mutation configuration using functional options.
type cattlegroupOption func(*CattleGroupMutation)

// newCattleGroupMutation creates new mutation for $n.Name.
func newCattleGroupMutation(c config, op Op, opts ...cattlegroupOption) *CattleGroupMutation {
	m := &CattleGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGroupID sets the id field of the mutation.
func withCattleGroupID(id int64) cattlegroupOption {
	return func(m *CattleGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGroup
		)
		m.oldValue = func(ctx context.Context) (*CattleGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGroup sets the old CattleGroup of the mutation.
func withCattleGroup(node *CattleGroup) cattlegroupOption {
	return func(m *CattleGroupMutation) {
		m.oldValue = func(context.Context) (*CattleGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEarNumber sets the earNumber field.
func (m *CattleGroupMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleGroupMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleGroupMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetDate sets the date field.
func (m *CattleGroupMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *CattleGroupMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *CattleGroupMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *CattleGroupMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *CattleGroupMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetToShed sets the toShed field.
func (m *CattleGroupMutation) SetToShed(s string) {
	m.toShed = &s
}

// ToShed returns the toShed value in the mutation.
func (m *CattleGroupMutation) ToShed() (r string, exists bool) {
	v := m.toShed
	if v == nil {
		return
	}
	return *v, true
}

// OldToShed returns the old toShed value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldToShed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToShed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToShed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToShed: %w", err)
	}
	return oldValue.ToShed, nil
}

// ResetToShed reset all changes of the "toShed" field.
func (m *CattleGroupMutation) ResetToShed() {
	m.toShed = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleGroupMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleGroupMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleGroupMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleGroupMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleGroupMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleGroupMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleGroupMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleGroupMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleGroupMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleGroupMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleGroupMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleGroupMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleGroupMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleGroupMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleGroupMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleGroupMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleGroupMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleGroupMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleGroupMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleGroupMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleGroupMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleGroupMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleGroupMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleGroup.
// If the CattleGroup object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGroupMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleGroupMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleGroupMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleGroupMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGroup).
func (m *CattleGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGroupMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.earNumber != nil {
		fields = append(fields, cattlegroup.FieldEarNumber)
	}
	if m.date != nil {
		fields = append(fields, cattlegroup.FieldDate)
	}
	if m.toShed != nil {
		fields = append(fields, cattlegroup.FieldToShed)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlegroup.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlegroup.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, cattlegroup.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlegroup.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlegroup.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlegroup.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegroup.FieldEarNumber:
		return m.EarNumber()
	case cattlegroup.FieldDate:
		return m.Date()
	case cattlegroup.FieldToShed:
		return m.ToShed()
	case cattlegroup.FieldTenantId:
		return m.TenantId()
	case cattlegroup.FieldTenantName:
		return m.TenantName()
	case cattlegroup.FieldRemarks:
		return m.Remarks()
	case cattlegroup.FieldCreatedAt:
		return m.CreatedAt()
	case cattlegroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlegroup.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegroup.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlegroup.FieldDate:
		return m.OldDate(ctx)
	case cattlegroup.FieldToShed:
		return m.OldToShed(ctx)
	case cattlegroup.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlegroup.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlegroup.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlegroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlegroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlegroup.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGroup field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegroup.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlegroup.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case cattlegroup.FieldToShed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToShed(v)
		return nil
	case cattlegroup.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlegroup.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlegroup.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlegroup.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlegroup.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlegroup.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGroupMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, cattlegroup.FieldDate)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattlegroup.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlegroup.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlegroup.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlegroup.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlegroup.FieldDate:
		return m.AddedDate()
	case cattlegroup.FieldTenantId:
		return m.AddedTenantId()
	case cattlegroup.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlegroup.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlegroup.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlegroup.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case cattlegroup.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlegroup.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlegroup.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlegroup.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGroupMutation) ResetField(name string) error {
	switch name {
	case cattlegroup.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlegroup.FieldDate:
		m.ResetDate()
		return nil
	case cattlegroup.FieldToShed:
		m.ResetToShed()
		return nil
	case cattlegroup.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlegroup.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlegroup.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlegroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlegroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlegroup.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGroup unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGroup edge %s", name)
}

// CattleGrowMutation represents an operation that mutate the CattleGrows
// nodes in the graph.
type CattleGrowMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	earNumber          *string
	stage              *string
	dateStart          *int64
	adddateStart       *int64
	dateEnd            *int64
	adddateEnd         *int64
	weightStart        *float32
	addweightStart     *float32
	weightEnd          *float32
	addweightEnd       *float32
	dailyWeight        *float32
	adddailyWeight     *float32
	feedWeight         *float32
	addfeedWeight      *float32
	dailyFeedWeight    *float32
	adddailyFeedWeight *float32
	conversionRate     *float32
	addconversionRate  *float32
	userName           *string
	tenantId           *int64
	addtenantId        *int64
	tenantName         *string
	remarks            *string
	createdAt          *int64
	addcreatedAt       *int64
	updatedAt          *int64
	addupdatedAt       *int64
	deleted            *int
	adddeleted         *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*CattleGrow, error)
}

var _ ent.Mutation = (*CattleGrowMutation)(nil)

// cattlegrowOption allows to manage the mutation configuration using functional options.
type cattlegrowOption func(*CattleGrowMutation)

// newCattleGrowMutation creates new mutation for $n.Name.
func newCattleGrowMutation(c config, op Op, opts ...cattlegrowOption) *CattleGrowMutation {
	m := &CattleGrowMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGrow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGrowID sets the id field of the mutation.
func withCattleGrowID(id int64) cattlegrowOption {
	return func(m *CattleGrowMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGrow
		)
		m.oldValue = func(ctx context.Context) (*CattleGrow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGrow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGrow sets the old CattleGrow of the mutation.
func withCattleGrow(node *CattleGrow) cattlegrowOption {
	return func(m *CattleGrowMutation) {
		m.oldValue = func(context.Context) (*CattleGrow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGrowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGrowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGrowMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleGrowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGrowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleGrowMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattlegrow.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleGrowMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattlegrow.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleGrowMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattlegrow.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CattleGrowMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleGrowMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleGrowMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetStage sets the stage field.
func (m *CattleGrowMutation) SetStage(s string) {
	m.stage = &s
}

// Stage returns the stage value in the mutation.
func (m *CattleGrowMutation) Stage() (r string, exists bool) {
	v := m.stage
	if v == nil {
		return
	}
	return *v, true
}

// OldStage returns the old stage value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldStage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStage: %w", err)
	}
	return oldValue.Stage, nil
}

// ResetStage reset all changes of the "stage" field.
func (m *CattleGrowMutation) ResetStage() {
	m.stage = nil
}

// SetDateStart sets the dateStart field.
func (m *CattleGrowMutation) SetDateStart(i int64) {
	m.dateStart = &i
	m.adddateStart = nil
}

// DateStart returns the dateStart value in the mutation.
func (m *CattleGrowMutation) DateStart() (r int64, exists bool) {
	v := m.dateStart
	if v == nil {
		return
	}
	return *v, true
}

// OldDateStart returns the old dateStart value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDateStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateStart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateStart: %w", err)
	}
	return oldValue.DateStart, nil
}

// AddDateStart adds i to dateStart.
func (m *CattleGrowMutation) AddDateStart(i int64) {
	if m.adddateStart != nil {
		*m.adddateStart += i
	} else {
		m.adddateStart = &i
	}
}

// AddedDateStart returns the value that was added to the dateStart field in this mutation.
func (m *CattleGrowMutation) AddedDateStart() (r int64, exists bool) {
	v := m.adddateStart
	if v == nil {
		return
	}
	return *v, true
}

// ResetDateStart reset all changes of the "dateStart" field.
func (m *CattleGrowMutation) ResetDateStart() {
	m.dateStart = nil
	m.adddateStart = nil
}

// SetDateEnd sets the dateEnd field.
func (m *CattleGrowMutation) SetDateEnd(i int64) {
	m.dateEnd = &i
	m.adddateEnd = nil
}

// DateEnd returns the dateEnd value in the mutation.
func (m *CattleGrowMutation) DateEnd() (r int64, exists bool) {
	v := m.dateEnd
	if v == nil {
		return
	}
	return *v, true
}

// OldDateEnd returns the old dateEnd value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDateEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateEnd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateEnd: %w", err)
	}
	return oldValue.DateEnd, nil
}

// AddDateEnd adds i to dateEnd.
func (m *CattleGrowMutation) AddDateEnd(i int64) {
	if m.adddateEnd != nil {
		*m.adddateEnd += i
	} else {
		m.adddateEnd = &i
	}
}

// AddedDateEnd returns the value that was added to the dateEnd field in this mutation.
func (m *CattleGrowMutation) AddedDateEnd() (r int64, exists bool) {
	v := m.adddateEnd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDateEnd reset all changes of the "dateEnd" field.
func (m *CattleGrowMutation) ResetDateEnd() {
	m.dateEnd = nil
	m.adddateEnd = nil
}

// SetWeightStart sets the weightStart field.
func (m *CattleGrowMutation) SetWeightStart(f float32) {
	m.weightStart = &f
	m.addweightStart = nil
}

// WeightStart returns the weightStart value in the mutation.
func (m *CattleGrowMutation) WeightStart() (r float32, exists bool) {
	v := m.weightStart
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightStart returns the old weightStart value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldWeightStart(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightStart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightStart: %w", err)
	}
	return oldValue.WeightStart, nil
}

// AddWeightStart adds f to weightStart.
func (m *CattleGrowMutation) AddWeightStart(f float32) {
	if m.addweightStart != nil {
		*m.addweightStart += f
	} else {
		m.addweightStart = &f
	}
}

// AddedWeightStart returns the value that was added to the weightStart field in this mutation.
func (m *CattleGrowMutation) AddedWeightStart() (r float32, exists bool) {
	v := m.addweightStart
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightStart reset all changes of the "weightStart" field.
func (m *CattleGrowMutation) ResetWeightStart() {
	m.weightStart = nil
	m.addweightStart = nil
}

// SetWeightEnd sets the weightEnd field.
func (m *CattleGrowMutation) SetWeightEnd(f float32) {
	m.weightEnd = &f
	m.addweightEnd = nil
}

// WeightEnd returns the weightEnd value in the mutation.
func (m *CattleGrowMutation) WeightEnd() (r float32, exists bool) {
	v := m.weightEnd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightEnd returns the old weightEnd value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldWeightEnd(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeightEnd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeightEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightEnd: %w", err)
	}
	return oldValue.WeightEnd, nil
}

// AddWeightEnd adds f to weightEnd.
func (m *CattleGrowMutation) AddWeightEnd(f float32) {
	if m.addweightEnd != nil {
		*m.addweightEnd += f
	} else {
		m.addweightEnd = &f
	}
}

// AddedWeightEnd returns the value that was added to the weightEnd field in this mutation.
func (m *CattleGrowMutation) AddedWeightEnd() (r float32, exists bool) {
	v := m.addweightEnd
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeightEnd reset all changes of the "weightEnd" field.
func (m *CattleGrowMutation) ResetWeightEnd() {
	m.weightEnd = nil
	m.addweightEnd = nil
}

// SetDailyWeight sets the dailyWeight field.
func (m *CattleGrowMutation) SetDailyWeight(f float32) {
	m.dailyWeight = &f
	m.adddailyWeight = nil
}

// DailyWeight returns the dailyWeight value in the mutation.
func (m *CattleGrowMutation) DailyWeight() (r float32, exists bool) {
	v := m.dailyWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyWeight returns the old dailyWeight value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDailyWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyWeight: %w", err)
	}
	return oldValue.DailyWeight, nil
}

// AddDailyWeight adds f to dailyWeight.
func (m *CattleGrowMutation) AddDailyWeight(f float32) {
	if m.adddailyWeight != nil {
		*m.adddailyWeight += f
	} else {
		m.adddailyWeight = &f
	}
}

// AddedDailyWeight returns the value that was added to the dailyWeight field in this mutation.
func (m *CattleGrowMutation) AddedDailyWeight() (r float32, exists bool) {
	v := m.adddailyWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyWeight reset all changes of the "dailyWeight" field.
func (m *CattleGrowMutation) ResetDailyWeight() {
	m.dailyWeight = nil
	m.adddailyWeight = nil
}

// SetFeedWeight sets the feedWeight field.
func (m *CattleGrowMutation) SetFeedWeight(f float32) {
	m.feedWeight = &f
	m.addfeedWeight = nil
}

// FeedWeight returns the feedWeight value in the mutation.
func (m *CattleGrowMutation) FeedWeight() (r float32, exists bool) {
	v := m.feedWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedWeight returns the old feedWeight value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldFeedWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFeedWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFeedWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedWeight: %w", err)
	}
	return oldValue.FeedWeight, nil
}

// AddFeedWeight adds f to feedWeight.
func (m *CattleGrowMutation) AddFeedWeight(f float32) {
	if m.addfeedWeight != nil {
		*m.addfeedWeight += f
	} else {
		m.addfeedWeight = &f
	}
}

// AddedFeedWeight returns the value that was added to the feedWeight field in this mutation.
func (m *CattleGrowMutation) AddedFeedWeight() (r float32, exists bool) {
	v := m.addfeedWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetFeedWeight reset all changes of the "feedWeight" field.
func (m *CattleGrowMutation) ResetFeedWeight() {
	m.feedWeight = nil
	m.addfeedWeight = nil
}

// SetDailyFeedWeight sets the dailyFeedWeight field.
func (m *CattleGrowMutation) SetDailyFeedWeight(f float32) {
	m.dailyFeedWeight = &f
	m.adddailyFeedWeight = nil
}

// DailyFeedWeight returns the dailyFeedWeight value in the mutation.
func (m *CattleGrowMutation) DailyFeedWeight() (r float32, exists bool) {
	v := m.dailyFeedWeight
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyFeedWeight returns the old dailyFeedWeight value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDailyFeedWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDailyFeedWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDailyFeedWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyFeedWeight: %w", err)
	}
	return oldValue.DailyFeedWeight, nil
}

// AddDailyFeedWeight adds f to dailyFeedWeight.
func (m *CattleGrowMutation) AddDailyFeedWeight(f float32) {
	if m.adddailyFeedWeight != nil {
		*m.adddailyFeedWeight += f
	} else {
		m.adddailyFeedWeight = &f
	}
}

// AddedDailyFeedWeight returns the value that was added to the dailyFeedWeight field in this mutation.
func (m *CattleGrowMutation) AddedDailyFeedWeight() (r float32, exists bool) {
	v := m.adddailyFeedWeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyFeedWeight reset all changes of the "dailyFeedWeight" field.
func (m *CattleGrowMutation) ResetDailyFeedWeight() {
	m.dailyFeedWeight = nil
	m.adddailyFeedWeight = nil
}

// SetConversionRate sets the conversionRate field.
func (m *CattleGrowMutation) SetConversionRate(f float32) {
	m.conversionRate = &f
	m.addconversionRate = nil
}

// ConversionRate returns the conversionRate value in the mutation.
func (m *CattleGrowMutation) ConversionRate() (r float32, exists bool) {
	v := m.conversionRate
	if v == nil {
		return
	}
	return *v, true
}

// OldConversionRate returns the old conversionRate value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldConversionRate(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConversionRate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConversionRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversionRate: %w", err)
	}
	return oldValue.ConversionRate, nil
}

// AddConversionRate adds f to conversionRate.
func (m *CattleGrowMutation) AddConversionRate(f float32) {
	if m.addconversionRate != nil {
		*m.addconversionRate += f
	} else {
		m.addconversionRate = &f
	}
}

// AddedConversionRate returns the value that was added to the conversionRate field in this mutation.
func (m *CattleGrowMutation) AddedConversionRate() (r float32, exists bool) {
	v := m.addconversionRate
	if v == nil {
		return
	}
	return *v, true
}

// ResetConversionRate reset all changes of the "conversionRate" field.
func (m *CattleGrowMutation) ResetConversionRate() {
	m.conversionRate = nil
	m.addconversionRate = nil
}

// SetUserName sets the userName field.
func (m *CattleGrowMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CattleGrowMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CattleGrowMutation) ResetUserName() {
	m.userName = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleGrowMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleGrowMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleGrowMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleGrowMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleGrowMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleGrowMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleGrowMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleGrowMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleGrowMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleGrowMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleGrowMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleGrowMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleGrowMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleGrowMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleGrowMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleGrowMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleGrowMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleGrowMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleGrowMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleGrowMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleGrowMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleGrowMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleGrowMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleGrow.
// If the CattleGrow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleGrowMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleGrowMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleGrowMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleGrowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGrow).
func (m *CattleGrowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGrowMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.name != nil {
		fields = append(fields, cattlegrow.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattlegrow.FieldEarNumber)
	}
	if m.stage != nil {
		fields = append(fields, cattlegrow.FieldStage)
	}
	if m.dateStart != nil {
		fields = append(fields, cattlegrow.FieldDateStart)
	}
	if m.dateEnd != nil {
		fields = append(fields, cattlegrow.FieldDateEnd)
	}
	if m.weightStart != nil {
		fields = append(fields, cattlegrow.FieldWeightStart)
	}
	if m.weightEnd != nil {
		fields = append(fields, cattlegrow.FieldWeightEnd)
	}
	if m.dailyWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyWeight)
	}
	if m.feedWeight != nil {
		fields = append(fields, cattlegrow.FieldFeedWeight)
	}
	if m.dailyFeedWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyFeedWeight)
	}
	if m.conversionRate != nil {
		fields = append(fields, cattlegrow.FieldConversionRate)
	}
	if m.userName != nil {
		fields = append(fields, cattlegrow.FieldUserName)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlegrow.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlegrow.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, cattlegrow.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlegrow.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlegrow.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlegrow.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGrowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegrow.FieldName:
		return m.Name()
	case cattlegrow.FieldEarNumber:
		return m.EarNumber()
	case cattlegrow.FieldStage:
		return m.Stage()
	case cattlegrow.FieldDateStart:
		return m.DateStart()
	case cattlegrow.FieldDateEnd:
		return m.DateEnd()
	case cattlegrow.FieldWeightStart:
		return m.WeightStart()
	case cattlegrow.FieldWeightEnd:
		return m.WeightEnd()
	case cattlegrow.FieldDailyWeight:
		return m.DailyWeight()
	case cattlegrow.FieldFeedWeight:
		return m.FeedWeight()
	case cattlegrow.FieldDailyFeedWeight:
		return m.DailyFeedWeight()
	case cattlegrow.FieldConversionRate:
		return m.ConversionRate()
	case cattlegrow.FieldUserName:
		return m.UserName()
	case cattlegrow.FieldTenantId:
		return m.TenantId()
	case cattlegrow.FieldTenantName:
		return m.TenantName()
	case cattlegrow.FieldRemarks:
		return m.Remarks()
	case cattlegrow.FieldCreatedAt:
		return m.CreatedAt()
	case cattlegrow.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlegrow.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGrowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegrow.FieldName:
		return m.OldName(ctx)
	case cattlegrow.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlegrow.FieldStage:
		return m.OldStage(ctx)
	case cattlegrow.FieldDateStart:
		return m.OldDateStart(ctx)
	case cattlegrow.FieldDateEnd:
		return m.OldDateEnd(ctx)
	case cattlegrow.FieldWeightStart:
		return m.OldWeightStart(ctx)
	case cattlegrow.FieldWeightEnd:
		return m.OldWeightEnd(ctx)
	case cattlegrow.FieldDailyWeight:
		return m.OldDailyWeight(ctx)
	case cattlegrow.FieldFeedWeight:
		return m.OldFeedWeight(ctx)
	case cattlegrow.FieldDailyFeedWeight:
		return m.OldDailyFeedWeight(ctx)
	case cattlegrow.FieldConversionRate:
		return m.OldConversionRate(ctx)
	case cattlegrow.FieldUserName:
		return m.OldUserName(ctx)
	case cattlegrow.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlegrow.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlegrow.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlegrow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlegrow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlegrow.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGrow field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegrow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlegrow.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlegrow.FieldStage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStage(v)
		return nil
	case cattlegrow.FieldDateStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateStart(v)
		return nil
	case cattlegrow.FieldDateEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateEnd(v)
		return nil
	case cattlegrow.FieldWeightStart:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightStart(v)
		return nil
	case cattlegrow.FieldWeightEnd:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightEnd(v)
		return nil
	case cattlegrow.FieldDailyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyWeight(v)
		return nil
	case cattlegrow.FieldFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedWeight(v)
		return nil
	case cattlegrow.FieldDailyFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyFeedWeight(v)
		return nil
	case cattlegrow.FieldConversionRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversionRate(v)
		return nil
	case cattlegrow.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case cattlegrow.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlegrow.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlegrow.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlegrow.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlegrow.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlegrow.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGrowMutation) AddedFields() []string {
	var fields []string
	if m.adddateStart != nil {
		fields = append(fields, cattlegrow.FieldDateStart)
	}
	if m.adddateEnd != nil {
		fields = append(fields, cattlegrow.FieldDateEnd)
	}
	if m.addweightStart != nil {
		fields = append(fields, cattlegrow.FieldWeightStart)
	}
	if m.addweightEnd != nil {
		fields = append(fields, cattlegrow.FieldWeightEnd)
	}
	if m.adddailyWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyWeight)
	}
	if m.addfeedWeight != nil {
		fields = append(fields, cattlegrow.FieldFeedWeight)
	}
	if m.adddailyFeedWeight != nil {
		fields = append(fields, cattlegrow.FieldDailyFeedWeight)
	}
	if m.addconversionRate != nil {
		fields = append(fields, cattlegrow.FieldConversionRate)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattlegrow.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlegrow.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlegrow.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlegrow.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGrowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlegrow.FieldDateStart:
		return m.AddedDateStart()
	case cattlegrow.FieldDateEnd:
		return m.AddedDateEnd()
	case cattlegrow.FieldWeightStart:
		return m.AddedWeightStart()
	case cattlegrow.FieldWeightEnd:
		return m.AddedWeightEnd()
	case cattlegrow.FieldDailyWeight:
		return m.AddedDailyWeight()
	case cattlegrow.FieldFeedWeight:
		return m.AddedFeedWeight()
	case cattlegrow.FieldDailyFeedWeight:
		return m.AddedDailyFeedWeight()
	case cattlegrow.FieldConversionRate:
		return m.AddedConversionRate()
	case cattlegrow.FieldTenantId:
		return m.AddedTenantId()
	case cattlegrow.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlegrow.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlegrow.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlegrow.FieldDateStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDateStart(v)
		return nil
	case cattlegrow.FieldDateEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDateEnd(v)
		return nil
	case cattlegrow.FieldWeightStart:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightStart(v)
		return nil
	case cattlegrow.FieldWeightEnd:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightEnd(v)
		return nil
	case cattlegrow.FieldDailyWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyWeight(v)
		return nil
	case cattlegrow.FieldFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeedWeight(v)
		return nil
	case cattlegrow.FieldDailyFeedWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyFeedWeight(v)
		return nil
	case cattlegrow.FieldConversionRate:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConversionRate(v)
		return nil
	case cattlegrow.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlegrow.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlegrow.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlegrow.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGrowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattlegrow.FieldName) {
		fields = append(fields, cattlegrow.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGrowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGrowMutation) ClearField(name string) error {
	switch name {
	case cattlegrow.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown CattleGrow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGrowMutation) ResetField(name string) error {
	switch name {
	case cattlegrow.FieldName:
		m.ResetName()
		return nil
	case cattlegrow.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlegrow.FieldStage:
		m.ResetStage()
		return nil
	case cattlegrow.FieldDateStart:
		m.ResetDateStart()
		return nil
	case cattlegrow.FieldDateEnd:
		m.ResetDateEnd()
		return nil
	case cattlegrow.FieldWeightStart:
		m.ResetWeightStart()
		return nil
	case cattlegrow.FieldWeightEnd:
		m.ResetWeightEnd()
		return nil
	case cattlegrow.FieldDailyWeight:
		m.ResetDailyWeight()
		return nil
	case cattlegrow.FieldFeedWeight:
		m.ResetFeedWeight()
		return nil
	case cattlegrow.FieldDailyFeedWeight:
		m.ResetDailyFeedWeight()
		return nil
	case cattlegrow.FieldConversionRate:
		m.ResetConversionRate()
		return nil
	case cattlegrow.FieldUserName:
		m.ResetUserName()
		return nil
	case cattlegrow.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlegrow.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlegrow.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlegrow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlegrow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlegrow.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleGrow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGrowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGrowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGrowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGrowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGrowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGrowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGrowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGrow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGrowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGrow edge %s", name)
}

// CattleGrowsDataMutation represents an operation that mutate the CattleGrowsDataSlice
// nodes in the graph.
type CattleGrowsDataMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	cattleId      *int64
	addcattleId   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	shedId        *int64
	addshedId     *int64
	shedName      *string
	name          *string
	earNumber     *string
	measuredAt    *int64
	addmeasuredAt *int64
	measuredBy    *string
	weight        *int
	addweight     *int
	bust          *int
	addbust       *int
	height        *int
	addheight     *int
	score         *int
	addscore      *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleGrowsData, error)
}

var _ ent.Mutation = (*CattleGrowsDataMutation)(nil)

// cattlegrowsdataOption allows to manage the mutation configuration using functional options.
type cattlegrowsdataOption func(*CattleGrowsDataMutation)

// newCattleGrowsDataMutation creates new mutation for $n.Name.
func newCattleGrowsDataMutation(c config, op Op, opts ...cattlegrowsdataOption) *CattleGrowsDataMutation {
	m := &CattleGrowsDataMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGrowsData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGrowsDataID sets the id field of the mutation.
func withCattleGrowsDataID(id int64) cattlegrowsdataOption {
	return func(m *CattleGrowsDataMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGrowsData
		)
		m.oldValue = func(ctx context.Context) (*CattleGrowsData, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGrowsData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGrowsData sets the old CattleGrowsData of the mutation.
func withCattleGrowsData(node *CattleGrowsData) cattlegrowsdataOption {
	return func(m *CattleGrowsDataMutation) {
		m.oldValue = func(context.Context) (*CattleGrowsData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGrowsDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGrowsDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGrowsDataMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *CattleGrowsDataMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *CattleGrowsDataMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *CattleGrowsDataMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *CattleGrowsDataMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *CattleGrowsDataMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleGrowsDataMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleGrowsDataMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleGrowsDataMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleGrowsDataMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleGrowsDataMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleGrowsDataMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleGrowsDataMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleGrowsDataMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *CattleGrowsDataMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *CattleGrowsDataMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *CattleGrowsDataMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *CattleGrowsDataMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *CattleGrowsDataMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *CattleGrowsDataMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *CattleGrowsDataMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *CattleGrowsDataMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *CattleGrowsDataMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *CattleGrowsDataMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *CattleGrowsDataMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *CattleGrowsDataMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *CattleGrowsDataMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *CattleGrowsDataMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleGrowsDataMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleGrowsDataMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *CattleGrowsDataMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGrowsDataMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleGrowsDataMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattlegrowsdata.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleGrowsDataMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattlegrowsdata.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleGrowsDataMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattlegrowsdata.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CattleGrowsDataMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleGrowsDataMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleGrowsDataMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetMeasuredAt sets the measuredAt field.
func (m *CattleGrowsDataMutation) SetMeasuredAt(i int64) {
	m.measuredAt = &i
	m.addmeasuredAt = nil
}

// MeasuredAt returns the measuredAt value in the mutation.
func (m *CattleGrowsDataMutation) MeasuredAt() (r int64, exists bool) {
	v := m.measuredAt
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasuredAt returns the old measuredAt value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldMeasuredAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMeasuredAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMeasuredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasuredAt: %w", err)
	}
	return oldValue.MeasuredAt, nil
}

// AddMeasuredAt adds i to measuredAt.
func (m *CattleGrowsDataMutation) AddMeasuredAt(i int64) {
	if m.addmeasuredAt != nil {
		*m.addmeasuredAt += i
	} else {
		m.addmeasuredAt = &i
	}
}

// AddedMeasuredAt returns the value that was added to the measuredAt field in this mutation.
func (m *CattleGrowsDataMutation) AddedMeasuredAt() (r int64, exists bool) {
	v := m.addmeasuredAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetMeasuredAt reset all changes of the "measuredAt" field.
func (m *CattleGrowsDataMutation) ResetMeasuredAt() {
	m.measuredAt = nil
	m.addmeasuredAt = nil
}

// SetMeasuredBy sets the measuredBy field.
func (m *CattleGrowsDataMutation) SetMeasuredBy(s string) {
	m.measuredBy = &s
}

// MeasuredBy returns the measuredBy value in the mutation.
func (m *CattleGrowsDataMutation) MeasuredBy() (r string, exists bool) {
	v := m.measuredBy
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasuredBy returns the old measuredBy value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldMeasuredBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMeasuredBy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMeasuredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasuredBy: %w", err)
	}
	return oldValue.MeasuredBy, nil
}

// ResetMeasuredBy reset all changes of the "measuredBy" field.
func (m *CattleGrowsDataMutation) ResetMeasuredBy() {
	m.measuredBy = nil
}

// SetWeight sets the weight field.
func (m *CattleGrowsDataMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *CattleGrowsDataMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *CattleGrowsDataMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *CattleGrowsDataMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *CattleGrowsDataMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetBust sets the bust field.
func (m *CattleGrowsDataMutation) SetBust(i int) {
	m.bust = &i
	m.addbust = nil
}

// Bust returns the bust value in the mutation.
func (m *CattleGrowsDataMutation) Bust() (r int, exists bool) {
	v := m.bust
	if v == nil {
		return
	}
	return *v, true
}

// OldBust returns the old bust value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldBust(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBust is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBust requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBust: %w", err)
	}
	return oldValue.Bust, nil
}

// AddBust adds i to bust.
func (m *CattleGrowsDataMutation) AddBust(i int) {
	if m.addbust != nil {
		*m.addbust += i
	} else {
		m.addbust = &i
	}
}

// AddedBust returns the value that was added to the bust field in this mutation.
func (m *CattleGrowsDataMutation) AddedBust() (r int, exists bool) {
	v := m.addbust
	if v == nil {
		return
	}
	return *v, true
}

// ResetBust reset all changes of the "bust" field.
func (m *CattleGrowsDataMutation) ResetBust() {
	m.bust = nil
	m.addbust = nil
}

// SetHeight sets the height field.
func (m *CattleGrowsDataMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the height value in the mutation.
func (m *CattleGrowsDataMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old height value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to height.
func (m *CattleGrowsDataMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the height field in this mutation.
func (m *CattleGrowsDataMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight reset all changes of the "height" field.
func (m *CattleGrowsDataMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetScore sets the score field.
func (m *CattleGrowsDataMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the score value in the mutation.
func (m *CattleGrowsDataMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old score value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldScore is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to score.
func (m *CattleGrowsDataMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the score field in this mutation.
func (m *CattleGrowsDataMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore reset all changes of the "score" field.
func (m *CattleGrowsDataMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetRemarks sets the remarks field.
func (m *CattleGrowsDataMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleGrowsDataMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleGrowsDataMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleGrowsDataMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleGrowsDataMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleGrowsDataMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleGrowsDataMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleGrowsDataMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleGrowsDataMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleGrowsDataMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleGrowsDataMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleGrowsDataMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleGrowsDataMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleGrowsDataMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleGrowsDataMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleGrowsData.
// If the CattleGrowsData object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsDataMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleGrowsDataMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleGrowsDataMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleGrowsDataMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleGrowsDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGrowsData).
func (m *CattleGrowsDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGrowsDataMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.cattleId != nil {
		fields = append(fields, cattlegrowsdata.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlegrowsdata.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlegrowsdata.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, cattlegrowsdata.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, cattlegrowsdata.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, cattlegrowsdata.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, cattlegrowsdata.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, cattlegrowsdata.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattlegrowsdata.FieldEarNumber)
	}
	if m.measuredAt != nil {
		fields = append(fields, cattlegrowsdata.FieldMeasuredAt)
	}
	if m.measuredBy != nil {
		fields = append(fields, cattlegrowsdata.FieldMeasuredBy)
	}
	if m.weight != nil {
		fields = append(fields, cattlegrowsdata.FieldWeight)
	}
	if m.bust != nil {
		fields = append(fields, cattlegrowsdata.FieldBust)
	}
	if m.height != nil {
		fields = append(fields, cattlegrowsdata.FieldHeight)
	}
	if m.score != nil {
		fields = append(fields, cattlegrowsdata.FieldScore)
	}
	if m.remarks != nil {
		fields = append(fields, cattlegrowsdata.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlegrowsdata.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlegrowsdata.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlegrowsdata.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGrowsDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsdata.FieldCattleId:
		return m.CattleId()
	case cattlegrowsdata.FieldTenantId:
		return m.TenantId()
	case cattlegrowsdata.FieldTenantName:
		return m.TenantName()
	case cattlegrowsdata.FieldFarmId:
		return m.FarmId()
	case cattlegrowsdata.FieldFarmName:
		return m.FarmName()
	case cattlegrowsdata.FieldShedId:
		return m.ShedId()
	case cattlegrowsdata.FieldShedName:
		return m.ShedName()
	case cattlegrowsdata.FieldName:
		return m.Name()
	case cattlegrowsdata.FieldEarNumber:
		return m.EarNumber()
	case cattlegrowsdata.FieldMeasuredAt:
		return m.MeasuredAt()
	case cattlegrowsdata.FieldMeasuredBy:
		return m.MeasuredBy()
	case cattlegrowsdata.FieldWeight:
		return m.Weight()
	case cattlegrowsdata.FieldBust:
		return m.Bust()
	case cattlegrowsdata.FieldHeight:
		return m.Height()
	case cattlegrowsdata.FieldScore:
		return m.Score()
	case cattlegrowsdata.FieldRemarks:
		return m.Remarks()
	case cattlegrowsdata.FieldCreatedAt:
		return m.CreatedAt()
	case cattlegrowsdata.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlegrowsdata.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGrowsDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegrowsdata.FieldCattleId:
		return m.OldCattleId(ctx)
	case cattlegrowsdata.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlegrowsdata.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlegrowsdata.FieldFarmId:
		return m.OldFarmId(ctx)
	case cattlegrowsdata.FieldFarmName:
		return m.OldFarmName(ctx)
	case cattlegrowsdata.FieldShedId:
		return m.OldShedId(ctx)
	case cattlegrowsdata.FieldShedName:
		return m.OldShedName(ctx)
	case cattlegrowsdata.FieldName:
		return m.OldName(ctx)
	case cattlegrowsdata.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlegrowsdata.FieldMeasuredAt:
		return m.OldMeasuredAt(ctx)
	case cattlegrowsdata.FieldMeasuredBy:
		return m.OldMeasuredBy(ctx)
	case cattlegrowsdata.FieldWeight:
		return m.OldWeight(ctx)
	case cattlegrowsdata.FieldBust:
		return m.OldBust(ctx)
	case cattlegrowsdata.FieldHeight:
		return m.OldHeight(ctx)
	case cattlegrowsdata.FieldScore:
		return m.OldScore(ctx)
	case cattlegrowsdata.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlegrowsdata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlegrowsdata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlegrowsdata.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGrowsData field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsdata.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case cattlegrowsdata.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlegrowsdata.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlegrowsdata.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case cattlegrowsdata.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case cattlegrowsdata.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case cattlegrowsdata.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattlegrowsdata.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlegrowsdata.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlegrowsdata.FieldMeasuredAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasuredAt(v)
		return nil
	case cattlegrowsdata.FieldMeasuredBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasuredBy(v)
		return nil
	case cattlegrowsdata.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case cattlegrowsdata.FieldBust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBust(v)
		return nil
	case cattlegrowsdata.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case cattlegrowsdata.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case cattlegrowsdata.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlegrowsdata.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlegrowsdata.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlegrowsdata.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGrowsDataMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, cattlegrowsdata.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattlegrowsdata.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, cattlegrowsdata.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, cattlegrowsdata.FieldShedId)
	}
	if m.addmeasuredAt != nil {
		fields = append(fields, cattlegrowsdata.FieldMeasuredAt)
	}
	if m.addweight != nil {
		fields = append(fields, cattlegrowsdata.FieldWeight)
	}
	if m.addbust != nil {
		fields = append(fields, cattlegrowsdata.FieldBust)
	}
	if m.addheight != nil {
		fields = append(fields, cattlegrowsdata.FieldHeight)
	}
	if m.addscore != nil {
		fields = append(fields, cattlegrowsdata.FieldScore)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlegrowsdata.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlegrowsdata.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlegrowsdata.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGrowsDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsdata.FieldCattleId:
		return m.AddedCattleId()
	case cattlegrowsdata.FieldTenantId:
		return m.AddedTenantId()
	case cattlegrowsdata.FieldFarmId:
		return m.AddedFarmId()
	case cattlegrowsdata.FieldShedId:
		return m.AddedShedId()
	case cattlegrowsdata.FieldMeasuredAt:
		return m.AddedMeasuredAt()
	case cattlegrowsdata.FieldWeight:
		return m.AddedWeight()
	case cattlegrowsdata.FieldBust:
		return m.AddedBust()
	case cattlegrowsdata.FieldHeight:
		return m.AddedHeight()
	case cattlegrowsdata.FieldScore:
		return m.AddedScore()
	case cattlegrowsdata.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlegrowsdata.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlegrowsdata.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsdata.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case cattlegrowsdata.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlegrowsdata.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case cattlegrowsdata.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case cattlegrowsdata.FieldMeasuredAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMeasuredAt(v)
		return nil
	case cattlegrowsdata.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case cattlegrowsdata.FieldBust:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBust(v)
		return nil
	case cattlegrowsdata.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case cattlegrowsdata.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	case cattlegrowsdata.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlegrowsdata.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlegrowsdata.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGrowsDataMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattlegrowsdata.FieldName) {
		fields = append(fields, cattlegrowsdata.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGrowsDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGrowsDataMutation) ClearField(name string) error {
	switch name {
	case cattlegrowsdata.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGrowsDataMutation) ResetField(name string) error {
	switch name {
	case cattlegrowsdata.FieldCattleId:
		m.ResetCattleId()
		return nil
	case cattlegrowsdata.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlegrowsdata.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlegrowsdata.FieldFarmId:
		m.ResetFarmId()
		return nil
	case cattlegrowsdata.FieldFarmName:
		m.ResetFarmName()
		return nil
	case cattlegrowsdata.FieldShedId:
		m.ResetShedId()
		return nil
	case cattlegrowsdata.FieldShedName:
		m.ResetShedName()
		return nil
	case cattlegrowsdata.FieldName:
		m.ResetName()
		return nil
	case cattlegrowsdata.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlegrowsdata.FieldMeasuredAt:
		m.ResetMeasuredAt()
		return nil
	case cattlegrowsdata.FieldMeasuredBy:
		m.ResetMeasuredBy()
		return nil
	case cattlegrowsdata.FieldWeight:
		m.ResetWeight()
		return nil
	case cattlegrowsdata.FieldBust:
		m.ResetBust()
		return nil
	case cattlegrowsdata.FieldHeight:
		m.ResetHeight()
		return nil
	case cattlegrowsdata.FieldScore:
		m.ResetScore()
		return nil
	case cattlegrowsdata.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlegrowsdata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlegrowsdata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlegrowsdata.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGrowsDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGrowsDataMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGrowsDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGrowsDataMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGrowsDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGrowsDataMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGrowsDataMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsData unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGrowsDataMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsData edge %s", name)
}

// CattleGrowsRateMutation represents an operation that mutate the CattleGrowsRates
// nodes in the graph.
type CattleGrowsRateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	earNumber     *string
	shedName      *string
	ratedAt       *int64
	addratedAt    *int64
	ratedBy       *string
	rate          *int
	addrate       *int
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleGrowsRate, error)
}

var _ ent.Mutation = (*CattleGrowsRateMutation)(nil)

// cattlegrowsrateOption allows to manage the mutation configuration using functional options.
type cattlegrowsrateOption func(*CattleGrowsRateMutation)

// newCattleGrowsRateMutation creates new mutation for $n.Name.
func newCattleGrowsRateMutation(c config, op Op, opts ...cattlegrowsrateOption) *CattleGrowsRateMutation {
	m := &CattleGrowsRateMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleGrowsRate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleGrowsRateID sets the id field of the mutation.
func withCattleGrowsRateID(id int64) cattlegrowsrateOption {
	return func(m *CattleGrowsRateMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleGrowsRate
		)
		m.oldValue = func(ctx context.Context) (*CattleGrowsRate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleGrowsRate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleGrowsRate sets the old CattleGrowsRate of the mutation.
func withCattleGrowsRate(node *CattleGrowsRate) cattlegrowsrateOption {
	return func(m *CattleGrowsRateMutation) {
		m.oldValue = func(context.Context) (*CattleGrowsRate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleGrowsRateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleGrowsRateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleGrowsRateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleGrowsRateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleGrowsRateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *CattleGrowsRateMutation) ClearName() {
	m.name = nil
	m.clearedFields[cattlegrowsrate.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *CattleGrowsRateMutation) NameCleared() bool {
	_, ok := m.clearedFields[cattlegrowsrate.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *CattleGrowsRateMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, cattlegrowsrate.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *CattleGrowsRateMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleGrowsRateMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleGrowsRateMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetShedName sets the shedName field.
func (m *CattleGrowsRateMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleGrowsRateMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleGrowsRateMutation) ResetShedName() {
	m.shedName = nil
}

// SetRatedAt sets the ratedAt field.
func (m *CattleGrowsRateMutation) SetRatedAt(i int64) {
	m.ratedAt = &i
	m.addratedAt = nil
}

// RatedAt returns the ratedAt value in the mutation.
func (m *CattleGrowsRateMutation) RatedAt() (r int64, exists bool) {
	v := m.ratedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldRatedAt returns the old ratedAt value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatedAt: %w", err)
	}
	return oldValue.RatedAt, nil
}

// AddRatedAt adds i to ratedAt.
func (m *CattleGrowsRateMutation) AddRatedAt(i int64) {
	if m.addratedAt != nil {
		*m.addratedAt += i
	} else {
		m.addratedAt = &i
	}
}

// AddedRatedAt returns the value that was added to the ratedAt field in this mutation.
func (m *CattleGrowsRateMutation) AddedRatedAt() (r int64, exists bool) {
	v := m.addratedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatedAt reset all changes of the "ratedAt" field.
func (m *CattleGrowsRateMutation) ResetRatedAt() {
	m.ratedAt = nil
	m.addratedAt = nil
}

// SetRatedBy sets the ratedBy field.
func (m *CattleGrowsRateMutation) SetRatedBy(s string) {
	m.ratedBy = &s
}

// RatedBy returns the ratedBy value in the mutation.
func (m *CattleGrowsRateMutation) RatedBy() (r string, exists bool) {
	v := m.ratedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldRatedBy returns the old ratedBy value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRatedBy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatedBy: %w", err)
	}
	return oldValue.RatedBy, nil
}

// ResetRatedBy reset all changes of the "ratedBy" field.
func (m *CattleGrowsRateMutation) ResetRatedBy() {
	m.ratedBy = nil
}

// SetRate sets the rate field.
func (m *CattleGrowsRateMutation) SetRate(i int) {
	m.rate = &i
	m.addrate = nil
}

// Rate returns the rate value in the mutation.
func (m *CattleGrowsRateMutation) Rate() (r int, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old rate value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds i to rate.
func (m *CattleGrowsRateMutation) AddRate(i int) {
	if m.addrate != nil {
		*m.addrate += i
	} else {
		m.addrate = &i
	}
}

// AddedRate returns the value that was added to the rate field in this mutation.
func (m *CattleGrowsRateMutation) AddedRate() (r int, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate reset all changes of the "rate" field.
func (m *CattleGrowsRateMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleGrowsRateMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleGrowsRateMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleGrowsRateMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleGrowsRateMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleGrowsRateMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleGrowsRateMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleGrowsRateMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleGrowsRateMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleGrowsRateMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleGrowsRateMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleGrowsRateMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleGrowsRateMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleGrowsRateMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleGrowsRateMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleGrowsRateMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleGrowsRateMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleGrowsRateMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleGrowsRateMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleGrowsRateMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleGrowsRateMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleGrowsRateMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleGrowsRateMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleGrowsRateMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleGrowsRate.
// If the CattleGrowsRate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleGrowsRateMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleGrowsRateMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleGrowsRateMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleGrowsRateMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleGrowsRateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleGrowsRate).
func (m *CattleGrowsRateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleGrowsRateMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.name != nil {
		fields = append(fields, cattlegrowsrate.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattlegrowsrate.FieldEarNumber)
	}
	if m.shedName != nil {
		fields = append(fields, cattlegrowsrate.FieldShedName)
	}
	if m.ratedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldRatedAt)
	}
	if m.ratedBy != nil {
		fields = append(fields, cattlegrowsrate.FieldRatedBy)
	}
	if m.rate != nil {
		fields = append(fields, cattlegrowsrate.FieldRate)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlegrowsrate.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlegrowsrate.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, cattlegrowsrate.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlegrowsrate.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlegrowsrate.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleGrowsRateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsrate.FieldName:
		return m.Name()
	case cattlegrowsrate.FieldEarNumber:
		return m.EarNumber()
	case cattlegrowsrate.FieldShedName:
		return m.ShedName()
	case cattlegrowsrate.FieldRatedAt:
		return m.RatedAt()
	case cattlegrowsrate.FieldRatedBy:
		return m.RatedBy()
	case cattlegrowsrate.FieldRate:
		return m.Rate()
	case cattlegrowsrate.FieldTenantId:
		return m.TenantId()
	case cattlegrowsrate.FieldTenantName:
		return m.TenantName()
	case cattlegrowsrate.FieldRemarks:
		return m.Remarks()
	case cattlegrowsrate.FieldCreatedAt:
		return m.CreatedAt()
	case cattlegrowsrate.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlegrowsrate.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleGrowsRateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlegrowsrate.FieldName:
		return m.OldName(ctx)
	case cattlegrowsrate.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlegrowsrate.FieldShedName:
		return m.OldShedName(ctx)
	case cattlegrowsrate.FieldRatedAt:
		return m.OldRatedAt(ctx)
	case cattlegrowsrate.FieldRatedBy:
		return m.OldRatedBy(ctx)
	case cattlegrowsrate.FieldRate:
		return m.OldRate(ctx)
	case cattlegrowsrate.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlegrowsrate.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlegrowsrate.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlegrowsrate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlegrowsrate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlegrowsrate.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleGrowsRate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsRateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsrate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlegrowsrate.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlegrowsrate.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattlegrowsrate.FieldRatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatedAt(v)
		return nil
	case cattlegrowsrate.FieldRatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatedBy(v)
		return nil
	case cattlegrowsrate.FieldRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case cattlegrowsrate.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlegrowsrate.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlegrowsrate.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlegrowsrate.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlegrowsrate.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlegrowsrate.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleGrowsRateMutation) AddedFields() []string {
	var fields []string
	if m.addratedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldRatedAt)
	}
	if m.addrate != nil {
		fields = append(fields, cattlegrowsrate.FieldRate)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattlegrowsrate.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlegrowsrate.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlegrowsrate.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleGrowsRateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlegrowsrate.FieldRatedAt:
		return m.AddedRatedAt()
	case cattlegrowsrate.FieldRate:
		return m.AddedRate()
	case cattlegrowsrate.FieldTenantId:
		return m.AddedTenantId()
	case cattlegrowsrate.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlegrowsrate.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlegrowsrate.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleGrowsRateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlegrowsrate.FieldRatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatedAt(v)
		return nil
	case cattlegrowsrate.FieldRate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	case cattlegrowsrate.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlegrowsrate.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlegrowsrate.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlegrowsrate.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleGrowsRateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cattlegrowsrate.FieldName) {
		fields = append(fields, cattlegrowsrate.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleGrowsRateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleGrowsRateMutation) ClearField(name string) error {
	switch name {
	case cattlegrowsrate.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleGrowsRateMutation) ResetField(name string) error {
	switch name {
	case cattlegrowsrate.FieldName:
		m.ResetName()
		return nil
	case cattlegrowsrate.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlegrowsrate.FieldShedName:
		m.ResetShedName()
		return nil
	case cattlegrowsrate.FieldRatedAt:
		m.ResetRatedAt()
		return nil
	case cattlegrowsrate.FieldRatedBy:
		m.ResetRatedBy()
		return nil
	case cattlegrowsrate.FieldRate:
		m.ResetRate()
		return nil
	case cattlegrowsrate.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlegrowsrate.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlegrowsrate.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlegrowsrate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlegrowsrate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlegrowsrate.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleGrowsRate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleGrowsRateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleGrowsRateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleGrowsRateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleGrowsRateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleGrowsRateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleGrowsRateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleGrowsRateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsRate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleGrowsRateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleGrowsRate edge %s", name)
}

// CattleHairColorMutation represents an operation that mutate the CattleHairColors
// nodes in the graph.
type CattleHairColorMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	_order        *int
	add_order     *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleHairColor, error)
}

var _ ent.Mutation = (*CattleHairColorMutation)(nil)

// cattlehaircolorOption allows to manage the mutation configuration using functional options.
type cattlehaircolorOption func(*CattleHairColorMutation)

// newCattleHairColorMutation creates new mutation for $n.Name.
func newCattleHairColorMutation(c config, op Op, opts ...cattlehaircolorOption) *CattleHairColorMutation {
	m := &CattleHairColorMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleHairColor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleHairColorID sets the id field of the mutation.
func withCattleHairColorID(id int64) cattlehaircolorOption {
	return func(m *CattleHairColorMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleHairColor
		)
		m.oldValue = func(ctx context.Context) (*CattleHairColor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleHairColor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleHairColor sets the old CattleHairColor of the mutation.
func withCattleHairColor(node *CattleHairColor) cattlehaircolorOption {
	return func(m *CattleHairColorMutation) {
		m.oldValue = func(context.Context) (*CattleHairColor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleHairColorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleHairColorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleHairColorMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleHairColorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleHairColorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleHairColorMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *CattleHairColorMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *CattleHairColorMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *CattleHairColorMutation) ResetCode() {
	m.code = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleHairColorMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleHairColorMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleHairColorMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleHairColorMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleHairColorMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleHairColorMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleHairColorMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleHairColorMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetOrder sets the order field.
func (m *CattleHairColorMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the order value in the mutation.
func (m *CattleHairColorMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old order value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to order.
func (m *CattleHairColorMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the order field in this mutation.
func (m *CattleHairColorMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder reset all changes of the "order" field.
func (m *CattleHairColorMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRemarks sets the remarks field.
func (m *CattleHairColorMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleHairColorMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleHairColorMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleHairColorMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleHairColorMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleHairColorMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleHairColorMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleHairColorMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleHairColorMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleHairColorMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleHairColorMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleHairColorMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleHairColorMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleHairColorMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleHairColorMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleHairColor.
// If the CattleHairColor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleHairColorMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleHairColorMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleHairColorMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleHairColorMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleHairColorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleHairColor).
func (m *CattleHairColorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleHairColorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, cattlehaircolor.FieldName)
	}
	if m.code != nil {
		fields = append(fields, cattlehaircolor.FieldCode)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlehaircolor.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlehaircolor.FieldTenantName)
	}
	if m._order != nil {
		fields = append(fields, cattlehaircolor.FieldOrder)
	}
	if m.remarks != nil {
		fields = append(fields, cattlehaircolor.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlehaircolor.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlehaircolor.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlehaircolor.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleHairColorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlehaircolor.FieldName:
		return m.Name()
	case cattlehaircolor.FieldCode:
		return m.Code()
	case cattlehaircolor.FieldTenantId:
		return m.TenantId()
	case cattlehaircolor.FieldTenantName:
		return m.TenantName()
	case cattlehaircolor.FieldOrder:
		return m.Order()
	case cattlehaircolor.FieldRemarks:
		return m.Remarks()
	case cattlehaircolor.FieldCreatedAt:
		return m.CreatedAt()
	case cattlehaircolor.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlehaircolor.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleHairColorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlehaircolor.FieldName:
		return m.OldName(ctx)
	case cattlehaircolor.FieldCode:
		return m.OldCode(ctx)
	case cattlehaircolor.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlehaircolor.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlehaircolor.FieldOrder:
		return m.OldOrder(ctx)
	case cattlehaircolor.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlehaircolor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlehaircolor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlehaircolor.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleHairColor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleHairColorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlehaircolor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlehaircolor.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case cattlehaircolor.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlehaircolor.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlehaircolor.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case cattlehaircolor.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlehaircolor.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlehaircolor.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlehaircolor.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleHairColor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleHairColorMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, cattlehaircolor.FieldTenantId)
	}
	if m.add_order != nil {
		fields = append(fields, cattlehaircolor.FieldOrder)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlehaircolor.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlehaircolor.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlehaircolor.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleHairColorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlehaircolor.FieldTenantId:
		return m.AddedTenantId()
	case cattlehaircolor.FieldOrder:
		return m.AddedOrder()
	case cattlehaircolor.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlehaircolor.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlehaircolor.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleHairColorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlehaircolor.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlehaircolor.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case cattlehaircolor.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlehaircolor.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlehaircolor.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleHairColor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleHairColorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleHairColorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleHairColorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleHairColor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleHairColorMutation) ResetField(name string) error {
	switch name {
	case cattlehaircolor.FieldName:
		m.ResetName()
		return nil
	case cattlehaircolor.FieldCode:
		m.ResetCode()
		return nil
	case cattlehaircolor.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlehaircolor.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlehaircolor.FieldOrder:
		m.ResetOrder()
		return nil
	case cattlehaircolor.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlehaircolor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlehaircolor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlehaircolor.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleHairColor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleHairColorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleHairColorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleHairColorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleHairColorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleHairColorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleHairColorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleHairColorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleHairColor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleHairColorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleHairColor edge %s", name)
}

// CattleInMutation represents an operation that mutate the CattleIns
// nodes in the graph.
type CattleInMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	joinType       *int64
	addjoinType    *int64
	date           *int64
	adddate        *int64
	from           *string
	weight         *int64
	addweight      *int64
	cost           *int64
	addcost        *int64
	shippingFee    *int64
	addshippingFee *int64
	shippingCode   *string
	userName       *string
	checkCode      *string
	tenantId       *int64
	addtenantId    *int64
	tenantName     *string
	remarks        *string
	createdAt      *int64
	addcreatedAt   *int64
	updatedAt      *int64
	addupdatedAt   *int64
	deleted        *int
	adddeleted     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CattleIn, error)
}

var _ ent.Mutation = (*CattleInMutation)(nil)

// cattleinOption allows to manage the mutation configuration using functional options.
type cattleinOption func(*CattleInMutation)

// newCattleInMutation creates new mutation for $n.Name.
func newCattleInMutation(c config, op Op, opts ...cattleinOption) *CattleInMutation {
	m := &CattleInMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleIn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleInID sets the id field of the mutation.
func withCattleInID(id int64) cattleinOption {
	return func(m *CattleInMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleIn
		)
		m.oldValue = func(ctx context.Context) (*CattleIn, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleIn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleIn sets the old CattleIn of the mutation.
func withCattleIn(node *CattleIn) cattleinOption {
	return func(m *CattleInMutation) {
		m.oldValue = func(context.Context) (*CattleIn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleInMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleInMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleInMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetJoinType sets the joinType field.
func (m *CattleInMutation) SetJoinType(i int64) {
	m.joinType = &i
	m.addjoinType = nil
}

// JoinType returns the joinType value in the mutation.
func (m *CattleInMutation) JoinType() (r int64, exists bool) {
	v := m.joinType
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinType returns the old joinType value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldJoinType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinType: %w", err)
	}
	return oldValue.JoinType, nil
}

// AddJoinType adds i to joinType.
func (m *CattleInMutation) AddJoinType(i int64) {
	if m.addjoinType != nil {
		*m.addjoinType += i
	} else {
		m.addjoinType = &i
	}
}

// AddedJoinType returns the value that was added to the joinType field in this mutation.
func (m *CattleInMutation) AddedJoinType() (r int64, exists bool) {
	v := m.addjoinType
	if v == nil {
		return
	}
	return *v, true
}

// ResetJoinType reset all changes of the "joinType" field.
func (m *CattleInMutation) ResetJoinType() {
	m.joinType = nil
	m.addjoinType = nil
}

// SetDate sets the date field.
func (m *CattleInMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *CattleInMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *CattleInMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *CattleInMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *CattleInMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetFrom sets the from field.
func (m *CattleInMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the from value in the mutation.
func (m *CattleInMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old from value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFrom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom reset all changes of the "from" field.
func (m *CattleInMutation) ResetFrom() {
	m.from = nil
}

// SetWeight sets the weight field.
func (m *CattleInMutation) SetWeight(i int64) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *CattleInMutation) Weight() (r int64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldWeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *CattleInMutation) AddWeight(i int64) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *CattleInMutation) AddedWeight() (r int64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *CattleInMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetCost sets the cost field.
func (m *CattleInMutation) SetCost(i int64) {
	m.cost = &i
	m.addcost = nil
}

// Cost returns the cost value in the mutation.
func (m *CattleInMutation) Cost() (r int64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old cost value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCost is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds i to cost.
func (m *CattleInMutation) AddCost(i int64) {
	if m.addcost != nil {
		*m.addcost += i
	} else {
		m.addcost = &i
	}
}

// AddedCost returns the value that was added to the cost field in this mutation.
func (m *CattleInMutation) AddedCost() (r int64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost reset all changes of the "cost" field.
func (m *CattleInMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetShippingFee sets the shippingFee field.
func (m *CattleInMutation) SetShippingFee(i int64) {
	m.shippingFee = &i
	m.addshippingFee = nil
}

// ShippingFee returns the shippingFee value in the mutation.
func (m *CattleInMutation) ShippingFee() (r int64, exists bool) {
	v := m.shippingFee
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingFee returns the old shippingFee value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldShippingFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingFee is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingFee: %w", err)
	}
	return oldValue.ShippingFee, nil
}

// AddShippingFee adds i to shippingFee.
func (m *CattleInMutation) AddShippingFee(i int64) {
	if m.addshippingFee != nil {
		*m.addshippingFee += i
	} else {
		m.addshippingFee = &i
	}
}

// AddedShippingFee returns the value that was added to the shippingFee field in this mutation.
func (m *CattleInMutation) AddedShippingFee() (r int64, exists bool) {
	v := m.addshippingFee
	if v == nil {
		return
	}
	return *v, true
}

// ResetShippingFee reset all changes of the "shippingFee" field.
func (m *CattleInMutation) ResetShippingFee() {
	m.shippingFee = nil
	m.addshippingFee = nil
}

// SetShippingCode sets the shippingCode field.
func (m *CattleInMutation) SetShippingCode(s string) {
	m.shippingCode = &s
}

// ShippingCode returns the shippingCode value in the mutation.
func (m *CattleInMutation) ShippingCode() (r string, exists bool) {
	v := m.shippingCode
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCode returns the old shippingCode value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldShippingCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCode: %w", err)
	}
	return oldValue.ShippingCode, nil
}

// ResetShippingCode reset all changes of the "shippingCode" field.
func (m *CattleInMutation) ResetShippingCode() {
	m.shippingCode = nil
}

// SetUserName sets the userName field.
func (m *CattleInMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CattleInMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CattleInMutation) ResetUserName() {
	m.userName = nil
}

// SetCheckCode sets the checkCode field.
func (m *CattleInMutation) SetCheckCode(s string) {
	m.checkCode = &s
}

// CheckCode returns the checkCode value in the mutation.
func (m *CattleInMutation) CheckCode() (r string, exists bool) {
	v := m.checkCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckCode returns the old checkCode value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldCheckCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckCode: %w", err)
	}
	return oldValue.CheckCode, nil
}

// ResetCheckCode reset all changes of the "checkCode" field.
func (m *CattleInMutation) ResetCheckCode() {
	m.checkCode = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleInMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleInMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleInMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleInMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleInMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleInMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleInMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleInMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleInMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleInMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleInMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleInMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleInMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleInMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleInMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleInMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleInMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleInMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleInMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleInMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleInMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleInMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleInMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleIn.
// If the CattleIn object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleInMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleInMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleInMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleInMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleInMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleIn).
func (m *CattleInMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleInMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.joinType != nil {
		fields = append(fields, cattlein.FieldJoinType)
	}
	if m.date != nil {
		fields = append(fields, cattlein.FieldDate)
	}
	if m.from != nil {
		fields = append(fields, cattlein.FieldFrom)
	}
	if m.weight != nil {
		fields = append(fields, cattlein.FieldWeight)
	}
	if m.cost != nil {
		fields = append(fields, cattlein.FieldCost)
	}
	if m.shippingFee != nil {
		fields = append(fields, cattlein.FieldShippingFee)
	}
	if m.shippingCode != nil {
		fields = append(fields, cattlein.FieldShippingCode)
	}
	if m.userName != nil {
		fields = append(fields, cattlein.FieldUserName)
	}
	if m.checkCode != nil {
		fields = append(fields, cattlein.FieldCheckCode)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlein.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlein.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, cattlein.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlein.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlein.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlein.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleInMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlein.FieldJoinType:
		return m.JoinType()
	case cattlein.FieldDate:
		return m.Date()
	case cattlein.FieldFrom:
		return m.From()
	case cattlein.FieldWeight:
		return m.Weight()
	case cattlein.FieldCost:
		return m.Cost()
	case cattlein.FieldShippingFee:
		return m.ShippingFee()
	case cattlein.FieldShippingCode:
		return m.ShippingCode()
	case cattlein.FieldUserName:
		return m.UserName()
	case cattlein.FieldCheckCode:
		return m.CheckCode()
	case cattlein.FieldTenantId:
		return m.TenantId()
	case cattlein.FieldTenantName:
		return m.TenantName()
	case cattlein.FieldRemarks:
		return m.Remarks()
	case cattlein.FieldCreatedAt:
		return m.CreatedAt()
	case cattlein.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlein.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleInMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlein.FieldJoinType:
		return m.OldJoinType(ctx)
	case cattlein.FieldDate:
		return m.OldDate(ctx)
	case cattlein.FieldFrom:
		return m.OldFrom(ctx)
	case cattlein.FieldWeight:
		return m.OldWeight(ctx)
	case cattlein.FieldCost:
		return m.OldCost(ctx)
	case cattlein.FieldShippingFee:
		return m.OldShippingFee(ctx)
	case cattlein.FieldShippingCode:
		return m.OldShippingCode(ctx)
	case cattlein.FieldUserName:
		return m.OldUserName(ctx)
	case cattlein.FieldCheckCode:
		return m.OldCheckCode(ctx)
	case cattlein.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlein.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlein.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlein.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlein.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlein.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleIn field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleInMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlein.FieldJoinType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinType(v)
		return nil
	case cattlein.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case cattlein.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case cattlein.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case cattlein.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case cattlein.FieldShippingFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingFee(v)
		return nil
	case cattlein.FieldShippingCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCode(v)
		return nil
	case cattlein.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case cattlein.FieldCheckCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckCode(v)
		return nil
	case cattlein.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlein.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlein.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlein.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlein.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlein.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleIn field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleInMutation) AddedFields() []string {
	var fields []string
	if m.addjoinType != nil {
		fields = append(fields, cattlein.FieldJoinType)
	}
	if m.adddate != nil {
		fields = append(fields, cattlein.FieldDate)
	}
	if m.addweight != nil {
		fields = append(fields, cattlein.FieldWeight)
	}
	if m.addcost != nil {
		fields = append(fields, cattlein.FieldCost)
	}
	if m.addshippingFee != nil {
		fields = append(fields, cattlein.FieldShippingFee)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattlein.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlein.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlein.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlein.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleInMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlein.FieldJoinType:
		return m.AddedJoinType()
	case cattlein.FieldDate:
		return m.AddedDate()
	case cattlein.FieldWeight:
		return m.AddedWeight()
	case cattlein.FieldCost:
		return m.AddedCost()
	case cattlein.FieldShippingFee:
		return m.AddedShippingFee()
	case cattlein.FieldTenantId:
		return m.AddedTenantId()
	case cattlein.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlein.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlein.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleInMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlein.FieldJoinType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinType(v)
		return nil
	case cattlein.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case cattlein.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case cattlein.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case cattlein.FieldShippingFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingFee(v)
		return nil
	case cattlein.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlein.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlein.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlein.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleIn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleInMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleInMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleInMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleIn nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleInMutation) ResetField(name string) error {
	switch name {
	case cattlein.FieldJoinType:
		m.ResetJoinType()
		return nil
	case cattlein.FieldDate:
		m.ResetDate()
		return nil
	case cattlein.FieldFrom:
		m.ResetFrom()
		return nil
	case cattlein.FieldWeight:
		m.ResetWeight()
		return nil
	case cattlein.FieldCost:
		m.ResetCost()
		return nil
	case cattlein.FieldShippingFee:
		m.ResetShippingFee()
		return nil
	case cattlein.FieldShippingCode:
		m.ResetShippingCode()
		return nil
	case cattlein.FieldUserName:
		m.ResetUserName()
		return nil
	case cattlein.FieldCheckCode:
		m.ResetCheckCode()
		return nil
	case cattlein.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlein.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlein.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlein.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlein.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlein.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleIn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleInMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleInMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleInMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleInMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleInMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleInMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleInMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleIn unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleInMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleIn edge %s", name)
}

// CattleJoinedTypeMutation represents an operation that mutate the CattleJoinedTypes
// nodes in the graph.
type CattleJoinedTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleJoinedType, error)
}

var _ ent.Mutation = (*CattleJoinedTypeMutation)(nil)

// cattlejoinedtypeOption allows to manage the mutation configuration using functional options.
type cattlejoinedtypeOption func(*CattleJoinedTypeMutation)

// newCattleJoinedTypeMutation creates new mutation for $n.Name.
func newCattleJoinedTypeMutation(c config, op Op, opts ...cattlejoinedtypeOption) *CattleJoinedTypeMutation {
	m := &CattleJoinedTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleJoinedType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleJoinedTypeID sets the id field of the mutation.
func withCattleJoinedTypeID(id int64) cattlejoinedtypeOption {
	return func(m *CattleJoinedTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleJoinedType
		)
		m.oldValue = func(ctx context.Context) (*CattleJoinedType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleJoinedType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleJoinedType sets the old CattleJoinedType of the mutation.
func withCattleJoinedType(node *CattleJoinedType) cattlejoinedtypeOption {
	return func(m *CattleJoinedTypeMutation) {
		m.oldValue = func(context.Context) (*CattleJoinedType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleJoinedTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleJoinedTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleJoinedTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleJoinedTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleJoinedTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleJoinedType.
// If the CattleJoinedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleJoinedTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleJoinedTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleJoinedTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleJoinedType).
func (m *CattleJoinedTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleJoinedTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattlejoinedtype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleJoinedTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlejoinedtype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleJoinedTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlejoinedtype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleJoinedType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleJoinedTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlejoinedtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleJoinedType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleJoinedTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleJoinedTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleJoinedTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleJoinedType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleJoinedTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleJoinedTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleJoinedTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleJoinedType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleJoinedTypeMutation) ResetField(name string) error {
	switch name {
	case cattlejoinedtype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleJoinedType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleJoinedTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleJoinedTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleJoinedTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleJoinedTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleJoinedTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleJoinedTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleJoinedTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleJoinedType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleJoinedTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleJoinedType edge %s", name)
}

// CattleMoveMutation represents an operation that mutate the CattleMoves
// nodes in the graph.
type CattleMoveMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	cattleId      *int64
	addcattleId   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	shedId        *int64
	addshedId     *int64
	shedName      *string
	earNumber     *string
	date          *int64
	adddate       *int64
	fromShedId    *int64
	addfromShedId *int64
	fromShed      *string
	toShedId      *int64
	addtoShedId   *int64
	toShed        *string
	userName      *string
	reasonId      *int64
	addreasonId   *int64
	reasonName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleMove, error)
}

var _ ent.Mutation = (*CattleMoveMutation)(nil)

// cattlemoveOption allows to manage the mutation configuration using functional options.
type cattlemoveOption func(*CattleMoveMutation)

// newCattleMoveMutation creates new mutation for $n.Name.
func newCattleMoveMutation(c config, op Op, opts ...cattlemoveOption) *CattleMoveMutation {
	m := &CattleMoveMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleMove,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleMoveID sets the id field of the mutation.
func withCattleMoveID(id int64) cattlemoveOption {
	return func(m *CattleMoveMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleMove
		)
		m.oldValue = func(ctx context.Context) (*CattleMove, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleMove.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleMove sets the old CattleMove of the mutation.
func withCattleMove(node *CattleMove) cattlemoveOption {
	return func(m *CattleMoveMutation) {
		m.oldValue = func(context.Context) (*CattleMove, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleMoveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleMoveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleMoveMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *CattleMoveMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *CattleMoveMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *CattleMoveMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *CattleMoveMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *CattleMoveMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleMoveMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleMoveMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleMoveMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleMoveMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleMoveMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleMoveMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleMoveMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleMoveMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *CattleMoveMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *CattleMoveMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *CattleMoveMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *CattleMoveMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *CattleMoveMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *CattleMoveMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *CattleMoveMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *CattleMoveMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *CattleMoveMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *CattleMoveMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *CattleMoveMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *CattleMoveMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *CattleMoveMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *CattleMoveMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *CattleMoveMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *CattleMoveMutation) ResetShedName() {
	m.shedName = nil
}

// SetEarNumber sets the earNumber field.
func (m *CattleMoveMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *CattleMoveMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *CattleMoveMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetDate sets the date field.
func (m *CattleMoveMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *CattleMoveMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *CattleMoveMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *CattleMoveMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *CattleMoveMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetFromShedId sets the fromShedId field.
func (m *CattleMoveMutation) SetFromShedId(i int64) {
	m.fromShedId = &i
	m.addfromShedId = nil
}

// FromShedId returns the fromShedId value in the mutation.
func (m *CattleMoveMutation) FromShedId() (r int64, exists bool) {
	v := m.fromShedId
	if v == nil {
		return
	}
	return *v, true
}

// OldFromShedId returns the old fromShedId value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldFromShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromShedId: %w", err)
	}
	return oldValue.FromShedId, nil
}

// AddFromShedId adds i to fromShedId.
func (m *CattleMoveMutation) AddFromShedId(i int64) {
	if m.addfromShedId != nil {
		*m.addfromShedId += i
	} else {
		m.addfromShedId = &i
	}
}

// AddedFromShedId returns the value that was added to the fromShedId field in this mutation.
func (m *CattleMoveMutation) AddedFromShedId() (r int64, exists bool) {
	v := m.addfromShedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFromShedId reset all changes of the "fromShedId" field.
func (m *CattleMoveMutation) ResetFromShedId() {
	m.fromShedId = nil
	m.addfromShedId = nil
}

// SetFromShed sets the fromShed field.
func (m *CattleMoveMutation) SetFromShed(s string) {
	m.fromShed = &s
}

// FromShed returns the fromShed value in the mutation.
func (m *CattleMoveMutation) FromShed() (r string, exists bool) {
	v := m.fromShed
	if v == nil {
		return
	}
	return *v, true
}

// OldFromShed returns the old fromShed value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldFromShed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromShed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromShed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromShed: %w", err)
	}
	return oldValue.FromShed, nil
}

// ResetFromShed reset all changes of the "fromShed" field.
func (m *CattleMoveMutation) ResetFromShed() {
	m.fromShed = nil
}

// SetToShedId sets the toShedId field.
func (m *CattleMoveMutation) SetToShedId(i int64) {
	m.toShedId = &i
	m.addtoShedId = nil
}

// ToShedId returns the toShedId value in the mutation.
func (m *CattleMoveMutation) ToShedId() (r int64, exists bool) {
	v := m.toShedId
	if v == nil {
		return
	}
	return *v, true
}

// OldToShedId returns the old toShedId value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldToShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToShedId: %w", err)
	}
	return oldValue.ToShedId, nil
}

// AddToShedId adds i to toShedId.
func (m *CattleMoveMutation) AddToShedId(i int64) {
	if m.addtoShedId != nil {
		*m.addtoShedId += i
	} else {
		m.addtoShedId = &i
	}
}

// AddedToShedId returns the value that was added to the toShedId field in this mutation.
func (m *CattleMoveMutation) AddedToShedId() (r int64, exists bool) {
	v := m.addtoShedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetToShedId reset all changes of the "toShedId" field.
func (m *CattleMoveMutation) ResetToShedId() {
	m.toShedId = nil
	m.addtoShedId = nil
}

// SetToShed sets the toShed field.
func (m *CattleMoveMutation) SetToShed(s string) {
	m.toShed = &s
}

// ToShed returns the toShed value in the mutation.
func (m *CattleMoveMutation) ToShed() (r string, exists bool) {
	v := m.toShed
	if v == nil {
		return
	}
	return *v, true
}

// OldToShed returns the old toShed value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldToShed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToShed is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToShed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToShed: %w", err)
	}
	return oldValue.ToShed, nil
}

// ResetToShed reset all changes of the "toShed" field.
func (m *CattleMoveMutation) ResetToShed() {
	m.toShed = nil
}

// SetUserName sets the userName field.
func (m *CattleMoveMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CattleMoveMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CattleMoveMutation) ResetUserName() {
	m.userName = nil
}

// SetReasonId sets the reasonId field.
func (m *CattleMoveMutation) SetReasonId(i int64) {
	m.reasonId = &i
	m.addreasonId = nil
}

// ReasonId returns the reasonId value in the mutation.
func (m *CattleMoveMutation) ReasonId() (r int64, exists bool) {
	v := m.reasonId
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonId returns the old reasonId value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldReasonId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReasonId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReasonId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonId: %w", err)
	}
	return oldValue.ReasonId, nil
}

// AddReasonId adds i to reasonId.
func (m *CattleMoveMutation) AddReasonId(i int64) {
	if m.addreasonId != nil {
		*m.addreasonId += i
	} else {
		m.addreasonId = &i
	}
}

// AddedReasonId returns the value that was added to the reasonId field in this mutation.
func (m *CattleMoveMutation) AddedReasonId() (r int64, exists bool) {
	v := m.addreasonId
	if v == nil {
		return
	}
	return *v, true
}

// ResetReasonId reset all changes of the "reasonId" field.
func (m *CattleMoveMutation) ResetReasonId() {
	m.reasonId = nil
	m.addreasonId = nil
}

// SetReasonName sets the reasonName field.
func (m *CattleMoveMutation) SetReasonName(s string) {
	m.reasonName = &s
}

// ReasonName returns the reasonName value in the mutation.
func (m *CattleMoveMutation) ReasonName() (r string, exists bool) {
	v := m.reasonName
	if v == nil {
		return
	}
	return *v, true
}

// OldReasonName returns the old reasonName value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldReasonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReasonName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReasonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReasonName: %w", err)
	}
	return oldValue.ReasonName, nil
}

// ResetReasonName reset all changes of the "reasonName" field.
func (m *CattleMoveMutation) ResetReasonName() {
	m.reasonName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleMoveMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleMoveMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleMoveMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleMoveMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleMoveMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleMoveMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleMoveMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleMoveMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleMoveMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleMoveMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleMoveMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleMoveMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleMoveMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleMoveMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleMoveMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleMove.
// If the CattleMove object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleMoveMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleMoveMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleMoveMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleMoveMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleMove).
func (m *CattleMoveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleMoveMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.cattleId != nil {
		fields = append(fields, cattlemove.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlemove.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlemove.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, cattlemove.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, cattlemove.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, cattlemove.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, cattlemove.FieldShedName)
	}
	if m.earNumber != nil {
		fields = append(fields, cattlemove.FieldEarNumber)
	}
	if m.date != nil {
		fields = append(fields, cattlemove.FieldDate)
	}
	if m.fromShedId != nil {
		fields = append(fields, cattlemove.FieldFromShedId)
	}
	if m.fromShed != nil {
		fields = append(fields, cattlemove.FieldFromShed)
	}
	if m.toShedId != nil {
		fields = append(fields, cattlemove.FieldToShedId)
	}
	if m.toShed != nil {
		fields = append(fields, cattlemove.FieldToShed)
	}
	if m.userName != nil {
		fields = append(fields, cattlemove.FieldUserName)
	}
	if m.reasonId != nil {
		fields = append(fields, cattlemove.FieldReasonId)
	}
	if m.reasonName != nil {
		fields = append(fields, cattlemove.FieldReasonName)
	}
	if m.remarks != nil {
		fields = append(fields, cattlemove.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlemove.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlemove.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlemove.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleMoveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlemove.FieldCattleId:
		return m.CattleId()
	case cattlemove.FieldTenantId:
		return m.TenantId()
	case cattlemove.FieldTenantName:
		return m.TenantName()
	case cattlemove.FieldFarmId:
		return m.FarmId()
	case cattlemove.FieldFarmName:
		return m.FarmName()
	case cattlemove.FieldShedId:
		return m.ShedId()
	case cattlemove.FieldShedName:
		return m.ShedName()
	case cattlemove.FieldEarNumber:
		return m.EarNumber()
	case cattlemove.FieldDate:
		return m.Date()
	case cattlemove.FieldFromShedId:
		return m.FromShedId()
	case cattlemove.FieldFromShed:
		return m.FromShed()
	case cattlemove.FieldToShedId:
		return m.ToShedId()
	case cattlemove.FieldToShed:
		return m.ToShed()
	case cattlemove.FieldUserName:
		return m.UserName()
	case cattlemove.FieldReasonId:
		return m.ReasonId()
	case cattlemove.FieldReasonName:
		return m.ReasonName()
	case cattlemove.FieldRemarks:
		return m.Remarks()
	case cattlemove.FieldCreatedAt:
		return m.CreatedAt()
	case cattlemove.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlemove.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleMoveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlemove.FieldCattleId:
		return m.OldCattleId(ctx)
	case cattlemove.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlemove.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlemove.FieldFarmId:
		return m.OldFarmId(ctx)
	case cattlemove.FieldFarmName:
		return m.OldFarmName(ctx)
	case cattlemove.FieldShedId:
		return m.OldShedId(ctx)
	case cattlemove.FieldShedName:
		return m.OldShedName(ctx)
	case cattlemove.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case cattlemove.FieldDate:
		return m.OldDate(ctx)
	case cattlemove.FieldFromShedId:
		return m.OldFromShedId(ctx)
	case cattlemove.FieldFromShed:
		return m.OldFromShed(ctx)
	case cattlemove.FieldToShedId:
		return m.OldToShedId(ctx)
	case cattlemove.FieldToShed:
		return m.OldToShed(ctx)
	case cattlemove.FieldUserName:
		return m.OldUserName(ctx)
	case cattlemove.FieldReasonId:
		return m.OldReasonId(ctx)
	case cattlemove.FieldReasonName:
		return m.OldReasonName(ctx)
	case cattlemove.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlemove.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlemove.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlemove.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleMove field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMoveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlemove.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case cattlemove.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlemove.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlemove.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case cattlemove.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case cattlemove.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case cattlemove.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case cattlemove.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case cattlemove.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case cattlemove.FieldFromShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromShedId(v)
		return nil
	case cattlemove.FieldFromShed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromShed(v)
		return nil
	case cattlemove.FieldToShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToShedId(v)
		return nil
	case cattlemove.FieldToShed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToShed(v)
		return nil
	case cattlemove.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case cattlemove.FieldReasonId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonId(v)
		return nil
	case cattlemove.FieldReasonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReasonName(v)
		return nil
	case cattlemove.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlemove.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlemove.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlemove.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleMove field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleMoveMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, cattlemove.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattlemove.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, cattlemove.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, cattlemove.FieldShedId)
	}
	if m.adddate != nil {
		fields = append(fields, cattlemove.FieldDate)
	}
	if m.addfromShedId != nil {
		fields = append(fields, cattlemove.FieldFromShedId)
	}
	if m.addtoShedId != nil {
		fields = append(fields, cattlemove.FieldToShedId)
	}
	if m.addreasonId != nil {
		fields = append(fields, cattlemove.FieldReasonId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlemove.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlemove.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlemove.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleMoveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlemove.FieldCattleId:
		return m.AddedCattleId()
	case cattlemove.FieldTenantId:
		return m.AddedTenantId()
	case cattlemove.FieldFarmId:
		return m.AddedFarmId()
	case cattlemove.FieldShedId:
		return m.AddedShedId()
	case cattlemove.FieldDate:
		return m.AddedDate()
	case cattlemove.FieldFromShedId:
		return m.AddedFromShedId()
	case cattlemove.FieldToShedId:
		return m.AddedToShedId()
	case cattlemove.FieldReasonId:
		return m.AddedReasonId()
	case cattlemove.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlemove.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlemove.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMoveMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlemove.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case cattlemove.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlemove.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case cattlemove.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case cattlemove.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case cattlemove.FieldFromShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFromShedId(v)
		return nil
	case cattlemove.FieldToShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToShedId(v)
		return nil
	case cattlemove.FieldReasonId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReasonId(v)
		return nil
	case cattlemove.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlemove.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlemove.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleMove numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleMoveMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleMoveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleMoveMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleMove nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleMoveMutation) ResetField(name string) error {
	switch name {
	case cattlemove.FieldCattleId:
		m.ResetCattleId()
		return nil
	case cattlemove.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlemove.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlemove.FieldFarmId:
		m.ResetFarmId()
		return nil
	case cattlemove.FieldFarmName:
		m.ResetFarmName()
		return nil
	case cattlemove.FieldShedId:
		m.ResetShedId()
		return nil
	case cattlemove.FieldShedName:
		m.ResetShedName()
		return nil
	case cattlemove.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case cattlemove.FieldDate:
		m.ResetDate()
		return nil
	case cattlemove.FieldFromShedId:
		m.ResetFromShedId()
		return nil
	case cattlemove.FieldFromShed:
		m.ResetFromShed()
		return nil
	case cattlemove.FieldToShedId:
		m.ResetToShedId()
		return nil
	case cattlemove.FieldToShed:
		m.ResetToShed()
		return nil
	case cattlemove.FieldUserName:
		m.ResetUserName()
		return nil
	case cattlemove.FieldReasonId:
		m.ResetReasonId()
		return nil
	case cattlemove.FieldReasonName:
		m.ResetReasonName()
		return nil
	case cattlemove.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlemove.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlemove.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlemove.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleMove field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleMoveMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleMoveMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleMoveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleMoveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleMoveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleMoveMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleMoveMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleMove unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleMoveMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleMove edge %s", name)
}

// CattleMoveReasonMutation represents an operation that mutate the CattleMoveReasons
// nodes in the graph.
type CattleMoveReasonMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	_order        *int
	add_order     *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleMoveReason, error)
}

var _ ent.Mutation = (*CattleMoveReasonMutation)(nil)

// cattlemovereasonOption allows to manage the mutation configuration using functional options.
type cattlemovereasonOption func(*CattleMoveReasonMutation)

// newCattleMoveReasonMutation creates new mutation for $n.Name.
func newCattleMoveReasonMutation(c config, op Op, opts ...cattlemovereasonOption) *CattleMoveReasonMutation {
	m := &CattleMoveReasonMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleMoveReason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleMoveReasonID sets the id field of the mutation.
func withCattleMoveReasonID(id int64) cattlemovereasonOption {
	return func(m *CattleMoveReasonMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleMoveReason
		)
		m.oldValue = func(ctx context.Context) (*CattleMoveReason, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleMoveReason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleMoveReason sets the old CattleMoveReason of the mutation.
func withCattleMoveReason(node *CattleMoveReason) cattlemovereasonOption {
	return func(m *CattleMoveReasonMutation) {
		m.oldValue = func(context.Context) (*CattleMoveReason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleMoveReasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleMoveReasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleMoveReasonMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleMoveReasonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleMoveReasonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleMoveReasonMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *CattleMoveReasonMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *CattleMoveReasonMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *CattleMoveReasonMutation) ResetCode() {
	m.code = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleMoveReasonMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleMoveReasonMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleMoveReasonMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleMoveReasonMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleMoveReasonMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleMoveReasonMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleMoveReasonMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleMoveReasonMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetOrder sets the order field.
func (m *CattleMoveReasonMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the order value in the mutation.
func (m *CattleMoveReasonMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old order value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to order.
func (m *CattleMoveReasonMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the order field in this mutation.
func (m *CattleMoveReasonMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder reset all changes of the "order" field.
func (m *CattleMoveReasonMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRemarks sets the remarks field.
func (m *CattleMoveReasonMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleMoveReasonMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleMoveReasonMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleMoveReasonMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleMoveReasonMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleMoveReasonMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleMoveReasonMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleMoveReasonMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleMoveReasonMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleMoveReasonMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleMoveReasonMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleMoveReasonMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleMoveReasonMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleMoveReasonMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleMoveReasonMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleMoveReason.
// If the CattleMoveReason object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleMoveReasonMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleMoveReasonMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleMoveReasonMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleMoveReasonMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleMoveReasonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleMoveReason).
func (m *CattleMoveReasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleMoveReasonMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, cattlemovereason.FieldName)
	}
	if m.code != nil {
		fields = append(fields, cattlemovereason.FieldCode)
	}
	if m.tenantId != nil {
		fields = append(fields, cattlemovereason.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattlemovereason.FieldTenantName)
	}
	if m._order != nil {
		fields = append(fields, cattlemovereason.FieldOrder)
	}
	if m.remarks != nil {
		fields = append(fields, cattlemovereason.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattlemovereason.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattlemovereason.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattlemovereason.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleMoveReasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattlemovereason.FieldName:
		return m.Name()
	case cattlemovereason.FieldCode:
		return m.Code()
	case cattlemovereason.FieldTenantId:
		return m.TenantId()
	case cattlemovereason.FieldTenantName:
		return m.TenantName()
	case cattlemovereason.FieldOrder:
		return m.Order()
	case cattlemovereason.FieldRemarks:
		return m.Remarks()
	case cattlemovereason.FieldCreatedAt:
		return m.CreatedAt()
	case cattlemovereason.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattlemovereason.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleMoveReasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattlemovereason.FieldName:
		return m.OldName(ctx)
	case cattlemovereason.FieldCode:
		return m.OldCode(ctx)
	case cattlemovereason.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattlemovereason.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattlemovereason.FieldOrder:
		return m.OldOrder(ctx)
	case cattlemovereason.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattlemovereason.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattlemovereason.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattlemovereason.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleMoveReason field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMoveReasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattlemovereason.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cattlemovereason.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case cattlemovereason.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattlemovereason.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattlemovereason.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case cattlemovereason.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattlemovereason.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattlemovereason.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattlemovereason.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleMoveReason field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleMoveReasonMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, cattlemovereason.FieldTenantId)
	}
	if m.add_order != nil {
		fields = append(fields, cattlemovereason.FieldOrder)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattlemovereason.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattlemovereason.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattlemovereason.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleMoveReasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattlemovereason.FieldTenantId:
		return m.AddedTenantId()
	case cattlemovereason.FieldOrder:
		return m.AddedOrder()
	case cattlemovereason.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattlemovereason.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattlemovereason.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleMoveReasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattlemovereason.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattlemovereason.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case cattlemovereason.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattlemovereason.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattlemovereason.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleMoveReason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleMoveReasonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleMoveReasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleMoveReasonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleMoveReason nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleMoveReasonMutation) ResetField(name string) error {
	switch name {
	case cattlemovereason.FieldName:
		m.ResetName()
		return nil
	case cattlemovereason.FieldCode:
		m.ResetCode()
		return nil
	case cattlemovereason.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattlemovereason.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattlemovereason.FieldOrder:
		m.ResetOrder()
		return nil
	case cattlemovereason.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattlemovereason.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattlemovereason.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattlemovereason.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleMoveReason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleMoveReasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleMoveReasonMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleMoveReasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleMoveReasonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleMoveReasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleMoveReasonMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleMoveReasonMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleMoveReason unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleMoveReasonMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleMoveReason edge %s", name)
}

// CattleOutMutation represents an operation that mutate the CattleOuts
// nodes in the graph.
type CattleOutMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	outType        *int64
	addoutType     *int64
	date           *int64
	adddate        *int64
	to             *string
	weight         *int64
	addweight      *int64
	cost           *int64
	addcost        *int64
	shippingFee    *int64
	addshippingFee *int64
	shippingCode   *string
	userName       *string
	checkCode      *string
	tenantId       *int64
	addtenantId    *int64
	tenantName     *string
	remarks        *string
	createdAt      *int64
	addcreatedAt   *int64
	updatedAt      *int64
	addupdatedAt   *int64
	deleted        *int
	adddeleted     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*CattleOut, error)
}

var _ ent.Mutation = (*CattleOutMutation)(nil)

// cattleoutOption allows to manage the mutation configuration using functional options.
type cattleoutOption func(*CattleOutMutation)

// newCattleOutMutation creates new mutation for $n.Name.
func newCattleOutMutation(c config, op Op, opts ...cattleoutOption) *CattleOutMutation {
	m := &CattleOutMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleOut,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleOutID sets the id field of the mutation.
func withCattleOutID(id int64) cattleoutOption {
	return func(m *CattleOutMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleOut
		)
		m.oldValue = func(ctx context.Context) (*CattleOut, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleOut.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleOut sets the old CattleOut of the mutation.
func withCattleOut(node *CattleOut) cattleoutOption {
	return func(m *CattleOutMutation) {
		m.oldValue = func(context.Context) (*CattleOut, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleOutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleOutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleOutMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOutType sets the outType field.
func (m *CattleOutMutation) SetOutType(i int64) {
	m.outType = &i
	m.addoutType = nil
}

// OutType returns the outType value in the mutation.
func (m *CattleOutMutation) OutType() (r int64, exists bool) {
	v := m.outType
	if v == nil {
		return
	}
	return *v, true
}

// OldOutType returns the old outType value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldOutType(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutType: %w", err)
	}
	return oldValue.OutType, nil
}

// AddOutType adds i to outType.
func (m *CattleOutMutation) AddOutType(i int64) {
	if m.addoutType != nil {
		*m.addoutType += i
	} else {
		m.addoutType = &i
	}
}

// AddedOutType returns the value that was added to the outType field in this mutation.
func (m *CattleOutMutation) AddedOutType() (r int64, exists bool) {
	v := m.addoutType
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutType reset all changes of the "outType" field.
func (m *CattleOutMutation) ResetOutType() {
	m.outType = nil
	m.addoutType = nil
}

// SetDate sets the date field.
func (m *CattleOutMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *CattleOutMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *CattleOutMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *CattleOutMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *CattleOutMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetTo sets the to field.
func (m *CattleOutMutation) SetTo(s string) {
	m.to = &s
}

// To returns the to value in the mutation.
func (m *CattleOutMutation) To() (r string, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old to value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldTo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// ResetTo reset all changes of the "to" field.
func (m *CattleOutMutation) ResetTo() {
	m.to = nil
}

// SetWeight sets the weight field.
func (m *CattleOutMutation) SetWeight(i int64) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *CattleOutMutation) Weight() (r int64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldWeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to weight.
func (m *CattleOutMutation) AddWeight(i int64) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *CattleOutMutation) AddedWeight() (r int64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *CattleOutMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetCost sets the cost field.
func (m *CattleOutMutation) SetCost(i int64) {
	m.cost = &i
	m.addcost = nil
}

// Cost returns the cost value in the mutation.
func (m *CattleOutMutation) Cost() (r int64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old cost value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCost is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds i to cost.
func (m *CattleOutMutation) AddCost(i int64) {
	if m.addcost != nil {
		*m.addcost += i
	} else {
		m.addcost = &i
	}
}

// AddedCost returns the value that was added to the cost field in this mutation.
func (m *CattleOutMutation) AddedCost() (r int64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost reset all changes of the "cost" field.
func (m *CattleOutMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetShippingFee sets the shippingFee field.
func (m *CattleOutMutation) SetShippingFee(i int64) {
	m.shippingFee = &i
	m.addshippingFee = nil
}

// ShippingFee returns the shippingFee value in the mutation.
func (m *CattleOutMutation) ShippingFee() (r int64, exists bool) {
	v := m.shippingFee
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingFee returns the old shippingFee value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldShippingFee(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingFee is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingFee: %w", err)
	}
	return oldValue.ShippingFee, nil
}

// AddShippingFee adds i to shippingFee.
func (m *CattleOutMutation) AddShippingFee(i int64) {
	if m.addshippingFee != nil {
		*m.addshippingFee += i
	} else {
		m.addshippingFee = &i
	}
}

// AddedShippingFee returns the value that was added to the shippingFee field in this mutation.
func (m *CattleOutMutation) AddedShippingFee() (r int64, exists bool) {
	v := m.addshippingFee
	if v == nil {
		return
	}
	return *v, true
}

// ResetShippingFee reset all changes of the "shippingFee" field.
func (m *CattleOutMutation) ResetShippingFee() {
	m.shippingFee = nil
	m.addshippingFee = nil
}

// SetShippingCode sets the shippingCode field.
func (m *CattleOutMutation) SetShippingCode(s string) {
	m.shippingCode = &s
}

// ShippingCode returns the shippingCode value in the mutation.
func (m *CattleOutMutation) ShippingCode() (r string, exists bool) {
	v := m.shippingCode
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingCode returns the old shippingCode value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldShippingCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShippingCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShippingCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingCode: %w", err)
	}
	return oldValue.ShippingCode, nil
}

// ResetShippingCode reset all changes of the "shippingCode" field.
func (m *CattleOutMutation) ResetShippingCode() {
	m.shippingCode = nil
}

// SetUserName sets the userName field.
func (m *CattleOutMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *CattleOutMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *CattleOutMutation) ResetUserName() {
	m.userName = nil
}

// SetCheckCode sets the checkCode field.
func (m *CattleOutMutation) SetCheckCode(s string) {
	m.checkCode = &s
}

// CheckCode returns the checkCode value in the mutation.
func (m *CattleOutMutation) CheckCode() (r string, exists bool) {
	v := m.checkCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckCode returns the old checkCode value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldCheckCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckCode: %w", err)
	}
	return oldValue.CheckCode, nil
}

// ResetCheckCode reset all changes of the "checkCode" field.
func (m *CattleOutMutation) ResetCheckCode() {
	m.checkCode = nil
}

// SetTenantId sets the tenantId field.
func (m *CattleOutMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CattleOutMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CattleOutMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CattleOutMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CattleOutMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CattleOutMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CattleOutMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CattleOutMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *CattleOutMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CattleOutMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CattleOutMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CattleOutMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CattleOutMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CattleOutMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CattleOutMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CattleOutMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CattleOutMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CattleOutMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CattleOutMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CattleOutMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CattleOutMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CattleOutMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CattleOutMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the CattleOut.
// If the CattleOut object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOutMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CattleOutMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CattleOutMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CattleOutMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CattleOutMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleOut).
func (m *CattleOutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleOutMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.outType != nil {
		fields = append(fields, cattleout.FieldOutType)
	}
	if m.date != nil {
		fields = append(fields, cattleout.FieldDate)
	}
	if m.to != nil {
		fields = append(fields, cattleout.FieldTo)
	}
	if m.weight != nil {
		fields = append(fields, cattleout.FieldWeight)
	}
	if m.cost != nil {
		fields = append(fields, cattleout.FieldCost)
	}
	if m.shippingFee != nil {
		fields = append(fields, cattleout.FieldShippingFee)
	}
	if m.shippingCode != nil {
		fields = append(fields, cattleout.FieldShippingCode)
	}
	if m.userName != nil {
		fields = append(fields, cattleout.FieldUserName)
	}
	if m.checkCode != nil {
		fields = append(fields, cattleout.FieldCheckCode)
	}
	if m.tenantId != nil {
		fields = append(fields, cattleout.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, cattleout.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, cattleout.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, cattleout.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, cattleout.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, cattleout.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleOutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattleout.FieldOutType:
		return m.OutType()
	case cattleout.FieldDate:
		return m.Date()
	case cattleout.FieldTo:
		return m.To()
	case cattleout.FieldWeight:
		return m.Weight()
	case cattleout.FieldCost:
		return m.Cost()
	case cattleout.FieldShippingFee:
		return m.ShippingFee()
	case cattleout.FieldShippingCode:
		return m.ShippingCode()
	case cattleout.FieldUserName:
		return m.UserName()
	case cattleout.FieldCheckCode:
		return m.CheckCode()
	case cattleout.FieldTenantId:
		return m.TenantId()
	case cattleout.FieldTenantName:
		return m.TenantName()
	case cattleout.FieldRemarks:
		return m.Remarks()
	case cattleout.FieldCreatedAt:
		return m.CreatedAt()
	case cattleout.FieldUpdatedAt:
		return m.UpdatedAt()
	case cattleout.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleOutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattleout.FieldOutType:
		return m.OldOutType(ctx)
	case cattleout.FieldDate:
		return m.OldDate(ctx)
	case cattleout.FieldTo:
		return m.OldTo(ctx)
	case cattleout.FieldWeight:
		return m.OldWeight(ctx)
	case cattleout.FieldCost:
		return m.OldCost(ctx)
	case cattleout.FieldShippingFee:
		return m.OldShippingFee(ctx)
	case cattleout.FieldShippingCode:
		return m.OldShippingCode(ctx)
	case cattleout.FieldUserName:
		return m.OldUserName(ctx)
	case cattleout.FieldCheckCode:
		return m.OldCheckCode(ctx)
	case cattleout.FieldTenantId:
		return m.OldTenantId(ctx)
	case cattleout.FieldTenantName:
		return m.OldTenantName(ctx)
	case cattleout.FieldRemarks:
		return m.OldRemarks(ctx)
	case cattleout.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cattleout.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cattleout.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown CattleOut field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleOutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattleout.FieldOutType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutType(v)
		return nil
	case cattleout.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case cattleout.FieldTo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	case cattleout.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case cattleout.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case cattleout.FieldShippingFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingFee(v)
		return nil
	case cattleout.FieldShippingCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingCode(v)
		return nil
	case cattleout.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case cattleout.FieldCheckCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckCode(v)
		return nil
	case cattleout.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case cattleout.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case cattleout.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case cattleout.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cattleout.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cattleout.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleOut field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleOutMutation) AddedFields() []string {
	var fields []string
	if m.addoutType != nil {
		fields = append(fields, cattleout.FieldOutType)
	}
	if m.adddate != nil {
		fields = append(fields, cattleout.FieldDate)
	}
	if m.addweight != nil {
		fields = append(fields, cattleout.FieldWeight)
	}
	if m.addcost != nil {
		fields = append(fields, cattleout.FieldCost)
	}
	if m.addshippingFee != nil {
		fields = append(fields, cattleout.FieldShippingFee)
	}
	if m.addtenantId != nil {
		fields = append(fields, cattleout.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, cattleout.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, cattleout.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, cattleout.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleOutMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cattleout.FieldOutType:
		return m.AddedOutType()
	case cattleout.FieldDate:
		return m.AddedDate()
	case cattleout.FieldWeight:
		return m.AddedWeight()
	case cattleout.FieldCost:
		return m.AddedCost()
	case cattleout.FieldShippingFee:
		return m.AddedShippingFee()
	case cattleout.FieldTenantId:
		return m.AddedTenantId()
	case cattleout.FieldCreatedAt:
		return m.AddedCreatedAt()
	case cattleout.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case cattleout.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleOutMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cattleout.FieldOutType:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutType(v)
		return nil
	case cattleout.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case cattleout.FieldWeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case cattleout.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case cattleout.FieldShippingFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShippingFee(v)
		return nil
	case cattleout.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case cattleout.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case cattleout.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case cattleout.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CattleOut numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleOutMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleOutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleOutMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleOut nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleOutMutation) ResetField(name string) error {
	switch name {
	case cattleout.FieldOutType:
		m.ResetOutType()
		return nil
	case cattleout.FieldDate:
		m.ResetDate()
		return nil
	case cattleout.FieldTo:
		m.ResetTo()
		return nil
	case cattleout.FieldWeight:
		m.ResetWeight()
		return nil
	case cattleout.FieldCost:
		m.ResetCost()
		return nil
	case cattleout.FieldShippingFee:
		m.ResetShippingFee()
		return nil
	case cattleout.FieldShippingCode:
		m.ResetShippingCode()
		return nil
	case cattleout.FieldUserName:
		m.ResetUserName()
		return nil
	case cattleout.FieldCheckCode:
		m.ResetCheckCode()
		return nil
	case cattleout.FieldTenantId:
		m.ResetTenantId()
		return nil
	case cattleout.FieldTenantName:
		m.ResetTenantName()
		return nil
	case cattleout.FieldRemarks:
		m.ResetRemarks()
		return nil
	case cattleout.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cattleout.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cattleout.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown CattleOut field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleOutMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleOutMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleOutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleOutMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleOutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleOutMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleOutMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleOut unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleOutMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleOut edge %s", name)
}

// CattleOwnerMutation represents an operation that mutate the CattleOwners
// nodes in the graph.
type CattleOwnerMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleOwner, error)
}

var _ ent.Mutation = (*CattleOwnerMutation)(nil)

// cattleownerOption allows to manage the mutation configuration using functional options.
type cattleownerOption func(*CattleOwnerMutation)

// newCattleOwnerMutation creates new mutation for $n.Name.
func newCattleOwnerMutation(c config, op Op, opts ...cattleownerOption) *CattleOwnerMutation {
	m := &CattleOwnerMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleOwner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleOwnerID sets the id field of the mutation.
func withCattleOwnerID(id int64) cattleownerOption {
	return func(m *CattleOwnerMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleOwner
		)
		m.oldValue = func(ctx context.Context) (*CattleOwner, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleOwner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleOwner sets the old CattleOwner of the mutation.
func withCattleOwner(node *CattleOwner) cattleownerOption {
	return func(m *CattleOwnerMutation) {
		m.oldValue = func(context.Context) (*CattleOwner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleOwnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleOwnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleOwnerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleOwnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleOwnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleOwner.
// If the CattleOwner object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleOwnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleOwnerMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleOwnerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleOwner).
func (m *CattleOwnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleOwnerMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattleowner.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleOwnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattleowner.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleOwnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattleowner.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleOwner field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleOwnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattleowner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleOwner field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleOwnerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleOwnerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleOwnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleOwner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleOwnerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleOwnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleOwnerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleOwner nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleOwnerMutation) ResetField(name string) error {
	switch name {
	case cattleowner.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleOwner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleOwnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleOwnerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleOwnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleOwnerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleOwnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleOwnerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleOwnerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleOwner unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleOwnerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleOwner edge %s", name)
}

// CattleTypeMutation represents an operation that mutate the CattleTypes
// nodes in the graph.
type CattleTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CattleType, error)
}

var _ ent.Mutation = (*CattleTypeMutation)(nil)

// cattletypeOption allows to manage the mutation configuration using functional options.
type cattletypeOption func(*CattleTypeMutation)

// newCattleTypeMutation creates new mutation for $n.Name.
func newCattleTypeMutation(c config, op Op, opts ...cattletypeOption) *CattleTypeMutation {
	m := &CattleTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCattleType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCattleTypeID sets the id field of the mutation.
func withCattleTypeID(id int64) cattletypeOption {
	return func(m *CattleTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CattleType
		)
		m.oldValue = func(ctx context.Context) (*CattleType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CattleType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCattleType sets the old CattleType of the mutation.
func withCattleType(node *CattleType) cattletypeOption {
	return func(m *CattleTypeMutation) {
		m.oldValue = func(context.Context) (*CattleType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CattleTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CattleTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CattleTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CattleTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CattleTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the CattleType.
// If the CattleType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CattleTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CattleTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *CattleTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CattleType).
func (m *CattleTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CattleTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, cattletype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CattleTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cattletype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CattleTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cattletype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown CattleType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cattletype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown CattleType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CattleTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CattleTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CattleTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CattleType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CattleTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CattleTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CattleTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CattleType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CattleTypeMutation) ResetField(name string) error {
	switch name {
	case cattletype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown CattleType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CattleTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CattleTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CattleTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CattleTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CattleTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CattleTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CattleTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CattleType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CattleTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CattleType edge %s", name)
}

// ChangeMutation represents an operation that mutate the Changes
// nodes in the graph.
type ChangeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Change, error)
}

var _ ent.Mutation = (*ChangeMutation)(nil)

// changeOption allows to manage the mutation configuration using functional options.
type changeOption func(*ChangeMutation)

// newChangeMutation creates new mutation for $n.Name.
func newChangeMutation(c config, op Op, opts ...changeOption) *ChangeMutation {
	m := &ChangeMutation{
		config:        c,
		op:            op,
		typ:           TypeChange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangeID sets the id field of the mutation.
func withChangeID(id int64) changeOption {
	return func(m *ChangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Change
		)
		m.oldValue = func(ctx context.Context) (*Change, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Change.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChange sets the old Change of the mutation.
func withChange(node *Change) changeOption {
	return func(m *ChangeMutation) {
		m.oldValue = func(context.Context) (*Change, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ChangeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *ChangeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Change).
func (m *ChangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ChangeMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ChangeMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ChangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Change field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ChangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Change field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ChangeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ChangeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ChangeMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Change numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ChangeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ChangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Change nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ChangeMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Change field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ChangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ChangeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ChangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ChangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ChangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ChangeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ChangeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Change unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ChangeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Change edge %s", name)
}

// ConcentrateFormulaMutation represents an operation that mutate the ConcentrateFormulas
// nodes in the graph.
type ConcentrateFormulaMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	name           *string
	code           *string
	status         *int
	addstatus      *int
	createDate     *int64
	addcreateDate  *int64
	adjustDate     *int64
	addadjustDate  *int64
	disableDate    *int64
	adddisableDate *int64
	cost           *int64
	addcost        *int64
	data           *string
	tenantId       *int64
	addtenantId    *int64
	tenantName     *string
	remarks        *string
	createdAt      *int64
	addcreatedAt   *int64
	updatedAt      *int64
	addupdatedAt   *int64
	deleted        *int
	adddeleted     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ConcentrateFormula, error)
}

var _ ent.Mutation = (*ConcentrateFormulaMutation)(nil)

// concentrateformulaOption allows to manage the mutation configuration using functional options.
type concentrateformulaOption func(*ConcentrateFormulaMutation)

// newConcentrateFormulaMutation creates new mutation for $n.Name.
func newConcentrateFormulaMutation(c config, op Op, opts ...concentrateformulaOption) *ConcentrateFormulaMutation {
	m := &ConcentrateFormulaMutation{
		config:        c,
		op:            op,
		typ:           TypeConcentrateFormula,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConcentrateFormulaID sets the id field of the mutation.
func withConcentrateFormulaID(id int64) concentrateformulaOption {
	return func(m *ConcentrateFormulaMutation) {
		var (
			err   error
			once  sync.Once
			value *ConcentrateFormula
		)
		m.oldValue = func(ctx context.Context) (*ConcentrateFormula, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConcentrateFormula.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConcentrateFormula sets the old ConcentrateFormula of the mutation.
func withConcentrateFormula(node *ConcentrateFormula) concentrateformulaOption {
	return func(m *ConcentrateFormulaMutation) {
		m.oldValue = func(context.Context) (*ConcentrateFormula, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConcentrateFormulaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConcentrateFormulaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConcentrateFormulaMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ConcentrateFormulaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ConcentrateFormulaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ConcentrateFormulaMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *ConcentrateFormulaMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *ConcentrateFormulaMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *ConcentrateFormulaMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the status field.
func (m *ConcentrateFormulaMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *ConcentrateFormulaMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *ConcentrateFormulaMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *ConcentrateFormulaMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *ConcentrateFormulaMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateDate sets the createDate field.
func (m *ConcentrateFormulaMutation) SetCreateDate(i int64) {
	m.createDate = &i
	m.addcreateDate = nil
}

// CreateDate returns the createDate value in the mutation.
func (m *ConcentrateFormulaMutation) CreateDate() (r int64, exists bool) {
	v := m.createDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateDate returns the old createDate value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldCreateDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateDate: %w", err)
	}
	return oldValue.CreateDate, nil
}

// AddCreateDate adds i to createDate.
func (m *ConcentrateFormulaMutation) AddCreateDate(i int64) {
	if m.addcreateDate != nil {
		*m.addcreateDate += i
	} else {
		m.addcreateDate = &i
	}
}

// AddedCreateDate returns the value that was added to the createDate field in this mutation.
func (m *ConcentrateFormulaMutation) AddedCreateDate() (r int64, exists bool) {
	v := m.addcreateDate
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateDate reset all changes of the "createDate" field.
func (m *ConcentrateFormulaMutation) ResetCreateDate() {
	m.createDate = nil
	m.addcreateDate = nil
}

// SetAdjustDate sets the adjustDate field.
func (m *ConcentrateFormulaMutation) SetAdjustDate(i int64) {
	m.adjustDate = &i
	m.addadjustDate = nil
}

// AdjustDate returns the adjustDate value in the mutation.
func (m *ConcentrateFormulaMutation) AdjustDate() (r int64, exists bool) {
	v := m.adjustDate
	if v == nil {
		return
	}
	return *v, true
}

// OldAdjustDate returns the old adjustDate value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldAdjustDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdjustDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdjustDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdjustDate: %w", err)
	}
	return oldValue.AdjustDate, nil
}

// AddAdjustDate adds i to adjustDate.
func (m *ConcentrateFormulaMutation) AddAdjustDate(i int64) {
	if m.addadjustDate != nil {
		*m.addadjustDate += i
	} else {
		m.addadjustDate = &i
	}
}

// AddedAdjustDate returns the value that was added to the adjustDate field in this mutation.
func (m *ConcentrateFormulaMutation) AddedAdjustDate() (r int64, exists bool) {
	v := m.addadjustDate
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdjustDate reset all changes of the "adjustDate" field.
func (m *ConcentrateFormulaMutation) ResetAdjustDate() {
	m.adjustDate = nil
	m.addadjustDate = nil
}

// SetDisableDate sets the disableDate field.
func (m *ConcentrateFormulaMutation) SetDisableDate(i int64) {
	m.disableDate = &i
	m.adddisableDate = nil
}

// DisableDate returns the disableDate value in the mutation.
func (m *ConcentrateFormulaMutation) DisableDate() (r int64, exists bool) {
	v := m.disableDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDisableDate returns the old disableDate value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldDisableDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisableDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisableDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisableDate: %w", err)
	}
	return oldValue.DisableDate, nil
}

// AddDisableDate adds i to disableDate.
func (m *ConcentrateFormulaMutation) AddDisableDate(i int64) {
	if m.adddisableDate != nil {
		*m.adddisableDate += i
	} else {
		m.adddisableDate = &i
	}
}

// AddedDisableDate returns the value that was added to the disableDate field in this mutation.
func (m *ConcentrateFormulaMutation) AddedDisableDate() (r int64, exists bool) {
	v := m.adddisableDate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisableDate reset all changes of the "disableDate" field.
func (m *ConcentrateFormulaMutation) ResetDisableDate() {
	m.disableDate = nil
	m.adddisableDate = nil
}

// SetCost sets the cost field.
func (m *ConcentrateFormulaMutation) SetCost(i int64) {
	m.cost = &i
	m.addcost = nil
}

// Cost returns the cost value in the mutation.
func (m *ConcentrateFormulaMutation) Cost() (r int64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old cost value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCost is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds i to cost.
func (m *ConcentrateFormulaMutation) AddCost(i int64) {
	if m.addcost != nil {
		*m.addcost += i
	} else {
		m.addcost = &i
	}
}

// AddedCost returns the value that was added to the cost field in this mutation.
func (m *ConcentrateFormulaMutation) AddedCost() (r int64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost reset all changes of the "cost" field.
func (m *ConcentrateFormulaMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetData sets the data field.
func (m *ConcentrateFormulaMutation) SetData(s string) {
	m.data = &s
}

// Data returns the data value in the mutation.
func (m *ConcentrateFormulaMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old data value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldData is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData reset all changes of the "data" field.
func (m *ConcentrateFormulaMutation) ResetData() {
	m.data = nil
}

// SetTenantId sets the tenantId field.
func (m *ConcentrateFormulaMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *ConcentrateFormulaMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *ConcentrateFormulaMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *ConcentrateFormulaMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *ConcentrateFormulaMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *ConcentrateFormulaMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *ConcentrateFormulaMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *ConcentrateFormulaMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *ConcentrateFormulaMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ConcentrateFormulaMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ConcentrateFormulaMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ConcentrateFormulaMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ConcentrateFormulaMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ConcentrateFormulaMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ConcentrateFormulaMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ConcentrateFormulaMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ConcentrateFormulaMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ConcentrateFormulaMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ConcentrateFormulaMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ConcentrateFormulaMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ConcentrateFormulaMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ConcentrateFormulaMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ConcentrateFormulaMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the ConcentrateFormula.
// If the ConcentrateFormula object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateFormulaMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ConcentrateFormulaMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ConcentrateFormulaMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ConcentrateFormulaMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ConcentrateFormulaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ConcentrateFormula).
func (m *ConcentrateFormulaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConcentrateFormulaMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, concentrateformula.FieldName)
	}
	if m.code != nil {
		fields = append(fields, concentrateformula.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, concentrateformula.FieldStatus)
	}
	if m.createDate != nil {
		fields = append(fields, concentrateformula.FieldCreateDate)
	}
	if m.adjustDate != nil {
		fields = append(fields, concentrateformula.FieldAdjustDate)
	}
	if m.disableDate != nil {
		fields = append(fields, concentrateformula.FieldDisableDate)
	}
	if m.cost != nil {
		fields = append(fields, concentrateformula.FieldCost)
	}
	if m.data != nil {
		fields = append(fields, concentrateformula.FieldData)
	}
	if m.tenantId != nil {
		fields = append(fields, concentrateformula.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, concentrateformula.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, concentrateformula.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, concentrateformula.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, concentrateformula.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, concentrateformula.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConcentrateFormulaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case concentrateformula.FieldName:
		return m.Name()
	case concentrateformula.FieldCode:
		return m.Code()
	case concentrateformula.FieldStatus:
		return m.Status()
	case concentrateformula.FieldCreateDate:
		return m.CreateDate()
	case concentrateformula.FieldAdjustDate:
		return m.AdjustDate()
	case concentrateformula.FieldDisableDate:
		return m.DisableDate()
	case concentrateformula.FieldCost:
		return m.Cost()
	case concentrateformula.FieldData:
		return m.Data()
	case concentrateformula.FieldTenantId:
		return m.TenantId()
	case concentrateformula.FieldTenantName:
		return m.TenantName()
	case concentrateformula.FieldRemarks:
		return m.Remarks()
	case concentrateformula.FieldCreatedAt:
		return m.CreatedAt()
	case concentrateformula.FieldUpdatedAt:
		return m.UpdatedAt()
	case concentrateformula.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ConcentrateFormulaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case concentrateformula.FieldName:
		return m.OldName(ctx)
	case concentrateformula.FieldCode:
		return m.OldCode(ctx)
	case concentrateformula.FieldStatus:
		return m.OldStatus(ctx)
	case concentrateformula.FieldCreateDate:
		return m.OldCreateDate(ctx)
	case concentrateformula.FieldAdjustDate:
		return m.OldAdjustDate(ctx)
	case concentrateformula.FieldDisableDate:
		return m.OldDisableDate(ctx)
	case concentrateformula.FieldCost:
		return m.OldCost(ctx)
	case concentrateformula.FieldData:
		return m.OldData(ctx)
	case concentrateformula.FieldTenantId:
		return m.OldTenantId(ctx)
	case concentrateformula.FieldTenantName:
		return m.OldTenantName(ctx)
	case concentrateformula.FieldRemarks:
		return m.OldRemarks(ctx)
	case concentrateformula.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case concentrateformula.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case concentrateformula.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown ConcentrateFormula field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConcentrateFormulaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case concentrateformula.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case concentrateformula.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case concentrateformula.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case concentrateformula.FieldCreateDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateDate(v)
		return nil
	case concentrateformula.FieldAdjustDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdjustDate(v)
		return nil
	case concentrateformula.FieldDisableDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisableDate(v)
		return nil
	case concentrateformula.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case concentrateformula.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case concentrateformula.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case concentrateformula.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case concentrateformula.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case concentrateformula.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case concentrateformula.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case concentrateformula.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ConcentrateFormula field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConcentrateFormulaMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, concentrateformula.FieldStatus)
	}
	if m.addcreateDate != nil {
		fields = append(fields, concentrateformula.FieldCreateDate)
	}
	if m.addadjustDate != nil {
		fields = append(fields, concentrateformula.FieldAdjustDate)
	}
	if m.adddisableDate != nil {
		fields = append(fields, concentrateformula.FieldDisableDate)
	}
	if m.addcost != nil {
		fields = append(fields, concentrateformula.FieldCost)
	}
	if m.addtenantId != nil {
		fields = append(fields, concentrateformula.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, concentrateformula.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, concentrateformula.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, concentrateformula.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConcentrateFormulaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case concentrateformula.FieldStatus:
		return m.AddedStatus()
	case concentrateformula.FieldCreateDate:
		return m.AddedCreateDate()
	case concentrateformula.FieldAdjustDate:
		return m.AddedAdjustDate()
	case concentrateformula.FieldDisableDate:
		return m.AddedDisableDate()
	case concentrateformula.FieldCost:
		return m.AddedCost()
	case concentrateformula.FieldTenantId:
		return m.AddedTenantId()
	case concentrateformula.FieldCreatedAt:
		return m.AddedCreatedAt()
	case concentrateformula.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case concentrateformula.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConcentrateFormulaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case concentrateformula.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case concentrateformula.FieldCreateDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateDate(v)
		return nil
	case concentrateformula.FieldAdjustDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdjustDate(v)
		return nil
	case concentrateformula.FieldDisableDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisableDate(v)
		return nil
	case concentrateformula.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case concentrateformula.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case concentrateformula.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case concentrateformula.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case concentrateformula.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ConcentrateFormula numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConcentrateFormulaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConcentrateFormulaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConcentrateFormulaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConcentrateFormula nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConcentrateFormulaMutation) ResetField(name string) error {
	switch name {
	case concentrateformula.FieldName:
		m.ResetName()
		return nil
	case concentrateformula.FieldCode:
		m.ResetCode()
		return nil
	case concentrateformula.FieldStatus:
		m.ResetStatus()
		return nil
	case concentrateformula.FieldCreateDate:
		m.ResetCreateDate()
		return nil
	case concentrateformula.FieldAdjustDate:
		m.ResetAdjustDate()
		return nil
	case concentrateformula.FieldDisableDate:
		m.ResetDisableDate()
		return nil
	case concentrateformula.FieldCost:
		m.ResetCost()
		return nil
	case concentrateformula.FieldData:
		m.ResetData()
		return nil
	case concentrateformula.FieldTenantId:
		m.ResetTenantId()
		return nil
	case concentrateformula.FieldTenantName:
		m.ResetTenantName()
		return nil
	case concentrateformula.FieldRemarks:
		m.ResetRemarks()
		return nil
	case concentrateformula.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case concentrateformula.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case concentrateformula.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown ConcentrateFormula field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConcentrateFormulaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConcentrateFormulaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConcentrateFormulaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConcentrateFormulaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConcentrateFormulaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConcentrateFormulaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConcentrateFormulaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConcentrateFormula unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConcentrateFormulaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConcentrateFormula edge %s", name)
}

// ConcentrateProcessMutation represents an operation that mutate the ConcentrateProcesses
// nodes in the graph.
type ConcentrateProcessMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	formulaID     *int64
	addformulaID  *int64
	name          *string
	code          *string
	date          *int64
	adddate       *int64
	count         *int64
	addcount      *int64
	in            *int64
	addin         *int64
	inventory     *int64
	addinventory  *int64
	userName      *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ConcentrateProcess, error)
}

var _ ent.Mutation = (*ConcentrateProcessMutation)(nil)

// concentrateprocessOption allows to manage the mutation configuration using functional options.
type concentrateprocessOption func(*ConcentrateProcessMutation)

// newConcentrateProcessMutation creates new mutation for $n.Name.
func newConcentrateProcessMutation(c config, op Op, opts ...concentrateprocessOption) *ConcentrateProcessMutation {
	m := &ConcentrateProcessMutation{
		config:        c,
		op:            op,
		typ:           TypeConcentrateProcess,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConcentrateProcessID sets the id field of the mutation.
func withConcentrateProcessID(id int64) concentrateprocessOption {
	return func(m *ConcentrateProcessMutation) {
		var (
			err   error
			once  sync.Once
			value *ConcentrateProcess
		)
		m.oldValue = func(ctx context.Context) (*ConcentrateProcess, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConcentrateProcess.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConcentrateProcess sets the old ConcentrateProcess of the mutation.
func withConcentrateProcess(node *ConcentrateProcess) concentrateprocessOption {
	return func(m *ConcentrateProcessMutation) {
		m.oldValue = func(context.Context) (*ConcentrateProcess, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConcentrateProcessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConcentrateProcessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConcentrateProcessMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFormulaID sets the formulaID field.
func (m *ConcentrateProcessMutation) SetFormulaID(i int64) {
	m.formulaID = &i
	m.addformulaID = nil
}

// FormulaID returns the formulaID value in the mutation.
func (m *ConcentrateProcessMutation) FormulaID() (r int64, exists bool) {
	v := m.formulaID
	if v == nil {
		return
	}
	return *v, true
}

// OldFormulaID returns the old formulaID value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldFormulaID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFormulaID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFormulaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormulaID: %w", err)
	}
	return oldValue.FormulaID, nil
}

// AddFormulaID adds i to formulaID.
func (m *ConcentrateProcessMutation) AddFormulaID(i int64) {
	if m.addformulaID != nil {
		*m.addformulaID += i
	} else {
		m.addformulaID = &i
	}
}

// AddedFormulaID returns the value that was added to the formulaID field in this mutation.
func (m *ConcentrateProcessMutation) AddedFormulaID() (r int64, exists bool) {
	v := m.addformulaID
	if v == nil {
		return
	}
	return *v, true
}

// ResetFormulaID reset all changes of the "formulaID" field.
func (m *ConcentrateProcessMutation) ResetFormulaID() {
	m.formulaID = nil
	m.addformulaID = nil
}

// SetName sets the name field.
func (m *ConcentrateProcessMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ConcentrateProcessMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ConcentrateProcessMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *ConcentrateProcessMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *ConcentrateProcessMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *ConcentrateProcessMutation) ResetCode() {
	m.code = nil
}

// SetDate sets the date field.
func (m *ConcentrateProcessMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *ConcentrateProcessMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *ConcentrateProcessMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *ConcentrateProcessMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *ConcentrateProcessMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetCount sets the count field.
func (m *ConcentrateProcessMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *ConcentrateProcessMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to count.
func (m *ConcentrateProcessMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *ConcentrateProcessMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *ConcentrateProcessMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetIn sets the in field.
func (m *ConcentrateProcessMutation) SetIn(i int64) {
	m.in = &i
	m.addin = nil
}

// In returns the in value in the mutation.
func (m *ConcentrateProcessMutation) In() (r int64, exists bool) {
	v := m.in
	if v == nil {
		return
	}
	return *v, true
}

// OldIn returns the old in value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldIn(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIn: %w", err)
	}
	return oldValue.In, nil
}

// AddIn adds i to in.
func (m *ConcentrateProcessMutation) AddIn(i int64) {
	if m.addin != nil {
		*m.addin += i
	} else {
		m.addin = &i
	}
}

// AddedIn returns the value that was added to the in field in this mutation.
func (m *ConcentrateProcessMutation) AddedIn() (r int64, exists bool) {
	v := m.addin
	if v == nil {
		return
	}
	return *v, true
}

// ResetIn reset all changes of the "in" field.
func (m *ConcentrateProcessMutation) ResetIn() {
	m.in = nil
	m.addin = nil
}

// SetInventory sets the inventory field.
func (m *ConcentrateProcessMutation) SetInventory(i int64) {
	m.inventory = &i
	m.addinventory = nil
}

// Inventory returns the inventory value in the mutation.
func (m *ConcentrateProcessMutation) Inventory() (r int64, exists bool) {
	v := m.inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldInventory returns the old inventory value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldInventory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInventory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventory: %w", err)
	}
	return oldValue.Inventory, nil
}

// AddInventory adds i to inventory.
func (m *ConcentrateProcessMutation) AddInventory(i int64) {
	if m.addinventory != nil {
		*m.addinventory += i
	} else {
		m.addinventory = &i
	}
}

// AddedInventory returns the value that was added to the inventory field in this mutation.
func (m *ConcentrateProcessMutation) AddedInventory() (r int64, exists bool) {
	v := m.addinventory
	if v == nil {
		return
	}
	return *v, true
}

// ResetInventory reset all changes of the "inventory" field.
func (m *ConcentrateProcessMutation) ResetInventory() {
	m.inventory = nil
	m.addinventory = nil
}

// SetUserName sets the userName field.
func (m *ConcentrateProcessMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *ConcentrateProcessMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *ConcentrateProcessMutation) ResetUserName() {
	m.userName = nil
}

// SetTenantId sets the tenantId field.
func (m *ConcentrateProcessMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *ConcentrateProcessMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *ConcentrateProcessMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *ConcentrateProcessMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *ConcentrateProcessMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *ConcentrateProcessMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *ConcentrateProcessMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *ConcentrateProcessMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *ConcentrateProcessMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ConcentrateProcessMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ConcentrateProcessMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ConcentrateProcessMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ConcentrateProcessMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ConcentrateProcessMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ConcentrateProcessMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ConcentrateProcessMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ConcentrateProcessMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ConcentrateProcessMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ConcentrateProcessMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ConcentrateProcessMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ConcentrateProcessMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ConcentrateProcessMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ConcentrateProcessMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the ConcentrateProcess.
// If the ConcentrateProcess object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConcentrateProcessMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ConcentrateProcessMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ConcentrateProcessMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ConcentrateProcessMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ConcentrateProcessMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ConcentrateProcess).
func (m *ConcentrateProcessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConcentrateProcessMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.formulaID != nil {
		fields = append(fields, concentrateprocess.FieldFormulaID)
	}
	if m.name != nil {
		fields = append(fields, concentrateprocess.FieldName)
	}
	if m.code != nil {
		fields = append(fields, concentrateprocess.FieldCode)
	}
	if m.date != nil {
		fields = append(fields, concentrateprocess.FieldDate)
	}
	if m.count != nil {
		fields = append(fields, concentrateprocess.FieldCount)
	}
	if m.in != nil {
		fields = append(fields, concentrateprocess.FieldIn)
	}
	if m.inventory != nil {
		fields = append(fields, concentrateprocess.FieldInventory)
	}
	if m.userName != nil {
		fields = append(fields, concentrateprocess.FieldUserName)
	}
	if m.tenantId != nil {
		fields = append(fields, concentrateprocess.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, concentrateprocess.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, concentrateprocess.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, concentrateprocess.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, concentrateprocess.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, concentrateprocess.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConcentrateProcessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case concentrateprocess.FieldFormulaID:
		return m.FormulaID()
	case concentrateprocess.FieldName:
		return m.Name()
	case concentrateprocess.FieldCode:
		return m.Code()
	case concentrateprocess.FieldDate:
		return m.Date()
	case concentrateprocess.FieldCount:
		return m.Count()
	case concentrateprocess.FieldIn:
		return m.In()
	case concentrateprocess.FieldInventory:
		return m.Inventory()
	case concentrateprocess.FieldUserName:
		return m.UserName()
	case concentrateprocess.FieldTenantId:
		return m.TenantId()
	case concentrateprocess.FieldTenantName:
		return m.TenantName()
	case concentrateprocess.FieldRemarks:
		return m.Remarks()
	case concentrateprocess.FieldCreatedAt:
		return m.CreatedAt()
	case concentrateprocess.FieldUpdatedAt:
		return m.UpdatedAt()
	case concentrateprocess.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ConcentrateProcessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case concentrateprocess.FieldFormulaID:
		return m.OldFormulaID(ctx)
	case concentrateprocess.FieldName:
		return m.OldName(ctx)
	case concentrateprocess.FieldCode:
		return m.OldCode(ctx)
	case concentrateprocess.FieldDate:
		return m.OldDate(ctx)
	case concentrateprocess.FieldCount:
		return m.OldCount(ctx)
	case concentrateprocess.FieldIn:
		return m.OldIn(ctx)
	case concentrateprocess.FieldInventory:
		return m.OldInventory(ctx)
	case concentrateprocess.FieldUserName:
		return m.OldUserName(ctx)
	case concentrateprocess.FieldTenantId:
		return m.OldTenantId(ctx)
	case concentrateprocess.FieldTenantName:
		return m.OldTenantName(ctx)
	case concentrateprocess.FieldRemarks:
		return m.OldRemarks(ctx)
	case concentrateprocess.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case concentrateprocess.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case concentrateprocess.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown ConcentrateProcess field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConcentrateProcessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case concentrateprocess.FieldFormulaID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormulaID(v)
		return nil
	case concentrateprocess.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case concentrateprocess.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case concentrateprocess.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case concentrateprocess.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case concentrateprocess.FieldIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIn(v)
		return nil
	case concentrateprocess.FieldInventory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventory(v)
		return nil
	case concentrateprocess.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case concentrateprocess.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case concentrateprocess.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case concentrateprocess.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case concentrateprocess.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case concentrateprocess.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case concentrateprocess.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ConcentrateProcess field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConcentrateProcessMutation) AddedFields() []string {
	var fields []string
	if m.addformulaID != nil {
		fields = append(fields, concentrateprocess.FieldFormulaID)
	}
	if m.adddate != nil {
		fields = append(fields, concentrateprocess.FieldDate)
	}
	if m.addcount != nil {
		fields = append(fields, concentrateprocess.FieldCount)
	}
	if m.addin != nil {
		fields = append(fields, concentrateprocess.FieldIn)
	}
	if m.addinventory != nil {
		fields = append(fields, concentrateprocess.FieldInventory)
	}
	if m.addtenantId != nil {
		fields = append(fields, concentrateprocess.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, concentrateprocess.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, concentrateprocess.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, concentrateprocess.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConcentrateProcessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case concentrateprocess.FieldFormulaID:
		return m.AddedFormulaID()
	case concentrateprocess.FieldDate:
		return m.AddedDate()
	case concentrateprocess.FieldCount:
		return m.AddedCount()
	case concentrateprocess.FieldIn:
		return m.AddedIn()
	case concentrateprocess.FieldInventory:
		return m.AddedInventory()
	case concentrateprocess.FieldTenantId:
		return m.AddedTenantId()
	case concentrateprocess.FieldCreatedAt:
		return m.AddedCreatedAt()
	case concentrateprocess.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case concentrateprocess.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConcentrateProcessMutation) AddField(name string, value ent.Value) error {
	switch name {
	case concentrateprocess.FieldFormulaID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFormulaID(v)
		return nil
	case concentrateprocess.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case concentrateprocess.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case concentrateprocess.FieldIn:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIn(v)
		return nil
	case concentrateprocess.FieldInventory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInventory(v)
		return nil
	case concentrateprocess.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case concentrateprocess.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case concentrateprocess.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case concentrateprocess.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ConcentrateProcess numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConcentrateProcessMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConcentrateProcessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConcentrateProcessMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConcentrateProcess nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConcentrateProcessMutation) ResetField(name string) error {
	switch name {
	case concentrateprocess.FieldFormulaID:
		m.ResetFormulaID()
		return nil
	case concentrateprocess.FieldName:
		m.ResetName()
		return nil
	case concentrateprocess.FieldCode:
		m.ResetCode()
		return nil
	case concentrateprocess.FieldDate:
		m.ResetDate()
		return nil
	case concentrateprocess.FieldCount:
		m.ResetCount()
		return nil
	case concentrateprocess.FieldIn:
		m.ResetIn()
		return nil
	case concentrateprocess.FieldInventory:
		m.ResetInventory()
		return nil
	case concentrateprocess.FieldUserName:
		m.ResetUserName()
		return nil
	case concentrateprocess.FieldTenantId:
		m.ResetTenantId()
		return nil
	case concentrateprocess.FieldTenantName:
		m.ResetTenantName()
		return nil
	case concentrateprocess.FieldRemarks:
		m.ResetRemarks()
		return nil
	case concentrateprocess.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case concentrateprocess.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case concentrateprocess.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown ConcentrateProcess field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConcentrateProcessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConcentrateProcessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConcentrateProcessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConcentrateProcessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConcentrateProcessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConcentrateProcessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConcentrateProcessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConcentrateProcess unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConcentrateProcessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConcentrateProcess edge %s", name)
}

// ConfMutation represents an operation that mutate the Confs
// nodes in the graph.
type ConfMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	confs         **confs.Confs
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Conf, error)
}

var _ ent.Mutation = (*ConfMutation)(nil)

// confOption allows to manage the mutation configuration using functional options.
type confOption func(*ConfMutation)

// newConfMutation creates new mutation for $n.Name.
func newConfMutation(c config, op Op, opts ...confOption) *ConfMutation {
	m := &ConfMutation{
		config:        c,
		op:            op,
		typ:           TypeConf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfID sets the id field of the mutation.
func withConfID(id int64) confOption {
	return func(m *ConfMutation) {
		var (
			err   error
			once  sync.Once
			value *Conf
		)
		m.oldValue = func(ctx context.Context) (*Conf, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Conf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConf sets the old Conf of the mutation.
func withConf(node *Conf) confOption {
	return func(m *ConfMutation) {
		m.oldValue = func(context.Context) (*Conf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ConfMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetConfs sets the confs field.
func (m *ConfMutation) SetConfs(c *confs.Confs) {
	m.confs = &c
}

// Confs returns the confs value in the mutation.
func (m *ConfMutation) Confs() (r *confs.Confs, exists bool) {
	v := m.confs
	if v == nil {
		return
	}
	return *v, true
}

// OldConfs returns the old confs value of the Conf.
// If the Conf object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ConfMutation) OldConfs(ctx context.Context) (v *confs.Confs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConfs is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConfs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfs: %w", err)
	}
	return oldValue.Confs, nil
}

// ResetConfs reset all changes of the "confs" field.
func (m *ConfMutation) ResetConfs() {
	m.confs = nil
}

// Op returns the operation name.
func (m *ConfMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Conf).
func (m *ConfMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ConfMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.confs != nil {
		fields = append(fields, conf.FieldConfs)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ConfMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case conf.FieldConfs:
		return m.Confs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ConfMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case conf.FieldConfs:
		return m.OldConfs(ctx)
	}
	return nil, fmt.Errorf("unknown Conf field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfMutation) SetField(name string, value ent.Value) error {
	switch name {
	case conf.FieldConfs:
		v, ok := value.(*confs.Confs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfs(v)
		return nil
	}
	return fmt.Errorf("unknown Conf field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ConfMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ConfMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ConfMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Conf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ConfMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ConfMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Conf nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ConfMutation) ResetField(name string) error {
	switch name {
	case conf.FieldConfs:
		m.ResetConfs()
		return nil
	}
	return fmt.Errorf("unknown Conf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ConfMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ConfMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ConfMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ConfMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ConfMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ConfMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ConfMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Conf unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ConfMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Conf edge %s", name)
}

// CustomerMutation represents an operation that mutate the Customers
// nodes in the graph.
type CustomerMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	_type         *string
	gender        *string
	province      *string
	phone         *string
	address       *string
	email         *string
	bank          *string
	account       *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Customer, error)
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows to manage the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for $n.Name.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the id field of the mutation.
func withCustomerID(id int64) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CustomerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetType sets the type field.
func (m *CustomerMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *CustomerMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *CustomerMutation) ResetType() {
	m._type = nil
}

// SetGender sets the gender field.
func (m *CustomerMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the gender value in the mutation.
func (m *CustomerMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender reset all changes of the "gender" field.
func (m *CustomerMutation) ResetGender() {
	m.gender = nil
}

// SetProvince sets the province field.
func (m *CustomerMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the province value in the mutation.
func (m *CustomerMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old province value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince reset all changes of the "province" field.
func (m *CustomerMutation) ResetProvince() {
	m.province = nil
}

// SetPhone sets the phone field.
func (m *CustomerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *CustomerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *CustomerMutation) ResetPhone() {
	m.phone = nil
}

// SetAddress sets the address field.
func (m *CustomerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *CustomerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *CustomerMutation) ResetAddress() {
	m.address = nil
}

// SetEmail sets the email field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
}

// SetBank sets the bank field.
func (m *CustomerMutation) SetBank(s string) {
	m.bank = &s
}

// Bank returns the bank value in the mutation.
func (m *CustomerMutation) Bank() (r string, exists bool) {
	v := m.bank
	if v == nil {
		return
	}
	return *v, true
}

// OldBank returns the old bank value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldBank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBank is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBank: %w", err)
	}
	return oldValue.Bank, nil
}

// ResetBank reset all changes of the "bank" field.
func (m *CustomerMutation) ResetBank() {
	m.bank = nil
}

// SetAccount sets the account field.
func (m *CustomerMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the account value in the mutation.
func (m *CustomerMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old account value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount reset all changes of the "account" field.
func (m *CustomerMutation) ResetAccount() {
	m.account = nil
}

// SetTenantId sets the tenantId field.
func (m *CustomerMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *CustomerMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *CustomerMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *CustomerMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *CustomerMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *CustomerMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *CustomerMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *CustomerMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *CustomerMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *CustomerMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *CustomerMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *CustomerMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *CustomerMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *CustomerMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *CustomerMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *CustomerMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *CustomerMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *CustomerMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *CustomerMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *CustomerMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *CustomerMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Customer.
// If the Customer object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CustomerMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *CustomerMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *CustomerMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *CustomerMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m._type != nil {
		fields = append(fields, customer.FieldType)
	}
	if m.gender != nil {
		fields = append(fields, customer.FieldGender)
	}
	if m.province != nil {
		fields = append(fields, customer.FieldProvince)
	}
	if m.phone != nil {
		fields = append(fields, customer.FieldPhone)
	}
	if m.address != nil {
		fields = append(fields, customer.FieldAddress)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.bank != nil {
		fields = append(fields, customer.FieldBank)
	}
	if m.account != nil {
		fields = append(fields, customer.FieldAccount)
	}
	if m.tenantId != nil {
		fields = append(fields, customer.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, customer.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, customer.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, customer.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldName:
		return m.Name()
	case customer.FieldType:
		return m.GetType()
	case customer.FieldGender:
		return m.Gender()
	case customer.FieldProvince:
		return m.Province()
	case customer.FieldPhone:
		return m.Phone()
	case customer.FieldAddress:
		return m.Address()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldBank:
		return m.Bank()
	case customer.FieldAccount:
		return m.Account()
	case customer.FieldTenantId:
		return m.TenantId()
	case customer.FieldTenantName:
		return m.TenantName()
	case customer.FieldRemarks:
		return m.Remarks()
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldType:
		return m.OldType(ctx)
	case customer.FieldGender:
		return m.OldGender(ctx)
	case customer.FieldProvince:
		return m.OldProvince(ctx)
	case customer.FieldPhone:
		return m.OldPhone(ctx)
	case customer.FieldAddress:
		return m.OldAddress(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldBank:
		return m.OldBank(ctx)
	case customer.FieldAccount:
		return m.OldAccount(ctx)
	case customer.FieldTenantId:
		return m.OldTenantId(ctx)
	case customer.FieldTenantName:
		return m.OldTenantName(ctx)
	case customer.FieldRemarks:
		return m.OldRemarks(ctx)
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case customer.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case customer.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case customer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case customer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldBank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBank(v)
		return nil
	case customer.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case customer.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case customer.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case customer.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CustomerMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, customer.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, customer.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldTenantId:
		return m.AddedTenantId()
	case customer.FieldCreatedAt:
		return m.AddedCreatedAt()
	case customer.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case customer.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customer.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case customer.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldType:
		m.ResetType()
		return nil
	case customer.FieldGender:
		m.ResetGender()
		return nil
	case customer.FieldProvince:
		m.ResetProvince()
		return nil
	case customer.FieldPhone:
		m.ResetPhone()
		return nil
	case customer.FieldAddress:
		m.ResetAddress()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldBank:
		m.ResetBank()
		return nil
	case customer.FieldAccount:
		m.ResetAccount()
		return nil
	case customer.FieldTenantId:
		m.ResetTenantId()
		return nil
	case customer.FieldTenantName:
		m.ResetTenantName()
		return nil
	case customer.FieldRemarks:
		m.ResetRemarks()
		return nil
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Customer edge %s", name)
}

// DiseaseInfoMutation represents an operation that mutate the DiseaseInfos
// nodes in the graph.
type DiseaseInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	_type         *string
	description   *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DiseaseInfo, error)
}

var _ ent.Mutation = (*DiseaseInfoMutation)(nil)

// diseaseinfoOption allows to manage the mutation configuration using functional options.
type diseaseinfoOption func(*DiseaseInfoMutation)

// newDiseaseInfoMutation creates new mutation for $n.Name.
func newDiseaseInfoMutation(c config, op Op, opts ...diseaseinfoOption) *DiseaseInfoMutation {
	m := &DiseaseInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDiseaseInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiseaseInfoID sets the id field of the mutation.
func withDiseaseInfoID(id int64) diseaseinfoOption {
	return func(m *DiseaseInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DiseaseInfo
		)
		m.oldValue = func(ctx context.Context) (*DiseaseInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiseaseInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiseaseInfo sets the old DiseaseInfo of the mutation.
func withDiseaseInfo(node *DiseaseInfo) diseaseinfoOption {
	return func(m *DiseaseInfoMutation) {
		m.oldValue = func(context.Context) (*DiseaseInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiseaseInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiseaseInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DiseaseInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DiseaseInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DiseaseInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DiseaseInfoMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *DiseaseInfoMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *DiseaseInfoMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *DiseaseInfoMutation) ResetCode() {
	m.code = nil
}

// SetType sets the type field.
func (m *DiseaseInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *DiseaseInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of type.
func (m *DiseaseInfoMutation) ClearType() {
	m._type = nil
	m.clearedFields[diseaseinfo.FieldType] = struct{}{}
}

// TypeCleared returns if the field type was cleared in this mutation.
func (m *DiseaseInfoMutation) TypeCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldType]
	return ok
}

// ResetType reset all changes of the "type" field.
func (m *DiseaseInfoMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, diseaseinfo.FieldType)
}

// SetDescription sets the description field.
func (m *DiseaseInfoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *DiseaseInfoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *DiseaseInfoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[diseaseinfo.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *DiseaseInfoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *DiseaseInfoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, diseaseinfo.FieldDescription)
}

// SetTenantId sets the tenantId field.
func (m *DiseaseInfoMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *DiseaseInfoMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *DiseaseInfoMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *DiseaseInfoMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantId clears the value of tenantId.
func (m *DiseaseInfoMutation) ClearTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
	m.clearedFields[diseaseinfo.FieldTenantId] = struct{}{}
}

// TenantIdCleared returns if the field tenantId was cleared in this mutation.
func (m *DiseaseInfoMutation) TenantIdCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldTenantId]
	return ok
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *DiseaseInfoMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
	delete(m.clearedFields, diseaseinfo.FieldTenantId)
}

// SetTenantName sets the tenantName field.
func (m *DiseaseInfoMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *DiseaseInfoMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ClearTenantName clears the value of tenantName.
func (m *DiseaseInfoMutation) ClearTenantName() {
	m.tenantName = nil
	m.clearedFields[diseaseinfo.FieldTenantName] = struct{}{}
}

// TenantNameCleared returns if the field tenantName was cleared in this mutation.
func (m *DiseaseInfoMutation) TenantNameCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldTenantName]
	return ok
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *DiseaseInfoMutation) ResetTenantName() {
	m.tenantName = nil
	delete(m.clearedFields, diseaseinfo.FieldTenantName)
}

// SetRemarks sets the remarks field.
func (m *DiseaseInfoMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *DiseaseInfoMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of remarks.
func (m *DiseaseInfoMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[diseaseinfo.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the field remarks was cleared in this mutation.
func (m *DiseaseInfoMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldRemarks]
	return ok
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *DiseaseInfoMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, diseaseinfo.FieldRemarks)
}

// SetCreatedAt sets the createdAt field.
func (m *DiseaseInfoMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *DiseaseInfoMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *DiseaseInfoMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *DiseaseInfoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of createdAt.
func (m *DiseaseInfoMutation) ClearCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
	m.clearedFields[diseaseinfo.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field createdAt was cleared in this mutation.
func (m *DiseaseInfoMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *DiseaseInfoMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
	delete(m.clearedFields, diseaseinfo.FieldCreatedAt)
}

// SetUpdatedAt sets the updatedAt field.
func (m *DiseaseInfoMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *DiseaseInfoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *DiseaseInfoMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *DiseaseInfoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of updatedAt.
func (m *DiseaseInfoMutation) ClearUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
	m.clearedFields[diseaseinfo.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updatedAt was cleared in this mutation.
func (m *DiseaseInfoMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *DiseaseInfoMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
	delete(m.clearedFields, diseaseinfo.FieldUpdatedAt)
}

// SetDeleted sets the deleted field.
func (m *DiseaseInfoMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *DiseaseInfoMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the DiseaseInfo.
// If the DiseaseInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseInfoMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *DiseaseInfoMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *DiseaseInfoMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleted clears the value of deleted.
func (m *DiseaseInfoMutation) ClearDeleted() {
	m.deleted = nil
	m.adddeleted = nil
	m.clearedFields[diseaseinfo.FieldDeleted] = struct{}{}
}

// DeletedCleared returns if the field deleted was cleared in this mutation.
func (m *DiseaseInfoMutation) DeletedCleared() bool {
	_, ok := m.clearedFields[diseaseinfo.FieldDeleted]
	return ok
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *DiseaseInfoMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
	delete(m.clearedFields, diseaseinfo.FieldDeleted)
}

// Op returns the operation name.
func (m *DiseaseInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DiseaseInfo).
func (m *DiseaseInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DiseaseInfoMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, diseaseinfo.FieldName)
	}
	if m.code != nil {
		fields = append(fields, diseaseinfo.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, diseaseinfo.FieldType)
	}
	if m.description != nil {
		fields = append(fields, diseaseinfo.FieldDescription)
	}
	if m.tenantId != nil {
		fields = append(fields, diseaseinfo.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, diseaseinfo.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, diseaseinfo.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, diseaseinfo.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, diseaseinfo.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, diseaseinfo.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DiseaseInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case diseaseinfo.FieldName:
		return m.Name()
	case diseaseinfo.FieldCode:
		return m.Code()
	case diseaseinfo.FieldType:
		return m.GetType()
	case diseaseinfo.FieldDescription:
		return m.Description()
	case diseaseinfo.FieldTenantId:
		return m.TenantId()
	case diseaseinfo.FieldTenantName:
		return m.TenantName()
	case diseaseinfo.FieldRemarks:
		return m.Remarks()
	case diseaseinfo.FieldCreatedAt:
		return m.CreatedAt()
	case diseaseinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case diseaseinfo.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DiseaseInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case diseaseinfo.FieldName:
		return m.OldName(ctx)
	case diseaseinfo.FieldCode:
		return m.OldCode(ctx)
	case diseaseinfo.FieldType:
		return m.OldType(ctx)
	case diseaseinfo.FieldDescription:
		return m.OldDescription(ctx)
	case diseaseinfo.FieldTenantId:
		return m.OldTenantId(ctx)
	case diseaseinfo.FieldTenantName:
		return m.OldTenantName(ctx)
	case diseaseinfo.FieldRemarks:
		return m.OldRemarks(ctx)
	case diseaseinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case diseaseinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case diseaseinfo.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown DiseaseInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case diseaseinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case diseaseinfo.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case diseaseinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case diseaseinfo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case diseaseinfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case diseaseinfo.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case diseaseinfo.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case diseaseinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case diseaseinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case diseaseinfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown DiseaseInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DiseaseInfoMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, diseaseinfo.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, diseaseinfo.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, diseaseinfo.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, diseaseinfo.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DiseaseInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case diseaseinfo.FieldTenantId:
		return m.AddedTenantId()
	case diseaseinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case diseaseinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case diseaseinfo.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case diseaseinfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case diseaseinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case diseaseinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case diseaseinfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown DiseaseInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DiseaseInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(diseaseinfo.FieldType) {
		fields = append(fields, diseaseinfo.FieldType)
	}
	if m.FieldCleared(diseaseinfo.FieldDescription) {
		fields = append(fields, diseaseinfo.FieldDescription)
	}
	if m.FieldCleared(diseaseinfo.FieldTenantId) {
		fields = append(fields, diseaseinfo.FieldTenantId)
	}
	if m.FieldCleared(diseaseinfo.FieldTenantName) {
		fields = append(fields, diseaseinfo.FieldTenantName)
	}
	if m.FieldCleared(diseaseinfo.FieldRemarks) {
		fields = append(fields, diseaseinfo.FieldRemarks)
	}
	if m.FieldCleared(diseaseinfo.FieldCreatedAt) {
		fields = append(fields, diseaseinfo.FieldCreatedAt)
	}
	if m.FieldCleared(diseaseinfo.FieldUpdatedAt) {
		fields = append(fields, diseaseinfo.FieldUpdatedAt)
	}
	if m.FieldCleared(diseaseinfo.FieldDeleted) {
		fields = append(fields, diseaseinfo.FieldDeleted)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DiseaseInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiseaseInfoMutation) ClearField(name string) error {
	switch name {
	case diseaseinfo.FieldType:
		m.ClearType()
		return nil
	case diseaseinfo.FieldDescription:
		m.ClearDescription()
		return nil
	case diseaseinfo.FieldTenantId:
		m.ClearTenantId()
		return nil
	case diseaseinfo.FieldTenantName:
		m.ClearTenantName()
		return nil
	case diseaseinfo.FieldRemarks:
		m.ClearRemarks()
		return nil
	case diseaseinfo.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case diseaseinfo.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case diseaseinfo.FieldDeleted:
		m.ClearDeleted()
		return nil
	}
	return fmt.Errorf("unknown DiseaseInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DiseaseInfoMutation) ResetField(name string) error {
	switch name {
	case diseaseinfo.FieldName:
		m.ResetName()
		return nil
	case diseaseinfo.FieldCode:
		m.ResetCode()
		return nil
	case diseaseinfo.FieldType:
		m.ResetType()
		return nil
	case diseaseinfo.FieldDescription:
		m.ResetDescription()
		return nil
	case diseaseinfo.FieldTenantId:
		m.ResetTenantId()
		return nil
	case diseaseinfo.FieldTenantName:
		m.ResetTenantName()
		return nil
	case diseaseinfo.FieldRemarks:
		m.ResetRemarks()
		return nil
	case diseaseinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case diseaseinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case diseaseinfo.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown DiseaseInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DiseaseInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DiseaseInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DiseaseInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DiseaseInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DiseaseInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DiseaseInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DiseaseInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DiseaseInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DiseaseInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DiseaseInfo edge %s", name)
}

// DisinfectMutation represents an operation that mutate the Disinfects
// nodes in the graph.
type DisinfectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	cattleId      *int64
	addcattleId   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	shedId        *int64
	addshedId     *int64
	shedName      *string
	name          *string
	date          *int64
	adddate       *int64
	typeId        *int
	addtypeId     *int
	typeName      *string
	methodId      *int
	addmethodId   *int
	methodName    *string
	wayId         *int
	addwayId      *int
	wayName       *string
	drug          *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Disinfect, error)
}

var _ ent.Mutation = (*DisinfectMutation)(nil)

// disinfectOption allows to manage the mutation configuration using functional options.
type disinfectOption func(*DisinfectMutation)

// newDisinfectMutation creates new mutation for $n.Name.
func newDisinfectMutation(c config, op Op, opts ...disinfectOption) *DisinfectMutation {
	m := &DisinfectMutation{
		config:        c,
		op:            op,
		typ:           TypeDisinfect,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDisinfectID sets the id field of the mutation.
func withDisinfectID(id int64) disinfectOption {
	return func(m *DisinfectMutation) {
		var (
			err   error
			once  sync.Once
			value *Disinfect
		)
		m.oldValue = func(ctx context.Context) (*Disinfect, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disinfect.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisinfect sets the old Disinfect of the mutation.
func withDisinfect(node *Disinfect) disinfectOption {
	return func(m *DisinfectMutation) {
		m.oldValue = func(context.Context) (*Disinfect, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DisinfectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DisinfectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DisinfectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *DisinfectMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *DisinfectMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *DisinfectMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *DisinfectMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *DisinfectMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *DisinfectMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *DisinfectMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *DisinfectMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *DisinfectMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *DisinfectMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *DisinfectMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *DisinfectMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *DisinfectMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *DisinfectMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *DisinfectMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *DisinfectMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *DisinfectMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *DisinfectMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *DisinfectMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *DisinfectMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *DisinfectMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *DisinfectMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *DisinfectMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *DisinfectMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *DisinfectMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *DisinfectMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *DisinfectMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *DisinfectMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *DisinfectMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *DisinfectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DisinfectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DisinfectMutation) ResetName() {
	m.name = nil
}

// SetDate sets the date field.
func (m *DisinfectMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *DisinfectMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *DisinfectMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *DisinfectMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *DisinfectMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetTypeId sets the typeId field.
func (m *DisinfectMutation) SetTypeId(i int) {
	m.typeId = &i
	m.addtypeId = nil
}

// TypeId returns the typeId value in the mutation.
func (m *DisinfectMutation) TypeId() (r int, exists bool) {
	v := m.typeId
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeId returns the old typeId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeId: %w", err)
	}
	return oldValue.TypeId, nil
}

// AddTypeId adds i to typeId.
func (m *DisinfectMutation) AddTypeId(i int) {
	if m.addtypeId != nil {
		*m.addtypeId += i
	} else {
		m.addtypeId = &i
	}
}

// AddedTypeId returns the value that was added to the typeId field in this mutation.
func (m *DisinfectMutation) AddedTypeId() (r int, exists bool) {
	v := m.addtypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTypeId reset all changes of the "typeId" field.
func (m *DisinfectMutation) ResetTypeId() {
	m.typeId = nil
	m.addtypeId = nil
}

// SetTypeName sets the typeName field.
func (m *DisinfectMutation) SetTypeName(s string) {
	m.typeName = &s
}

// TypeName returns the typeName value in the mutation.
func (m *DisinfectMutation) TypeName() (r string, exists bool) {
	v := m.typeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old typeName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName reset all changes of the "typeName" field.
func (m *DisinfectMutation) ResetTypeName() {
	m.typeName = nil
}

// SetMethodId sets the methodId field.
func (m *DisinfectMutation) SetMethodId(i int) {
	m.methodId = &i
	m.addmethodId = nil
}

// MethodId returns the methodId value in the mutation.
func (m *DisinfectMutation) MethodId() (r int, exists bool) {
	v := m.methodId
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodId returns the old methodId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldMethodId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodId: %w", err)
	}
	return oldValue.MethodId, nil
}

// AddMethodId adds i to methodId.
func (m *DisinfectMutation) AddMethodId(i int) {
	if m.addmethodId != nil {
		*m.addmethodId += i
	} else {
		m.addmethodId = &i
	}
}

// AddedMethodId returns the value that was added to the methodId field in this mutation.
func (m *DisinfectMutation) AddedMethodId() (r int, exists bool) {
	v := m.addmethodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetMethodId reset all changes of the "methodId" field.
func (m *DisinfectMutation) ResetMethodId() {
	m.methodId = nil
	m.addmethodId = nil
}

// SetMethodName sets the methodName field.
func (m *DisinfectMutation) SetMethodName(s string) {
	m.methodName = &s
}

// MethodName returns the methodName value in the mutation.
func (m *DisinfectMutation) MethodName() (r string, exists bool) {
	v := m.methodName
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodName returns the old methodName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodName: %w", err)
	}
	return oldValue.MethodName, nil
}

// ResetMethodName reset all changes of the "methodName" field.
func (m *DisinfectMutation) ResetMethodName() {
	m.methodName = nil
}

// SetWayId sets the wayId field.
func (m *DisinfectMutation) SetWayId(i int) {
	m.wayId = &i
	m.addwayId = nil
}

// WayId returns the wayId value in the mutation.
func (m *DisinfectMutation) WayId() (r int, exists bool) {
	v := m.wayId
	if v == nil {
		return
	}
	return *v, true
}

// OldWayId returns the old wayId value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldWayId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWayId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWayId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWayId: %w", err)
	}
	return oldValue.WayId, nil
}

// AddWayId adds i to wayId.
func (m *DisinfectMutation) AddWayId(i int) {
	if m.addwayId != nil {
		*m.addwayId += i
	} else {
		m.addwayId = &i
	}
}

// AddedWayId returns the value that was added to the wayId field in this mutation.
func (m *DisinfectMutation) AddedWayId() (r int, exists bool) {
	v := m.addwayId
	if v == nil {
		return
	}
	return *v, true
}

// ResetWayId reset all changes of the "wayId" field.
func (m *DisinfectMutation) ResetWayId() {
	m.wayId = nil
	m.addwayId = nil
}

// SetWayName sets the wayName field.
func (m *DisinfectMutation) SetWayName(s string) {
	m.wayName = &s
}

// WayName returns the wayName value in the mutation.
func (m *DisinfectMutation) WayName() (r string, exists bool) {
	v := m.wayName
	if v == nil {
		return
	}
	return *v, true
}

// OldWayName returns the old wayName value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldWayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWayName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWayName: %w", err)
	}
	return oldValue.WayName, nil
}

// ResetWayName reset all changes of the "wayName" field.
func (m *DisinfectMutation) ResetWayName() {
	m.wayName = nil
}

// SetDrug sets the drug field.
func (m *DisinfectMutation) SetDrug(s string) {
	m.drug = &s
}

// Drug returns the drug value in the mutation.
func (m *DisinfectMutation) Drug() (r string, exists bool) {
	v := m.drug
	if v == nil {
		return
	}
	return *v, true
}

// OldDrug returns the old drug value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldDrug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDrug is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDrug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrug: %w", err)
	}
	return oldValue.Drug, nil
}

// ResetDrug reset all changes of the "drug" field.
func (m *DisinfectMutation) ResetDrug() {
	m.drug = nil
}

// SetRemarks sets the remarks field.
func (m *DisinfectMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *DisinfectMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *DisinfectMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *DisinfectMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *DisinfectMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *DisinfectMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *DisinfectMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *DisinfectMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *DisinfectMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *DisinfectMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *DisinfectMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *DisinfectMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *DisinfectMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *DisinfectMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *DisinfectMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Disinfect.
// If the Disinfect object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DisinfectMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *DisinfectMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *DisinfectMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *DisinfectMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *DisinfectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disinfect).
func (m *DisinfectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DisinfectMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.cattleId != nil {
		fields = append(fields, disinfect.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, disinfect.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, disinfect.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, disinfect.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, disinfect.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, disinfect.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, disinfect.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, disinfect.FieldName)
	}
	if m.date != nil {
		fields = append(fields, disinfect.FieldDate)
	}
	if m.typeId != nil {
		fields = append(fields, disinfect.FieldTypeId)
	}
	if m.typeName != nil {
		fields = append(fields, disinfect.FieldTypeName)
	}
	if m.methodId != nil {
		fields = append(fields, disinfect.FieldMethodId)
	}
	if m.methodName != nil {
		fields = append(fields, disinfect.FieldMethodName)
	}
	if m.wayId != nil {
		fields = append(fields, disinfect.FieldWayId)
	}
	if m.wayName != nil {
		fields = append(fields, disinfect.FieldWayName)
	}
	if m.drug != nil {
		fields = append(fields, disinfect.FieldDrug)
	}
	if m.remarks != nil {
		fields = append(fields, disinfect.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, disinfect.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, disinfect.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, disinfect.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DisinfectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disinfect.FieldCattleId:
		return m.CattleId()
	case disinfect.FieldTenantId:
		return m.TenantId()
	case disinfect.FieldTenantName:
		return m.TenantName()
	case disinfect.FieldFarmId:
		return m.FarmId()
	case disinfect.FieldFarmName:
		return m.FarmName()
	case disinfect.FieldShedId:
		return m.ShedId()
	case disinfect.FieldShedName:
		return m.ShedName()
	case disinfect.FieldName:
		return m.Name()
	case disinfect.FieldDate:
		return m.Date()
	case disinfect.FieldTypeId:
		return m.TypeId()
	case disinfect.FieldTypeName:
		return m.TypeName()
	case disinfect.FieldMethodId:
		return m.MethodId()
	case disinfect.FieldMethodName:
		return m.MethodName()
	case disinfect.FieldWayId:
		return m.WayId()
	case disinfect.FieldWayName:
		return m.WayName()
	case disinfect.FieldDrug:
		return m.Drug()
	case disinfect.FieldRemarks:
		return m.Remarks()
	case disinfect.FieldCreatedAt:
		return m.CreatedAt()
	case disinfect.FieldUpdatedAt:
		return m.UpdatedAt()
	case disinfect.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DisinfectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disinfect.FieldCattleId:
		return m.OldCattleId(ctx)
	case disinfect.FieldTenantId:
		return m.OldTenantId(ctx)
	case disinfect.FieldTenantName:
		return m.OldTenantName(ctx)
	case disinfect.FieldFarmId:
		return m.OldFarmId(ctx)
	case disinfect.FieldFarmName:
		return m.OldFarmName(ctx)
	case disinfect.FieldShedId:
		return m.OldShedId(ctx)
	case disinfect.FieldShedName:
		return m.OldShedName(ctx)
	case disinfect.FieldName:
		return m.OldName(ctx)
	case disinfect.FieldDate:
		return m.OldDate(ctx)
	case disinfect.FieldTypeId:
		return m.OldTypeId(ctx)
	case disinfect.FieldTypeName:
		return m.OldTypeName(ctx)
	case disinfect.FieldMethodId:
		return m.OldMethodId(ctx)
	case disinfect.FieldMethodName:
		return m.OldMethodName(ctx)
	case disinfect.FieldWayId:
		return m.OldWayId(ctx)
	case disinfect.FieldWayName:
		return m.OldWayName(ctx)
	case disinfect.FieldDrug:
		return m.OldDrug(ctx)
	case disinfect.FieldRemarks:
		return m.OldRemarks(ctx)
	case disinfect.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case disinfect.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case disinfect.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Disinfect field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DisinfectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disinfect.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case disinfect.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case disinfect.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case disinfect.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case disinfect.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case disinfect.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case disinfect.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case disinfect.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case disinfect.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case disinfect.FieldTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeId(v)
		return nil
	case disinfect.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case disinfect.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodId(v)
		return nil
	case disinfect.FieldMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodName(v)
		return nil
	case disinfect.FieldWayId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWayId(v)
		return nil
	case disinfect.FieldWayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWayName(v)
		return nil
	case disinfect.FieldDrug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrug(v)
		return nil
	case disinfect.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case disinfect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case disinfect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case disinfect.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Disinfect field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DisinfectMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, disinfect.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, disinfect.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, disinfect.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, disinfect.FieldShedId)
	}
	if m.adddate != nil {
		fields = append(fields, disinfect.FieldDate)
	}
	if m.addtypeId != nil {
		fields = append(fields, disinfect.FieldTypeId)
	}
	if m.addmethodId != nil {
		fields = append(fields, disinfect.FieldMethodId)
	}
	if m.addwayId != nil {
		fields = append(fields, disinfect.FieldWayId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, disinfect.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, disinfect.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, disinfect.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DisinfectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case disinfect.FieldCattleId:
		return m.AddedCattleId()
	case disinfect.FieldTenantId:
		return m.AddedTenantId()
	case disinfect.FieldFarmId:
		return m.AddedFarmId()
	case disinfect.FieldShedId:
		return m.AddedShedId()
	case disinfect.FieldDate:
		return m.AddedDate()
	case disinfect.FieldTypeId:
		return m.AddedTypeId()
	case disinfect.FieldMethodId:
		return m.AddedMethodId()
	case disinfect.FieldWayId:
		return m.AddedWayId()
	case disinfect.FieldCreatedAt:
		return m.AddedCreatedAt()
	case disinfect.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case disinfect.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DisinfectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case disinfect.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case disinfect.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case disinfect.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case disinfect.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case disinfect.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case disinfect.FieldTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeId(v)
		return nil
	case disinfect.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethodId(v)
		return nil
	case disinfect.FieldWayId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWayId(v)
		return nil
	case disinfect.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case disinfect.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case disinfect.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Disinfect numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DisinfectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DisinfectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DisinfectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disinfect nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DisinfectMutation) ResetField(name string) error {
	switch name {
	case disinfect.FieldCattleId:
		m.ResetCattleId()
		return nil
	case disinfect.FieldTenantId:
		m.ResetTenantId()
		return nil
	case disinfect.FieldTenantName:
		m.ResetTenantName()
		return nil
	case disinfect.FieldFarmId:
		m.ResetFarmId()
		return nil
	case disinfect.FieldFarmName:
		m.ResetFarmName()
		return nil
	case disinfect.FieldShedId:
		m.ResetShedId()
		return nil
	case disinfect.FieldShedName:
		m.ResetShedName()
		return nil
	case disinfect.FieldName:
		m.ResetName()
		return nil
	case disinfect.FieldDate:
		m.ResetDate()
		return nil
	case disinfect.FieldTypeId:
		m.ResetTypeId()
		return nil
	case disinfect.FieldTypeName:
		m.ResetTypeName()
		return nil
	case disinfect.FieldMethodId:
		m.ResetMethodId()
		return nil
	case disinfect.FieldMethodName:
		m.ResetMethodName()
		return nil
	case disinfect.FieldWayId:
		m.ResetWayId()
		return nil
	case disinfect.FieldWayName:
		m.ResetWayName()
		return nil
	case disinfect.FieldDrug:
		m.ResetDrug()
		return nil
	case disinfect.FieldRemarks:
		m.ResetRemarks()
		return nil
	case disinfect.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case disinfect.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case disinfect.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Disinfect field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DisinfectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DisinfectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DisinfectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DisinfectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DisinfectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DisinfectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DisinfectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Disinfect unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DisinfectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Disinfect edge %s", name)
}

// DispenceMutation represents an operation that mutate the Dispences
// nodes in the graph.
type DispenceMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Dispence, error)
}

var _ ent.Mutation = (*DispenceMutation)(nil)

// dispenceOption allows to manage the mutation configuration using functional options.
type dispenceOption func(*DispenceMutation)

// newDispenceMutation creates new mutation for $n.Name.
func newDispenceMutation(c config, op Op, opts ...dispenceOption) *DispenceMutation {
	m := &DispenceMutation{
		config:        c,
		op:            op,
		typ:           TypeDispence,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDispenceID sets the id field of the mutation.
func withDispenceID(id int64) dispenceOption {
	return func(m *DispenceMutation) {
		var (
			err   error
			once  sync.Once
			value *Dispence
		)
		m.oldValue = func(ctx context.Context) (*Dispence, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dispence.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDispence sets the old Dispence of the mutation.
func withDispence(node *Dispence) dispenceOption {
	return func(m *DispenceMutation) {
		m.oldValue = func(context.Context) (*Dispence, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DispenceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DispenceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DispenceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *DispenceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dispence).
func (m *DispenceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DispenceMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DispenceMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DispenceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Dispence field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DispenceMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dispence field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DispenceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DispenceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DispenceMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Dispence numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DispenceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DispenceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DispenceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dispence nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DispenceMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Dispence field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DispenceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DispenceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DispenceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DispenceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DispenceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DispenceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DispenceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Dispence unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DispenceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Dispence edge %s", name)
}

// DutyMutation represents an operation that mutate the Duties
// nodes in the graph.
type DutyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Duty, error)
}

var _ ent.Mutation = (*DutyMutation)(nil)

// dutyOption allows to manage the mutation configuration using functional options.
type dutyOption func(*DutyMutation)

// newDutyMutation creates new mutation for $n.Name.
func newDutyMutation(c config, op Op, opts ...dutyOption) *DutyMutation {
	m := &DutyMutation{
		config:        c,
		op:            op,
		typ:           TypeDuty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDutyID sets the id field of the mutation.
func withDutyID(id int64) dutyOption {
	return func(m *DutyMutation) {
		var (
			err   error
			once  sync.Once
			value *Duty
		)
		m.oldValue = func(ctx context.Context) (*Duty, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Duty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDuty sets the old Duty of the mutation.
func withDuty(node *Duty) dutyOption {
	return func(m *DutyMutation) {
		m.oldValue = func(context.Context) (*Duty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DutyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DutyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DutyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *DutyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DutyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Duty.
// If the Duty object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DutyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DutyMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *DutyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Duty).
func (m *DutyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DutyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, duty.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DutyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case duty.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DutyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case duty.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Duty field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DutyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case duty.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Duty field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DutyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DutyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DutyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Duty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DutyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DutyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DutyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Duty nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DutyMutation) ResetField(name string) error {
	switch name {
	case duty.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Duty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DutyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DutyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DutyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DutyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DutyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DutyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DutyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Duty unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DutyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Duty edge %s", name)
}

// EpidemicMutation represents an operation that mutate the Epidemics
// nodes in the graph.
type EpidemicMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	cattleId             *int64
	addcattleId          *int64
	tenantId             *int64
	addtenantId          *int64
	tenantName           *string
	farmId               *int64
	addfarmId            *int64
	farmName             *string
	shedId               *int64
	addshedId            *int64
	shedName             *string
	name                 *string
	earNumber            *string
	onset                *int64
	addonset             *int64
	epidemicTypeId       *int
	addepidemicTypeId    *int
	epidemicTypeName     *string
	isolatedShedName     *string
	diagedBy             *string
	treatmentResultId    *int
	addtreatmentResultId *int
	treatmentResultName  *string
	treatmentState       *string
	treatmentAt          *int64
	addtreatmentAt       *int64
	whereabout           *string
	remarks              *string
	createdAt            *int64
	addcreatedAt         *int64
	updatedAt            *int64
	addupdatedAt         *int64
	deleted              *int
	adddeleted           *int
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Epidemic, error)
}

var _ ent.Mutation = (*EpidemicMutation)(nil)

// epidemicOption allows to manage the mutation configuration using functional options.
type epidemicOption func(*EpidemicMutation)

// newEpidemicMutation creates new mutation for $n.Name.
func newEpidemicMutation(c config, op Op, opts ...epidemicOption) *EpidemicMutation {
	m := &EpidemicMutation{
		config:        c,
		op:            op,
		typ:           TypeEpidemic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpidemicID sets the id field of the mutation.
func withEpidemicID(id int64) epidemicOption {
	return func(m *EpidemicMutation) {
		var (
			err   error
			once  sync.Once
			value *Epidemic
		)
		m.oldValue = func(ctx context.Context) (*Epidemic, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Epidemic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpidemic sets the old Epidemic of the mutation.
func withEpidemic(node *Epidemic) epidemicOption {
	return func(m *EpidemicMutation) {
		m.oldValue = func(context.Context) (*Epidemic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpidemicMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpidemicMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EpidemicMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *EpidemicMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *EpidemicMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *EpidemicMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *EpidemicMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *EpidemicMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *EpidemicMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *EpidemicMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *EpidemicMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *EpidemicMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *EpidemicMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *EpidemicMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *EpidemicMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *EpidemicMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *EpidemicMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *EpidemicMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *EpidemicMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *EpidemicMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *EpidemicMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *EpidemicMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *EpidemicMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *EpidemicMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *EpidemicMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *EpidemicMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *EpidemicMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *EpidemicMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *EpidemicMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *EpidemicMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *EpidemicMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *EpidemicMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *EpidemicMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EpidemicMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EpidemicMutation) ResetName() {
	m.name = nil
}

// SetEarNumber sets the earNumber field.
func (m *EpidemicMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *EpidemicMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *EpidemicMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetOnset sets the onset field.
func (m *EpidemicMutation) SetOnset(i int64) {
	m.onset = &i
	m.addonset = nil
}

// Onset returns the onset value in the mutation.
func (m *EpidemicMutation) Onset() (r int64, exists bool) {
	v := m.onset
	if v == nil {
		return
	}
	return *v, true
}

// OldOnset returns the old onset value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldOnset(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnset is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnset requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnset: %w", err)
	}
	return oldValue.Onset, nil
}

// AddOnset adds i to onset.
func (m *EpidemicMutation) AddOnset(i int64) {
	if m.addonset != nil {
		*m.addonset += i
	} else {
		m.addonset = &i
	}
}

// AddedOnset returns the value that was added to the onset field in this mutation.
func (m *EpidemicMutation) AddedOnset() (r int64, exists bool) {
	v := m.addonset
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnset reset all changes of the "onset" field.
func (m *EpidemicMutation) ResetOnset() {
	m.onset = nil
	m.addonset = nil
}

// SetEpidemicTypeId sets the epidemicTypeId field.
func (m *EpidemicMutation) SetEpidemicTypeId(i int) {
	m.epidemicTypeId = &i
	m.addepidemicTypeId = nil
}

// EpidemicTypeId returns the epidemicTypeId value in the mutation.
func (m *EpidemicMutation) EpidemicTypeId() (r int, exists bool) {
	v := m.epidemicTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldEpidemicTypeId returns the old epidemicTypeId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldEpidemicTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEpidemicTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEpidemicTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpidemicTypeId: %w", err)
	}
	return oldValue.EpidemicTypeId, nil
}

// AddEpidemicTypeId adds i to epidemicTypeId.
func (m *EpidemicMutation) AddEpidemicTypeId(i int) {
	if m.addepidemicTypeId != nil {
		*m.addepidemicTypeId += i
	} else {
		m.addepidemicTypeId = &i
	}
}

// AddedEpidemicTypeId returns the value that was added to the epidemicTypeId field in this mutation.
func (m *EpidemicMutation) AddedEpidemicTypeId() (r int, exists bool) {
	v := m.addepidemicTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpidemicTypeId reset all changes of the "epidemicTypeId" field.
func (m *EpidemicMutation) ResetEpidemicTypeId() {
	m.epidemicTypeId = nil
	m.addepidemicTypeId = nil
}

// SetEpidemicTypeName sets the epidemicTypeName field.
func (m *EpidemicMutation) SetEpidemicTypeName(s string) {
	m.epidemicTypeName = &s
}

// EpidemicTypeName returns the epidemicTypeName value in the mutation.
func (m *EpidemicMutation) EpidemicTypeName() (r string, exists bool) {
	v := m.epidemicTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEpidemicTypeName returns the old epidemicTypeName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldEpidemicTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEpidemicTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEpidemicTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpidemicTypeName: %w", err)
	}
	return oldValue.EpidemicTypeName, nil
}

// ResetEpidemicTypeName reset all changes of the "epidemicTypeName" field.
func (m *EpidemicMutation) ResetEpidemicTypeName() {
	m.epidemicTypeName = nil
}

// SetIsolatedShedName sets the isolatedShedName field.
func (m *EpidemicMutation) SetIsolatedShedName(s string) {
	m.isolatedShedName = &s
}

// IsolatedShedName returns the isolatedShedName value in the mutation.
func (m *EpidemicMutation) IsolatedShedName() (r string, exists bool) {
	v := m.isolatedShedName
	if v == nil {
		return
	}
	return *v, true
}

// OldIsolatedShedName returns the old isolatedShedName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldIsolatedShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsolatedShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsolatedShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsolatedShedName: %w", err)
	}
	return oldValue.IsolatedShedName, nil
}

// ResetIsolatedShedName reset all changes of the "isolatedShedName" field.
func (m *EpidemicMutation) ResetIsolatedShedName() {
	m.isolatedShedName = nil
}

// SetDiagedBy sets the diagedBy field.
func (m *EpidemicMutation) SetDiagedBy(s string) {
	m.diagedBy = &s
}

// DiagedBy returns the diagedBy value in the mutation.
func (m *EpidemicMutation) DiagedBy() (r string, exists bool) {
	v := m.diagedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldDiagedBy returns the old diagedBy value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldDiagedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiagedBy is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiagedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiagedBy: %w", err)
	}
	return oldValue.DiagedBy, nil
}

// ResetDiagedBy reset all changes of the "diagedBy" field.
func (m *EpidemicMutation) ResetDiagedBy() {
	m.diagedBy = nil
}

// SetTreatmentResultId sets the treatmentResultId field.
func (m *EpidemicMutation) SetTreatmentResultId(i int) {
	m.treatmentResultId = &i
	m.addtreatmentResultId = nil
}

// TreatmentResultId returns the treatmentResultId value in the mutation.
func (m *EpidemicMutation) TreatmentResultId() (r int, exists bool) {
	v := m.treatmentResultId
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentResultId returns the old treatmentResultId value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTreatmentResultId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatmentResultId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatmentResultId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentResultId: %w", err)
	}
	return oldValue.TreatmentResultId, nil
}

// AddTreatmentResultId adds i to treatmentResultId.
func (m *EpidemicMutation) AddTreatmentResultId(i int) {
	if m.addtreatmentResultId != nil {
		*m.addtreatmentResultId += i
	} else {
		m.addtreatmentResultId = &i
	}
}

// AddedTreatmentResultId returns the value that was added to the treatmentResultId field in this mutation.
func (m *EpidemicMutation) AddedTreatmentResultId() (r int, exists bool) {
	v := m.addtreatmentResultId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTreatmentResultId reset all changes of the "treatmentResultId" field.
func (m *EpidemicMutation) ResetTreatmentResultId() {
	m.treatmentResultId = nil
	m.addtreatmentResultId = nil
}

// SetTreatmentResultName sets the treatmentResultName field.
func (m *EpidemicMutation) SetTreatmentResultName(s string) {
	m.treatmentResultName = &s
}

// TreatmentResultName returns the treatmentResultName value in the mutation.
func (m *EpidemicMutation) TreatmentResultName() (r string, exists bool) {
	v := m.treatmentResultName
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentResultName returns the old treatmentResultName value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTreatmentResultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatmentResultName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatmentResultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentResultName: %w", err)
	}
	return oldValue.TreatmentResultName, nil
}

// ResetTreatmentResultName reset all changes of the "treatmentResultName" field.
func (m *EpidemicMutation) ResetTreatmentResultName() {
	m.treatmentResultName = nil
}

// SetTreatmentState sets the treatmentState field.
func (m *EpidemicMutation) SetTreatmentState(s string) {
	m.treatmentState = &s
}

// TreatmentState returns the treatmentState value in the mutation.
func (m *EpidemicMutation) TreatmentState() (r string, exists bool) {
	v := m.treatmentState
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentState returns the old treatmentState value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTreatmentState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatmentState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatmentState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentState: %w", err)
	}
	return oldValue.TreatmentState, nil
}

// ResetTreatmentState reset all changes of the "treatmentState" field.
func (m *EpidemicMutation) ResetTreatmentState() {
	m.treatmentState = nil
}

// SetTreatmentAt sets the treatmentAt field.
func (m *EpidemicMutation) SetTreatmentAt(i int64) {
	m.treatmentAt = &i
	m.addtreatmentAt = nil
}

// TreatmentAt returns the treatmentAt value in the mutation.
func (m *EpidemicMutation) TreatmentAt() (r int64, exists bool) {
	v := m.treatmentAt
	if v == nil {
		return
	}
	return *v, true
}

// OldTreatmentAt returns the old treatmentAt value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldTreatmentAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTreatmentAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTreatmentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTreatmentAt: %w", err)
	}
	return oldValue.TreatmentAt, nil
}

// AddTreatmentAt adds i to treatmentAt.
func (m *EpidemicMutation) AddTreatmentAt(i int64) {
	if m.addtreatmentAt != nil {
		*m.addtreatmentAt += i
	} else {
		m.addtreatmentAt = &i
	}
}

// AddedTreatmentAt returns the value that was added to the treatmentAt field in this mutation.
func (m *EpidemicMutation) AddedTreatmentAt() (r int64, exists bool) {
	v := m.addtreatmentAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetTreatmentAt reset all changes of the "treatmentAt" field.
func (m *EpidemicMutation) ResetTreatmentAt() {
	m.treatmentAt = nil
	m.addtreatmentAt = nil
}

// SetWhereabout sets the whereabout field.
func (m *EpidemicMutation) SetWhereabout(s string) {
	m.whereabout = &s
}

// Whereabout returns the whereabout value in the mutation.
func (m *EpidemicMutation) Whereabout() (r string, exists bool) {
	v := m.whereabout
	if v == nil {
		return
	}
	return *v, true
}

// OldWhereabout returns the old whereabout value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldWhereabout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWhereabout is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWhereabout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhereabout: %w", err)
	}
	return oldValue.Whereabout, nil
}

// ResetWhereabout reset all changes of the "whereabout" field.
func (m *EpidemicMutation) ResetWhereabout() {
	m.whereabout = nil
}

// SetRemarks sets the remarks field.
func (m *EpidemicMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *EpidemicMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *EpidemicMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *EpidemicMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *EpidemicMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *EpidemicMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *EpidemicMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *EpidemicMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *EpidemicMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *EpidemicMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *EpidemicMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *EpidemicMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *EpidemicMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *EpidemicMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *EpidemicMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Epidemic.
// If the Epidemic object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *EpidemicMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *EpidemicMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *EpidemicMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *EpidemicMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Epidemic).
func (m *EpidemicMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EpidemicMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.cattleId != nil {
		fields = append(fields, epidemic.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, epidemic.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, epidemic.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, epidemic.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, epidemic.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, epidemic.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, epidemic.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, epidemic.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, epidemic.FieldEarNumber)
	}
	if m.onset != nil {
		fields = append(fields, epidemic.FieldOnset)
	}
	if m.epidemicTypeId != nil {
		fields = append(fields, epidemic.FieldEpidemicTypeId)
	}
	if m.epidemicTypeName != nil {
		fields = append(fields, epidemic.FieldEpidemicTypeName)
	}
	if m.isolatedShedName != nil {
		fields = append(fields, epidemic.FieldIsolatedShedName)
	}
	if m.diagedBy != nil {
		fields = append(fields, epidemic.FieldDiagedBy)
	}
	if m.treatmentResultId != nil {
		fields = append(fields, epidemic.FieldTreatmentResultId)
	}
	if m.treatmentResultName != nil {
		fields = append(fields, epidemic.FieldTreatmentResultName)
	}
	if m.treatmentState != nil {
		fields = append(fields, epidemic.FieldTreatmentState)
	}
	if m.treatmentAt != nil {
		fields = append(fields, epidemic.FieldTreatmentAt)
	}
	if m.whereabout != nil {
		fields = append(fields, epidemic.FieldWhereabout)
	}
	if m.remarks != nil {
		fields = append(fields, epidemic.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, epidemic.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, epidemic.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, epidemic.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EpidemicMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case epidemic.FieldCattleId:
		return m.CattleId()
	case epidemic.FieldTenantId:
		return m.TenantId()
	case epidemic.FieldTenantName:
		return m.TenantName()
	case epidemic.FieldFarmId:
		return m.FarmId()
	case epidemic.FieldFarmName:
		return m.FarmName()
	case epidemic.FieldShedId:
		return m.ShedId()
	case epidemic.FieldShedName:
		return m.ShedName()
	case epidemic.FieldName:
		return m.Name()
	case epidemic.FieldEarNumber:
		return m.EarNumber()
	case epidemic.FieldOnset:
		return m.Onset()
	case epidemic.FieldEpidemicTypeId:
		return m.EpidemicTypeId()
	case epidemic.FieldEpidemicTypeName:
		return m.EpidemicTypeName()
	case epidemic.FieldIsolatedShedName:
		return m.IsolatedShedName()
	case epidemic.FieldDiagedBy:
		return m.DiagedBy()
	case epidemic.FieldTreatmentResultId:
		return m.TreatmentResultId()
	case epidemic.FieldTreatmentResultName:
		return m.TreatmentResultName()
	case epidemic.FieldTreatmentState:
		return m.TreatmentState()
	case epidemic.FieldTreatmentAt:
		return m.TreatmentAt()
	case epidemic.FieldWhereabout:
		return m.Whereabout()
	case epidemic.FieldRemarks:
		return m.Remarks()
	case epidemic.FieldCreatedAt:
		return m.CreatedAt()
	case epidemic.FieldUpdatedAt:
		return m.UpdatedAt()
	case epidemic.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EpidemicMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case epidemic.FieldCattleId:
		return m.OldCattleId(ctx)
	case epidemic.FieldTenantId:
		return m.OldTenantId(ctx)
	case epidemic.FieldTenantName:
		return m.OldTenantName(ctx)
	case epidemic.FieldFarmId:
		return m.OldFarmId(ctx)
	case epidemic.FieldFarmName:
		return m.OldFarmName(ctx)
	case epidemic.FieldShedId:
		return m.OldShedId(ctx)
	case epidemic.FieldShedName:
		return m.OldShedName(ctx)
	case epidemic.FieldName:
		return m.OldName(ctx)
	case epidemic.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case epidemic.FieldOnset:
		return m.OldOnset(ctx)
	case epidemic.FieldEpidemicTypeId:
		return m.OldEpidemicTypeId(ctx)
	case epidemic.FieldEpidemicTypeName:
		return m.OldEpidemicTypeName(ctx)
	case epidemic.FieldIsolatedShedName:
		return m.OldIsolatedShedName(ctx)
	case epidemic.FieldDiagedBy:
		return m.OldDiagedBy(ctx)
	case epidemic.FieldTreatmentResultId:
		return m.OldTreatmentResultId(ctx)
	case epidemic.FieldTreatmentResultName:
		return m.OldTreatmentResultName(ctx)
	case epidemic.FieldTreatmentState:
		return m.OldTreatmentState(ctx)
	case epidemic.FieldTreatmentAt:
		return m.OldTreatmentAt(ctx)
	case epidemic.FieldWhereabout:
		return m.OldWhereabout(ctx)
	case epidemic.FieldRemarks:
		return m.OldRemarks(ctx)
	case epidemic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case epidemic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case epidemic.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Epidemic field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicMutation) SetField(name string, value ent.Value) error {
	switch name {
	case epidemic.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case epidemic.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case epidemic.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case epidemic.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case epidemic.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case epidemic.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case epidemic.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case epidemic.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case epidemic.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case epidemic.FieldOnset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnset(v)
		return nil
	case epidemic.FieldEpidemicTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpidemicTypeId(v)
		return nil
	case epidemic.FieldEpidemicTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpidemicTypeName(v)
		return nil
	case epidemic.FieldIsolatedShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsolatedShedName(v)
		return nil
	case epidemic.FieldDiagedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiagedBy(v)
		return nil
	case epidemic.FieldTreatmentResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentResultId(v)
		return nil
	case epidemic.FieldTreatmentResultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentResultName(v)
		return nil
	case epidemic.FieldTreatmentState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentState(v)
		return nil
	case epidemic.FieldTreatmentAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTreatmentAt(v)
		return nil
	case epidemic.FieldWhereabout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhereabout(v)
		return nil
	case epidemic.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case epidemic.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case epidemic.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case epidemic.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Epidemic field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EpidemicMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, epidemic.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, epidemic.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, epidemic.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, epidemic.FieldShedId)
	}
	if m.addonset != nil {
		fields = append(fields, epidemic.FieldOnset)
	}
	if m.addepidemicTypeId != nil {
		fields = append(fields, epidemic.FieldEpidemicTypeId)
	}
	if m.addtreatmentResultId != nil {
		fields = append(fields, epidemic.FieldTreatmentResultId)
	}
	if m.addtreatmentAt != nil {
		fields = append(fields, epidemic.FieldTreatmentAt)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, epidemic.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, epidemic.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, epidemic.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EpidemicMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case epidemic.FieldCattleId:
		return m.AddedCattleId()
	case epidemic.FieldTenantId:
		return m.AddedTenantId()
	case epidemic.FieldFarmId:
		return m.AddedFarmId()
	case epidemic.FieldShedId:
		return m.AddedShedId()
	case epidemic.FieldOnset:
		return m.AddedOnset()
	case epidemic.FieldEpidemicTypeId:
		return m.AddedEpidemicTypeId()
	case epidemic.FieldTreatmentResultId:
		return m.AddedTreatmentResultId()
	case epidemic.FieldTreatmentAt:
		return m.AddedTreatmentAt()
	case epidemic.FieldCreatedAt:
		return m.AddedCreatedAt()
	case epidemic.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case epidemic.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicMutation) AddField(name string, value ent.Value) error {
	switch name {
	case epidemic.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case epidemic.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case epidemic.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case epidemic.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case epidemic.FieldOnset:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnset(v)
		return nil
	case epidemic.FieldEpidemicTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpidemicTypeId(v)
		return nil
	case epidemic.FieldTreatmentResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTreatmentResultId(v)
		return nil
	case epidemic.FieldTreatmentAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTreatmentAt(v)
		return nil
	case epidemic.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case epidemic.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case epidemic.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Epidemic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EpidemicMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EpidemicMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpidemicMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Epidemic nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EpidemicMutation) ResetField(name string) error {
	switch name {
	case epidemic.FieldCattleId:
		m.ResetCattleId()
		return nil
	case epidemic.FieldTenantId:
		m.ResetTenantId()
		return nil
	case epidemic.FieldTenantName:
		m.ResetTenantName()
		return nil
	case epidemic.FieldFarmId:
		m.ResetFarmId()
		return nil
	case epidemic.FieldFarmName:
		m.ResetFarmName()
		return nil
	case epidemic.FieldShedId:
		m.ResetShedId()
		return nil
	case epidemic.FieldShedName:
		m.ResetShedName()
		return nil
	case epidemic.FieldName:
		m.ResetName()
		return nil
	case epidemic.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case epidemic.FieldOnset:
		m.ResetOnset()
		return nil
	case epidemic.FieldEpidemicTypeId:
		m.ResetEpidemicTypeId()
		return nil
	case epidemic.FieldEpidemicTypeName:
		m.ResetEpidemicTypeName()
		return nil
	case epidemic.FieldIsolatedShedName:
		m.ResetIsolatedShedName()
		return nil
	case epidemic.FieldDiagedBy:
		m.ResetDiagedBy()
		return nil
	case epidemic.FieldTreatmentResultId:
		m.ResetTreatmentResultId()
		return nil
	case epidemic.FieldTreatmentResultName:
		m.ResetTreatmentResultName()
		return nil
	case epidemic.FieldTreatmentState:
		m.ResetTreatmentState()
		return nil
	case epidemic.FieldTreatmentAt:
		m.ResetTreatmentAt()
		return nil
	case epidemic.FieldWhereabout:
		m.ResetWhereabout()
		return nil
	case epidemic.FieldRemarks:
		m.ResetRemarks()
		return nil
	case epidemic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case epidemic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case epidemic.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Epidemic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EpidemicMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EpidemicMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EpidemicMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EpidemicMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EpidemicMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EpidemicMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EpidemicMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Epidemic unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EpidemicMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Epidemic edge %s", name)
}

// EpidemicTypeMutation represents an operation that mutate the EpidemicTypes
// nodes in the graph.
type EpidemicTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EpidemicType, error)
}

var _ ent.Mutation = (*EpidemicTypeMutation)(nil)

// epidemictypeOption allows to manage the mutation configuration using functional options.
type epidemictypeOption func(*EpidemicTypeMutation)

// newEpidemicTypeMutation creates new mutation for $n.Name.
func newEpidemicTypeMutation(c config, op Op, opts ...epidemictypeOption) *EpidemicTypeMutation {
	m := &EpidemicTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEpidemicType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpidemicTypeID sets the id field of the mutation.
func withEpidemicTypeID(id int64) epidemictypeOption {
	return func(m *EpidemicTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EpidemicType
		)
		m.oldValue = func(ctx context.Context) (*EpidemicType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EpidemicType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpidemicType sets the old EpidemicType of the mutation.
func withEpidemicType(node *EpidemicType) epidemictypeOption {
	return func(m *EpidemicTypeMutation) {
		m.oldValue = func(context.Context) (*EpidemicType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpidemicTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpidemicTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EpidemicTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EpidemicTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EpidemicTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EpidemicType.
// If the EpidemicType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EpidemicTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EpidemicTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *EpidemicTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EpidemicType).
func (m *EpidemicTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EpidemicTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, epidemictype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EpidemicTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case epidemictype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EpidemicTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case epidemictype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EpidemicType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case epidemictype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EpidemicType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EpidemicTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EpidemicTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EpidemicTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EpidemicType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EpidemicTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EpidemicTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpidemicTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EpidemicType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EpidemicTypeMutation) ResetField(name string) error {
	switch name {
	case epidemictype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EpidemicType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EpidemicTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EpidemicTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EpidemicTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EpidemicTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EpidemicTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EpidemicTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EpidemicTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EpidemicType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EpidemicTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EpidemicType edge %s", name)
}

// EstrusMutation represents an operation that mutate the EstrusSlice
// nodes in the graph.
type EstrusMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	cattleId        *int64
	addcattleId     *int64
	tenantId        *int64
	addtenantId     *int64
	tenantName      *string
	farmId          *int64
	addfarmId       *int64
	farmName        *string
	shedId          *int64
	addshedId       *int64
	shedName        *string
	name            *string
	earNumber       *string
	times           *int
	addtimes        *int
	estrusAt        *int64
	addestrusAt     *int64
	estrusTypeId    *int
	addestrusTypeId *int
	estrusTypeName  *string
	userName        *string
	remarks         *string
	createdAt       *int64
	addcreatedAt    *int64
	updatedAt       *int64
	addupdatedAt    *int64
	deleted         *int
	adddeleted      *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Estrus, error)
}

var _ ent.Mutation = (*EstrusMutation)(nil)

// estrusOption allows to manage the mutation configuration using functional options.
type estrusOption func(*EstrusMutation)

// newEstrusMutation creates new mutation for $n.Name.
func newEstrusMutation(c config, op Op, opts ...estrusOption) *EstrusMutation {
	m := &EstrusMutation{
		config:        c,
		op:            op,
		typ:           TypeEstrus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstrusID sets the id field of the mutation.
func withEstrusID(id int64) estrusOption {
	return func(m *EstrusMutation) {
		var (
			err   error
			once  sync.Once
			value *Estrus
		)
		m.oldValue = func(ctx context.Context) (*Estrus, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Estrus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstrus sets the old Estrus of the mutation.
func withEstrus(node *Estrus) estrusOption {
	return func(m *EstrusMutation) {
		m.oldValue = func(context.Context) (*Estrus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstrusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstrusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EstrusMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *EstrusMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *EstrusMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *EstrusMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *EstrusMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *EstrusMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *EstrusMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *EstrusMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *EstrusMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *EstrusMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *EstrusMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *EstrusMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *EstrusMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *EstrusMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *EstrusMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *EstrusMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *EstrusMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *EstrusMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *EstrusMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *EstrusMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *EstrusMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *EstrusMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *EstrusMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *EstrusMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *EstrusMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *EstrusMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *EstrusMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *EstrusMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *EstrusMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *EstrusMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *EstrusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EstrusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *EstrusMutation) ClearName() {
	m.name = nil
	m.clearedFields[estrus.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *EstrusMutation) NameCleared() bool {
	_, ok := m.clearedFields[estrus.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *EstrusMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, estrus.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *EstrusMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *EstrusMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *EstrusMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *EstrusMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *EstrusMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *EstrusMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *EstrusMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *EstrusMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetEstrusAt sets the estrusAt field.
func (m *EstrusMutation) SetEstrusAt(i int64) {
	m.estrusAt = &i
	m.addestrusAt = nil
}

// EstrusAt returns the estrusAt value in the mutation.
func (m *EstrusMutation) EstrusAt() (r int64, exists bool) {
	v := m.estrusAt
	if v == nil {
		return
	}
	return *v, true
}

// OldEstrusAt returns the old estrusAt value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEstrusAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstrusAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstrusAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstrusAt: %w", err)
	}
	return oldValue.EstrusAt, nil
}

// AddEstrusAt adds i to estrusAt.
func (m *EstrusMutation) AddEstrusAt(i int64) {
	if m.addestrusAt != nil {
		*m.addestrusAt += i
	} else {
		m.addestrusAt = &i
	}
}

// AddedEstrusAt returns the value that was added to the estrusAt field in this mutation.
func (m *EstrusMutation) AddedEstrusAt() (r int64, exists bool) {
	v := m.addestrusAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstrusAt reset all changes of the "estrusAt" field.
func (m *EstrusMutation) ResetEstrusAt() {
	m.estrusAt = nil
	m.addestrusAt = nil
}

// SetEstrusTypeId sets the estrusTypeId field.
func (m *EstrusMutation) SetEstrusTypeId(i int) {
	m.estrusTypeId = &i
	m.addestrusTypeId = nil
}

// EstrusTypeId returns the estrusTypeId value in the mutation.
func (m *EstrusMutation) EstrusTypeId() (r int, exists bool) {
	v := m.estrusTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldEstrusTypeId returns the old estrusTypeId value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEstrusTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstrusTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstrusTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstrusTypeId: %w", err)
	}
	return oldValue.EstrusTypeId, nil
}

// AddEstrusTypeId adds i to estrusTypeId.
func (m *EstrusMutation) AddEstrusTypeId(i int) {
	if m.addestrusTypeId != nil {
		*m.addestrusTypeId += i
	} else {
		m.addestrusTypeId = &i
	}
}

// AddedEstrusTypeId returns the value that was added to the estrusTypeId field in this mutation.
func (m *EstrusMutation) AddedEstrusTypeId() (r int, exists bool) {
	v := m.addestrusTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetEstrusTypeId reset all changes of the "estrusTypeId" field.
func (m *EstrusMutation) ResetEstrusTypeId() {
	m.estrusTypeId = nil
	m.addestrusTypeId = nil
}

// SetEstrusTypeName sets the estrusTypeName field.
func (m *EstrusMutation) SetEstrusTypeName(s string) {
	m.estrusTypeName = &s
}

// EstrusTypeName returns the estrusTypeName value in the mutation.
func (m *EstrusMutation) EstrusTypeName() (r string, exists bool) {
	v := m.estrusTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldEstrusTypeName returns the old estrusTypeName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldEstrusTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEstrusTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEstrusTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstrusTypeName: %w", err)
	}
	return oldValue.EstrusTypeName, nil
}

// ResetEstrusTypeName reset all changes of the "estrusTypeName" field.
func (m *EstrusMutation) ResetEstrusTypeName() {
	m.estrusTypeName = nil
}

// SetUserName sets the userName field.
func (m *EstrusMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *EstrusMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *EstrusMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *EstrusMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *EstrusMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *EstrusMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *EstrusMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *EstrusMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *EstrusMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *EstrusMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *EstrusMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *EstrusMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *EstrusMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *EstrusMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *EstrusMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *EstrusMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *EstrusMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *EstrusMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Estrus.
// If the Estrus object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *EstrusMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *EstrusMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *EstrusMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *EstrusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Estrus).
func (m *EstrusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EstrusMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.cattleId != nil {
		fields = append(fields, estrus.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, estrus.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, estrus.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, estrus.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, estrus.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, estrus.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, estrus.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, estrus.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, estrus.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, estrus.FieldTimes)
	}
	if m.estrusAt != nil {
		fields = append(fields, estrus.FieldEstrusAt)
	}
	if m.estrusTypeId != nil {
		fields = append(fields, estrus.FieldEstrusTypeId)
	}
	if m.estrusTypeName != nil {
		fields = append(fields, estrus.FieldEstrusTypeName)
	}
	if m.userName != nil {
		fields = append(fields, estrus.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, estrus.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, estrus.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, estrus.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, estrus.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EstrusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estrus.FieldCattleId:
		return m.CattleId()
	case estrus.FieldTenantId:
		return m.TenantId()
	case estrus.FieldTenantName:
		return m.TenantName()
	case estrus.FieldFarmId:
		return m.FarmId()
	case estrus.FieldFarmName:
		return m.FarmName()
	case estrus.FieldShedId:
		return m.ShedId()
	case estrus.FieldShedName:
		return m.ShedName()
	case estrus.FieldName:
		return m.Name()
	case estrus.FieldEarNumber:
		return m.EarNumber()
	case estrus.FieldTimes:
		return m.Times()
	case estrus.FieldEstrusAt:
		return m.EstrusAt()
	case estrus.FieldEstrusTypeId:
		return m.EstrusTypeId()
	case estrus.FieldEstrusTypeName:
		return m.EstrusTypeName()
	case estrus.FieldUserName:
		return m.UserName()
	case estrus.FieldRemarks:
		return m.Remarks()
	case estrus.FieldCreatedAt:
		return m.CreatedAt()
	case estrus.FieldUpdatedAt:
		return m.UpdatedAt()
	case estrus.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EstrusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estrus.FieldCattleId:
		return m.OldCattleId(ctx)
	case estrus.FieldTenantId:
		return m.OldTenantId(ctx)
	case estrus.FieldTenantName:
		return m.OldTenantName(ctx)
	case estrus.FieldFarmId:
		return m.OldFarmId(ctx)
	case estrus.FieldFarmName:
		return m.OldFarmName(ctx)
	case estrus.FieldShedId:
		return m.OldShedId(ctx)
	case estrus.FieldShedName:
		return m.OldShedName(ctx)
	case estrus.FieldName:
		return m.OldName(ctx)
	case estrus.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case estrus.FieldTimes:
		return m.OldTimes(ctx)
	case estrus.FieldEstrusAt:
		return m.OldEstrusAt(ctx)
	case estrus.FieldEstrusTypeId:
		return m.OldEstrusTypeId(ctx)
	case estrus.FieldEstrusTypeName:
		return m.OldEstrusTypeName(ctx)
	case estrus.FieldUserName:
		return m.OldUserName(ctx)
	case estrus.FieldRemarks:
		return m.OldRemarks(ctx)
	case estrus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case estrus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case estrus.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Estrus field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estrus.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case estrus.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case estrus.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case estrus.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case estrus.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case estrus.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case estrus.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case estrus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case estrus.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case estrus.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case estrus.FieldEstrusAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstrusAt(v)
		return nil
	case estrus.FieldEstrusTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstrusTypeId(v)
		return nil
	case estrus.FieldEstrusTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstrusTypeName(v)
		return nil
	case estrus.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case estrus.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case estrus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case estrus.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case estrus.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Estrus field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EstrusMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, estrus.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, estrus.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, estrus.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, estrus.FieldShedId)
	}
	if m.addtimes != nil {
		fields = append(fields, estrus.FieldTimes)
	}
	if m.addestrusAt != nil {
		fields = append(fields, estrus.FieldEstrusAt)
	}
	if m.addestrusTypeId != nil {
		fields = append(fields, estrus.FieldEstrusTypeId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, estrus.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, estrus.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, estrus.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EstrusMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case estrus.FieldCattleId:
		return m.AddedCattleId()
	case estrus.FieldTenantId:
		return m.AddedTenantId()
	case estrus.FieldFarmId:
		return m.AddedFarmId()
	case estrus.FieldShedId:
		return m.AddedShedId()
	case estrus.FieldTimes:
		return m.AddedTimes()
	case estrus.FieldEstrusAt:
		return m.AddedEstrusAt()
	case estrus.FieldEstrusTypeId:
		return m.AddedEstrusTypeId()
	case estrus.FieldCreatedAt:
		return m.AddedCreatedAt()
	case estrus.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case estrus.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusMutation) AddField(name string, value ent.Value) error {
	switch name {
	case estrus.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case estrus.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case estrus.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case estrus.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case estrus.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case estrus.FieldEstrusAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstrusAt(v)
		return nil
	case estrus.FieldEstrusTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstrusTypeId(v)
		return nil
	case estrus.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case estrus.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case estrus.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Estrus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EstrusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(estrus.FieldName) {
		fields = append(fields, estrus.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EstrusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstrusMutation) ClearField(name string) error {
	switch name {
	case estrus.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Estrus nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EstrusMutation) ResetField(name string) error {
	switch name {
	case estrus.FieldCattleId:
		m.ResetCattleId()
		return nil
	case estrus.FieldTenantId:
		m.ResetTenantId()
		return nil
	case estrus.FieldTenantName:
		m.ResetTenantName()
		return nil
	case estrus.FieldFarmId:
		m.ResetFarmId()
		return nil
	case estrus.FieldFarmName:
		m.ResetFarmName()
		return nil
	case estrus.FieldShedId:
		m.ResetShedId()
		return nil
	case estrus.FieldShedName:
		m.ResetShedName()
		return nil
	case estrus.FieldName:
		m.ResetName()
		return nil
	case estrus.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case estrus.FieldTimes:
		m.ResetTimes()
		return nil
	case estrus.FieldEstrusAt:
		m.ResetEstrusAt()
		return nil
	case estrus.FieldEstrusTypeId:
		m.ResetEstrusTypeId()
		return nil
	case estrus.FieldEstrusTypeName:
		m.ResetEstrusTypeName()
		return nil
	case estrus.FieldUserName:
		m.ResetUserName()
		return nil
	case estrus.FieldRemarks:
		m.ResetRemarks()
		return nil
	case estrus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case estrus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case estrus.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Estrus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EstrusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EstrusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EstrusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EstrusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EstrusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EstrusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EstrusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Estrus unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EstrusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Estrus edge %s", name)
}

// EstrusTypeMutation represents an operation that mutate the EstrusTypes
// nodes in the graph.
type EstrusTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EstrusType, error)
}

var _ ent.Mutation = (*EstrusTypeMutation)(nil)

// estrustypeOption allows to manage the mutation configuration using functional options.
type estrustypeOption func(*EstrusTypeMutation)

// newEstrusTypeMutation creates new mutation for $n.Name.
func newEstrusTypeMutation(c config, op Op, opts ...estrustypeOption) *EstrusTypeMutation {
	m := &EstrusTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEstrusType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstrusTypeID sets the id field of the mutation.
func withEstrusTypeID(id int64) estrustypeOption {
	return func(m *EstrusTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EstrusType
		)
		m.oldValue = func(ctx context.Context) (*EstrusType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EstrusType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstrusType sets the old EstrusType of the mutation.
func withEstrusType(node *EstrusType) estrustypeOption {
	return func(m *EstrusTypeMutation) {
		m.oldValue = func(context.Context) (*EstrusType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstrusTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstrusTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EstrusTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *EstrusTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *EstrusTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the EstrusType.
// If the EstrusType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EstrusTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *EstrusTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *EstrusTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EstrusType).
func (m *EstrusTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EstrusTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, estrustype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EstrusTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estrustype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EstrusTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estrustype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EstrusType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estrustype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EstrusType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EstrusTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EstrusTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EstrusTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EstrusType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EstrusTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EstrusTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstrusTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EstrusType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EstrusTypeMutation) ResetField(name string) error {
	switch name {
	case estrustype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EstrusType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EstrusTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EstrusTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EstrusTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EstrusTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EstrusTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EstrusTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EstrusTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EstrusType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EstrusTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EstrusType edge %s", name)
}

// EventMutation represents an operation that mutate the Events
// nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	earNumber     *string
	eventType     *string
	eventName     *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	createdAt     *int64
	addcreatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Event, error)
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows to manage the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for $n.Name.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the id field of the mutation.
func withEventID(id int64) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EventMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEarNumber sets the earNumber field.
func (m *EventMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *EventMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *EventMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetEventType sets the eventType field.
func (m *EventMutation) SetEventType(s string) {
	m.eventType = &s
}

// EventType returns the eventType value in the mutation.
func (m *EventMutation) EventType() (r string, exists bool) {
	v := m.eventType
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old eventType value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEventType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType reset all changes of the "eventType" field.
func (m *EventMutation) ResetEventType() {
	m.eventType = nil
}

// SetEventName sets the eventName field.
func (m *EventMutation) SetEventName(s string) {
	m.eventName = &s
}

// EventName returns the eventName value in the mutation.
func (m *EventMutation) EventName() (r string, exists bool) {
	v := m.eventName
	if v == nil {
		return
	}
	return *v, true
}

// OldEventName returns the old eventName value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldEventName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEventName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEventName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventName: %w", err)
	}
	return oldValue.EventName, nil
}

// ResetEventName reset all changes of the "eventName" field.
func (m *EventMutation) ResetEventName() {
	m.eventName = nil
}

// SetTenantId sets the tenantId field.
func (m *EventMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *EventMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *EventMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *EventMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *EventMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *EventMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *EventMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *EventMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetCreatedAt sets the createdAt field.
func (m *EventMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *EventMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *EventMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *EventMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *EventMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *EventMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *EventMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Event.
// If the Event object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EventMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *EventMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *EventMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *EventMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.earNumber != nil {
		fields = append(fields, event.FieldEarNumber)
	}
	if m.eventType != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.eventName != nil {
		fields = append(fields, event.FieldEventName)
	}
	if m.tenantId != nil {
		fields = append(fields, event.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, event.FieldTenantName)
	}
	if m.createdAt != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, event.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldEarNumber:
		return m.EarNumber()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldEventName:
		return m.EventName()
	case event.FieldTenantId:
		return m.TenantId()
	case event.FieldTenantName:
		return m.TenantName()
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldEventName:
		return m.OldEventName(ctx)
	case event.FieldTenantId:
		return m.OldTenantId(ctx)
	case event.FieldTenantName:
		return m.OldTenantName(ctx)
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldEventName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventName(v)
		return nil
	case event.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case event.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, event.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, event.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldTenantId:
		return m.AddedTenantId()
	case event.FieldCreatedAt:
		return m.AddedCreatedAt()
	case event.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case event.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case event.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldEventName:
		m.ResetEventName()
		return nil
	case event.FieldTenantId:
		m.ResetTenantId()
		return nil
	case event.FieldTenantName:
		m.ResetTenantName()
		return nil
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Event edge %s", name)
}

// FarmMutation represents an operation that mutate the Farms
// nodes in the graph.
type FarmMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	name             *string
	code             *string
	constructionDate *string
	feedingScale     *int64
	addfeedingScale  *int64
	contactUser      *string
	contactPhone     *string
	contactAddress   *string
	square           *int64
	addsquare        *int64
	shedCount        *int64
	addshedCount     *int64
	categoryId       *int64
	addcategoryId    *int64
	categoryName     *string
	varietyId        *int64
	addvarietyId     *int64
	varietyName      *string
	districtCode     *string
	districtName     *string
	tenantId         *int64
	addtenantId      *int64
	tenantName       *string
	remarks          *string
	createdAt        *int64
	addcreatedAt     *int64
	updatedAt        *int64
	addupdatedAt     *int64
	deleted          *int
	adddeleted       *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Farm, error)
}

var _ ent.Mutation = (*FarmMutation)(nil)

// farmOption allows to manage the mutation configuration using functional options.
type farmOption func(*FarmMutation)

// newFarmMutation creates new mutation for $n.Name.
func newFarmMutation(c config, op Op, opts ...farmOption) *FarmMutation {
	m := &FarmMutation{
		config:        c,
		op:            op,
		typ:           TypeFarm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFarmID sets the id field of the mutation.
func withFarmID(id int64) farmOption {
	return func(m *FarmMutation) {
		var (
			err   error
			once  sync.Once
			value *Farm
		)
		m.oldValue = func(ctx context.Context) (*Farm, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Farm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFarm sets the old Farm of the mutation.
func withFarm(node *Farm) farmOption {
	return func(m *FarmMutation) {
		m.oldValue = func(context.Context) (*Farm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FarmMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FarmMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FarmMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FarmMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FarmMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FarmMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *FarmMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *FarmMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *FarmMutation) ResetCode() {
	m.code = nil
}

// SetConstructionDate sets the constructionDate field.
func (m *FarmMutation) SetConstructionDate(s string) {
	m.constructionDate = &s
}

// ConstructionDate returns the constructionDate value in the mutation.
func (m *FarmMutation) ConstructionDate() (r string, exists bool) {
	v := m.constructionDate
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionDate returns the old constructionDate value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldConstructionDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConstructionDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConstructionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionDate: %w", err)
	}
	return oldValue.ConstructionDate, nil
}

// ResetConstructionDate reset all changes of the "constructionDate" field.
func (m *FarmMutation) ResetConstructionDate() {
	m.constructionDate = nil
}

// SetFeedingScale sets the feedingScale field.
func (m *FarmMutation) SetFeedingScale(i int64) {
	m.feedingScale = &i
	m.addfeedingScale = nil
}

// FeedingScale returns the feedingScale value in the mutation.
func (m *FarmMutation) FeedingScale() (r int64, exists bool) {
	v := m.feedingScale
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedingScale returns the old feedingScale value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldFeedingScale(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFeedingScale is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFeedingScale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedingScale: %w", err)
	}
	return oldValue.FeedingScale, nil
}

// AddFeedingScale adds i to feedingScale.
func (m *FarmMutation) AddFeedingScale(i int64) {
	if m.addfeedingScale != nil {
		*m.addfeedingScale += i
	} else {
		m.addfeedingScale = &i
	}
}

// AddedFeedingScale returns the value that was added to the feedingScale field in this mutation.
func (m *FarmMutation) AddedFeedingScale() (r int64, exists bool) {
	v := m.addfeedingScale
	if v == nil {
		return
	}
	return *v, true
}

// ResetFeedingScale reset all changes of the "feedingScale" field.
func (m *FarmMutation) ResetFeedingScale() {
	m.feedingScale = nil
	m.addfeedingScale = nil
}

// SetContactUser sets the contactUser field.
func (m *FarmMutation) SetContactUser(s string) {
	m.contactUser = &s
}

// ContactUser returns the contactUser value in the mutation.
func (m *FarmMutation) ContactUser() (r string, exists bool) {
	v := m.contactUser
	if v == nil {
		return
	}
	return *v, true
}

// OldContactUser returns the old contactUser value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldContactUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactUser is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactUser: %w", err)
	}
	return oldValue.ContactUser, nil
}

// ResetContactUser reset all changes of the "contactUser" field.
func (m *FarmMutation) ResetContactUser() {
	m.contactUser = nil
}

// SetContactPhone sets the contactPhone field.
func (m *FarmMutation) SetContactPhone(s string) {
	m.contactPhone = &s
}

// ContactPhone returns the contactPhone value in the mutation.
func (m *FarmMutation) ContactPhone() (r string, exists bool) {
	v := m.contactPhone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old contactPhone value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ResetContactPhone reset all changes of the "contactPhone" field.
func (m *FarmMutation) ResetContactPhone() {
	m.contactPhone = nil
}

// SetContactAddress sets the contactAddress field.
func (m *FarmMutation) SetContactAddress(s string) {
	m.contactAddress = &s
}

// ContactAddress returns the contactAddress value in the mutation.
func (m *FarmMutation) ContactAddress() (r string, exists bool) {
	v := m.contactAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldContactAddress returns the old contactAddress value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldContactAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContactAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContactAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactAddress: %w", err)
	}
	return oldValue.ContactAddress, nil
}

// ResetContactAddress reset all changes of the "contactAddress" field.
func (m *FarmMutation) ResetContactAddress() {
	m.contactAddress = nil
}

// SetSquare sets the square field.
func (m *FarmMutation) SetSquare(i int64) {
	m.square = &i
	m.addsquare = nil
}

// Square returns the square value in the mutation.
func (m *FarmMutation) Square() (r int64, exists bool) {
	v := m.square
	if v == nil {
		return
	}
	return *v, true
}

// OldSquare returns the old square value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldSquare(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSquare is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSquare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSquare: %w", err)
	}
	return oldValue.Square, nil
}

// AddSquare adds i to square.
func (m *FarmMutation) AddSquare(i int64) {
	if m.addsquare != nil {
		*m.addsquare += i
	} else {
		m.addsquare = &i
	}
}

// AddedSquare returns the value that was added to the square field in this mutation.
func (m *FarmMutation) AddedSquare() (r int64, exists bool) {
	v := m.addsquare
	if v == nil {
		return
	}
	return *v, true
}

// ResetSquare reset all changes of the "square" field.
func (m *FarmMutation) ResetSquare() {
	m.square = nil
	m.addsquare = nil
}

// SetShedCount sets the shedCount field.
func (m *FarmMutation) SetShedCount(i int64) {
	m.shedCount = &i
	m.addshedCount = nil
}

// ShedCount returns the shedCount value in the mutation.
func (m *FarmMutation) ShedCount() (r int64, exists bool) {
	v := m.shedCount
	if v == nil {
		return
	}
	return *v, true
}

// OldShedCount returns the old shedCount value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldShedCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedCount: %w", err)
	}
	return oldValue.ShedCount, nil
}

// AddShedCount adds i to shedCount.
func (m *FarmMutation) AddShedCount(i int64) {
	if m.addshedCount != nil {
		*m.addshedCount += i
	} else {
		m.addshedCount = &i
	}
}

// AddedShedCount returns the value that was added to the shedCount field in this mutation.
func (m *FarmMutation) AddedShedCount() (r int64, exists bool) {
	v := m.addshedCount
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedCount reset all changes of the "shedCount" field.
func (m *FarmMutation) ResetShedCount() {
	m.shedCount = nil
	m.addshedCount = nil
}

// SetCategoryId sets the categoryId field.
func (m *FarmMutation) SetCategoryId(i int64) {
	m.categoryId = &i
	m.addcategoryId = nil
}

// CategoryId returns the categoryId value in the mutation.
func (m *FarmMutation) CategoryId() (r int64, exists bool) {
	v := m.categoryId
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryId returns the old categoryId value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCategoryId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryId: %w", err)
	}
	return oldValue.CategoryId, nil
}

// AddCategoryId adds i to categoryId.
func (m *FarmMutation) AddCategoryId(i int64) {
	if m.addcategoryId != nil {
		*m.addcategoryId += i
	} else {
		m.addcategoryId = &i
	}
}

// AddedCategoryId returns the value that was added to the categoryId field in this mutation.
func (m *FarmMutation) AddedCategoryId() (r int64, exists bool) {
	v := m.addcategoryId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryId reset all changes of the "categoryId" field.
func (m *FarmMutation) ResetCategoryId() {
	m.categoryId = nil
	m.addcategoryId = nil
}

// SetCategoryName sets the categoryName field.
func (m *FarmMutation) SetCategoryName(s string) {
	m.categoryName = &s
}

// CategoryName returns the categoryName value in the mutation.
func (m *FarmMutation) CategoryName() (r string, exists bool) {
	v := m.categoryName
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryName returns the old categoryName value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCategoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryName: %w", err)
	}
	return oldValue.CategoryName, nil
}

// ResetCategoryName reset all changes of the "categoryName" field.
func (m *FarmMutation) ResetCategoryName() {
	m.categoryName = nil
}

// SetVarietyId sets the varietyId field.
func (m *FarmMutation) SetVarietyId(i int64) {
	m.varietyId = &i
	m.addvarietyId = nil
}

// VarietyId returns the varietyId value in the mutation.
func (m *FarmMutation) VarietyId() (r int64, exists bool) {
	v := m.varietyId
	if v == nil {
		return
	}
	return *v, true
}

// OldVarietyId returns the old varietyId value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldVarietyId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVarietyId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVarietyId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVarietyId: %w", err)
	}
	return oldValue.VarietyId, nil
}

// AddVarietyId adds i to varietyId.
func (m *FarmMutation) AddVarietyId(i int64) {
	if m.addvarietyId != nil {
		*m.addvarietyId += i
	} else {
		m.addvarietyId = &i
	}
}

// AddedVarietyId returns the value that was added to the varietyId field in this mutation.
func (m *FarmMutation) AddedVarietyId() (r int64, exists bool) {
	v := m.addvarietyId
	if v == nil {
		return
	}
	return *v, true
}

// ResetVarietyId reset all changes of the "varietyId" field.
func (m *FarmMutation) ResetVarietyId() {
	m.varietyId = nil
	m.addvarietyId = nil
}

// SetVarietyName sets the varietyName field.
func (m *FarmMutation) SetVarietyName(s string) {
	m.varietyName = &s
}

// VarietyName returns the varietyName value in the mutation.
func (m *FarmMutation) VarietyName() (r string, exists bool) {
	v := m.varietyName
	if v == nil {
		return
	}
	return *v, true
}

// OldVarietyName returns the old varietyName value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldVarietyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVarietyName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVarietyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVarietyName: %w", err)
	}
	return oldValue.VarietyName, nil
}

// ResetVarietyName reset all changes of the "varietyName" field.
func (m *FarmMutation) ResetVarietyName() {
	m.varietyName = nil
}

// SetDistrictCode sets the districtCode field.
func (m *FarmMutation) SetDistrictCode(s string) {
	m.districtCode = &s
}

// DistrictCode returns the districtCode value in the mutation.
func (m *FarmMutation) DistrictCode() (r string, exists bool) {
	v := m.districtCode
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictCode returns the old districtCode value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldDistrictCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictCode: %w", err)
	}
	return oldValue.DistrictCode, nil
}

// ResetDistrictCode reset all changes of the "districtCode" field.
func (m *FarmMutation) ResetDistrictCode() {
	m.districtCode = nil
}

// SetDistrictName sets the districtName field.
func (m *FarmMutation) SetDistrictName(s string) {
	m.districtName = &s
}

// DistrictName returns the districtName value in the mutation.
func (m *FarmMutation) DistrictName() (r string, exists bool) {
	v := m.districtName
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictName returns the old districtName value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldDistrictName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictName: %w", err)
	}
	return oldValue.DistrictName, nil
}

// ResetDistrictName reset all changes of the "districtName" field.
func (m *FarmMutation) ResetDistrictName() {
	m.districtName = nil
}

// SetTenantId sets the tenantId field.
func (m *FarmMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *FarmMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *FarmMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *FarmMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *FarmMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *FarmMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *FarmMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *FarmMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *FarmMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *FarmMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *FarmMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *FarmMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *FarmMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *FarmMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *FarmMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *FarmMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *FarmMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *FarmMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *FarmMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *FarmMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *FarmMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *FarmMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *FarmMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Farm.
// If the Farm object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FarmMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *FarmMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *FarmMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *FarmMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *FarmMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Farm).
func (m *FarmMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FarmMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.name != nil {
		fields = append(fields, farm.FieldName)
	}
	if m.code != nil {
		fields = append(fields, farm.FieldCode)
	}
	if m.constructionDate != nil {
		fields = append(fields, farm.FieldConstructionDate)
	}
	if m.feedingScale != nil {
		fields = append(fields, farm.FieldFeedingScale)
	}
	if m.contactUser != nil {
		fields = append(fields, farm.FieldContactUser)
	}
	if m.contactPhone != nil {
		fields = append(fields, farm.FieldContactPhone)
	}
	if m.contactAddress != nil {
		fields = append(fields, farm.FieldContactAddress)
	}
	if m.square != nil {
		fields = append(fields, farm.FieldSquare)
	}
	if m.shedCount != nil {
		fields = append(fields, farm.FieldShedCount)
	}
	if m.categoryId != nil {
		fields = append(fields, farm.FieldCategoryId)
	}
	if m.categoryName != nil {
		fields = append(fields, farm.FieldCategoryName)
	}
	if m.varietyId != nil {
		fields = append(fields, farm.FieldVarietyId)
	}
	if m.varietyName != nil {
		fields = append(fields, farm.FieldVarietyName)
	}
	if m.districtCode != nil {
		fields = append(fields, farm.FieldDistrictCode)
	}
	if m.districtName != nil {
		fields = append(fields, farm.FieldDistrictName)
	}
	if m.tenantId != nil {
		fields = append(fields, farm.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, farm.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, farm.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, farm.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, farm.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, farm.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FarmMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case farm.FieldName:
		return m.Name()
	case farm.FieldCode:
		return m.Code()
	case farm.FieldConstructionDate:
		return m.ConstructionDate()
	case farm.FieldFeedingScale:
		return m.FeedingScale()
	case farm.FieldContactUser:
		return m.ContactUser()
	case farm.FieldContactPhone:
		return m.ContactPhone()
	case farm.FieldContactAddress:
		return m.ContactAddress()
	case farm.FieldSquare:
		return m.Square()
	case farm.FieldShedCount:
		return m.ShedCount()
	case farm.FieldCategoryId:
		return m.CategoryId()
	case farm.FieldCategoryName:
		return m.CategoryName()
	case farm.FieldVarietyId:
		return m.VarietyId()
	case farm.FieldVarietyName:
		return m.VarietyName()
	case farm.FieldDistrictCode:
		return m.DistrictCode()
	case farm.FieldDistrictName:
		return m.DistrictName()
	case farm.FieldTenantId:
		return m.TenantId()
	case farm.FieldTenantName:
		return m.TenantName()
	case farm.FieldRemarks:
		return m.Remarks()
	case farm.FieldCreatedAt:
		return m.CreatedAt()
	case farm.FieldUpdatedAt:
		return m.UpdatedAt()
	case farm.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FarmMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case farm.FieldName:
		return m.OldName(ctx)
	case farm.FieldCode:
		return m.OldCode(ctx)
	case farm.FieldConstructionDate:
		return m.OldConstructionDate(ctx)
	case farm.FieldFeedingScale:
		return m.OldFeedingScale(ctx)
	case farm.FieldContactUser:
		return m.OldContactUser(ctx)
	case farm.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case farm.FieldContactAddress:
		return m.OldContactAddress(ctx)
	case farm.FieldSquare:
		return m.OldSquare(ctx)
	case farm.FieldShedCount:
		return m.OldShedCount(ctx)
	case farm.FieldCategoryId:
		return m.OldCategoryId(ctx)
	case farm.FieldCategoryName:
		return m.OldCategoryName(ctx)
	case farm.FieldVarietyId:
		return m.OldVarietyId(ctx)
	case farm.FieldVarietyName:
		return m.OldVarietyName(ctx)
	case farm.FieldDistrictCode:
		return m.OldDistrictCode(ctx)
	case farm.FieldDistrictName:
		return m.OldDistrictName(ctx)
	case farm.FieldTenantId:
		return m.OldTenantId(ctx)
	case farm.FieldTenantName:
		return m.OldTenantName(ctx)
	case farm.FieldRemarks:
		return m.OldRemarks(ctx)
	case farm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case farm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case farm.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Farm field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FarmMutation) SetField(name string, value ent.Value) error {
	switch name {
	case farm.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case farm.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case farm.FieldConstructionDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionDate(v)
		return nil
	case farm.FieldFeedingScale:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedingScale(v)
		return nil
	case farm.FieldContactUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactUser(v)
		return nil
	case farm.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case farm.FieldContactAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactAddress(v)
		return nil
	case farm.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSquare(v)
		return nil
	case farm.FieldShedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedCount(v)
		return nil
	case farm.FieldCategoryId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryId(v)
		return nil
	case farm.FieldCategoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryName(v)
		return nil
	case farm.FieldVarietyId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVarietyId(v)
		return nil
	case farm.FieldVarietyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVarietyName(v)
		return nil
	case farm.FieldDistrictCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictCode(v)
		return nil
	case farm.FieldDistrictName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictName(v)
		return nil
	case farm.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case farm.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case farm.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case farm.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case farm.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case farm.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Farm field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FarmMutation) AddedFields() []string {
	var fields []string
	if m.addfeedingScale != nil {
		fields = append(fields, farm.FieldFeedingScale)
	}
	if m.addsquare != nil {
		fields = append(fields, farm.FieldSquare)
	}
	if m.addshedCount != nil {
		fields = append(fields, farm.FieldShedCount)
	}
	if m.addcategoryId != nil {
		fields = append(fields, farm.FieldCategoryId)
	}
	if m.addvarietyId != nil {
		fields = append(fields, farm.FieldVarietyId)
	}
	if m.addtenantId != nil {
		fields = append(fields, farm.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, farm.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, farm.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, farm.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FarmMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case farm.FieldFeedingScale:
		return m.AddedFeedingScale()
	case farm.FieldSquare:
		return m.AddedSquare()
	case farm.FieldShedCount:
		return m.AddedShedCount()
	case farm.FieldCategoryId:
		return m.AddedCategoryId()
	case farm.FieldVarietyId:
		return m.AddedVarietyId()
	case farm.FieldTenantId:
		return m.AddedTenantId()
	case farm.FieldCreatedAt:
		return m.AddedCreatedAt()
	case farm.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case farm.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FarmMutation) AddField(name string, value ent.Value) error {
	switch name {
	case farm.FieldFeedingScale:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeedingScale(v)
		return nil
	case farm.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSquare(v)
		return nil
	case farm.FieldShedCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedCount(v)
		return nil
	case farm.FieldCategoryId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryId(v)
		return nil
	case farm.FieldVarietyId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVarietyId(v)
		return nil
	case farm.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case farm.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case farm.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case farm.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Farm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FarmMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FarmMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FarmMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Farm nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FarmMutation) ResetField(name string) error {
	switch name {
	case farm.FieldName:
		m.ResetName()
		return nil
	case farm.FieldCode:
		m.ResetCode()
		return nil
	case farm.FieldConstructionDate:
		m.ResetConstructionDate()
		return nil
	case farm.FieldFeedingScale:
		m.ResetFeedingScale()
		return nil
	case farm.FieldContactUser:
		m.ResetContactUser()
		return nil
	case farm.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case farm.FieldContactAddress:
		m.ResetContactAddress()
		return nil
	case farm.FieldSquare:
		m.ResetSquare()
		return nil
	case farm.FieldShedCount:
		m.ResetShedCount()
		return nil
	case farm.FieldCategoryId:
		m.ResetCategoryId()
		return nil
	case farm.FieldCategoryName:
		m.ResetCategoryName()
		return nil
	case farm.FieldVarietyId:
		m.ResetVarietyId()
		return nil
	case farm.FieldVarietyName:
		m.ResetVarietyName()
		return nil
	case farm.FieldDistrictCode:
		m.ResetDistrictCode()
		return nil
	case farm.FieldDistrictName:
		m.ResetDistrictName()
		return nil
	case farm.FieldTenantId:
		m.ResetTenantId()
		return nil
	case farm.FieldTenantName:
		m.ResetTenantName()
		return nil
	case farm.FieldRemarks:
		m.ResetRemarks()
		return nil
	case farm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case farm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case farm.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Farm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FarmMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FarmMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FarmMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FarmMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FarmMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FarmMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FarmMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Farm unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FarmMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Farm edge %s", name)
}

// FeedGroupMutation represents an operation that mutate the FeedGroups
// nodes in the graph.
type FeedGroupMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FeedGroup, error)
}

var _ ent.Mutation = (*FeedGroupMutation)(nil)

// feedgroupOption allows to manage the mutation configuration using functional options.
type feedgroupOption func(*FeedGroupMutation)

// newFeedGroupMutation creates new mutation for $n.Name.
func newFeedGroupMutation(c config, op Op, opts ...feedgroupOption) *FeedGroupMutation {
	m := &FeedGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedGroupID sets the id field of the mutation.
func withFeedGroupID(id int64) feedgroupOption {
	return func(m *FeedGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedGroup
		)
		m.oldValue = func(ctx context.Context) (*FeedGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedGroup sets the old FeedGroup of the mutation.
func withFeedGroup(node *FeedGroup) feedgroupOption {
	return func(m *FeedGroupMutation) {
		m.oldValue = func(context.Context) (*FeedGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FeedGroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *FeedGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FeedGroup).
func (m *FeedGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FeedGroupMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FeedGroupMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FeedGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown FeedGroup field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeedGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeedGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FeedGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FeedGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeedGroupMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown FeedGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FeedGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FeedGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FeedGroupMutation) ResetField(name string) error {
	return fmt.Errorf("unknown FeedGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FeedGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FeedGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FeedGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FeedGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FeedGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FeedGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FeedGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeedGroup unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FeedGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeedGroup edge %s", name)
}

// FeedInfoMutation represents an operation that mutate the FeedInfos
// nodes in the graph.
type FeedInfoMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name              *string
	code              *string
	moisture          *float32
	addmoisture       *float32
	dryMatter         *float32
	adddryMatter      *float32
	ndf               *float32
	addndf            *float32
	adf               *float32
	addadf            *float32
	endf              *float32
	addendf           *float32
	lacticAcid        *float32
	addlacticAcid     *float32
	wsc               *float32
	addwsc            *float32
	starch            *float32
	addstarch         *float32
	solubleFiber      *float32
	addsolubleFiber   *float32
	totalProtein      *float32
	addtotalProtein   *float32
	solubleProtein    *float32
	addsolubleProtein *float32
	rdp               *float32
	addrdp            *float32
	me                *float32
	addme             *float32
	nel               *float32
	addnel            *float32
	crudeFat          *float32
	addcrudeFat       *float32
	totalFttyAcid     *float32
	addtotalFttyAcid  *float32
	ash               *float32
	addash            *float32
	ca                *float32
	addca             *float32
	p                 *float32
	addp              *float32
	mg                *float32
	addmg             *float32
	k                 *float32
	addk              *float32
	mn                *float32
	addmn             *float32
	cu                *float32
	addcu             *float32
	fe                *float32
	addfe             *float32
	zn                *float32
	addzn             *float32
	methionine        *float32
	addmethionine     *float32
	lysine            *float32
	addlysine         *float32
	vitaminA          *float32
	addvitaminA       *float32
	vitaminD3         *float32
	addvitaminD3      *float32
	vitaminE          *float32
	addvitaminE       *float32
	choline           *float32
	addcholine        *float32
	biotin            *float32
	addbiotin         *float32
	description       *string
	tenantId          *int64
	addtenantId       *int64
	tenantName        *string
	farmId            *int64
	addfarmId         *int64
	farmName          *string
	remarks           *string
	createdAt         *int64
	addcreatedAt      *int64
	updatedAt         *int64
	addupdatedAt      *int64
	deleted           *int
	adddeleted        *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*FeedInfo, error)
}

var _ ent.Mutation = (*FeedInfoMutation)(nil)

// feedinfoOption allows to manage the mutation configuration using functional options.
type feedinfoOption func(*FeedInfoMutation)

// newFeedInfoMutation creates new mutation for $n.Name.
func newFeedInfoMutation(c config, op Op, opts ...feedinfoOption) *FeedInfoMutation {
	m := &FeedInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedInfoID sets the id field of the mutation.
func withFeedInfoID(id int64) feedinfoOption {
	return func(m *FeedInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedInfo
		)
		m.oldValue = func(ctx context.Context) (*FeedInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedInfo sets the old FeedInfo of the mutation.
func withFeedInfo(node *FeedInfo) feedinfoOption {
	return func(m *FeedInfoMutation) {
		m.oldValue = func(context.Context) (*FeedInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FeedInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FeedInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FeedInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *FeedInfoMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *FeedInfoMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *FeedInfoMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *FeedInfoMutation) ResetCode() {
	m.code = nil
}

// SetMoisture sets the moisture field.
func (m *FeedInfoMutation) SetMoisture(f float32) {
	m.moisture = &f
	m.addmoisture = nil
}

// Moisture returns the moisture value in the mutation.
func (m *FeedInfoMutation) Moisture() (r float32, exists bool) {
	v := m.moisture
	if v == nil {
		return
	}
	return *v, true
}

// OldMoisture returns the old moisture value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldMoisture(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMoisture is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMoisture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoisture: %w", err)
	}
	return oldValue.Moisture, nil
}

// AddMoisture adds f to moisture.
func (m *FeedInfoMutation) AddMoisture(f float32) {
	if m.addmoisture != nil {
		*m.addmoisture += f
	} else {
		m.addmoisture = &f
	}
}

// AddedMoisture returns the value that was added to the moisture field in this mutation.
func (m *FeedInfoMutation) AddedMoisture() (r float32, exists bool) {
	v := m.addmoisture
	if v == nil {
		return
	}
	return *v, true
}

// ResetMoisture reset all changes of the "moisture" field.
func (m *FeedInfoMutation) ResetMoisture() {
	m.moisture = nil
	m.addmoisture = nil
}

// SetDryMatter sets the dryMatter field.
func (m *FeedInfoMutation) SetDryMatter(f float32) {
	m.dryMatter = &f
	m.adddryMatter = nil
}

// DryMatter returns the dryMatter value in the mutation.
func (m *FeedInfoMutation) DryMatter() (r float32, exists bool) {
	v := m.dryMatter
	if v == nil {
		return
	}
	return *v, true
}

// OldDryMatter returns the old dryMatter value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldDryMatter(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDryMatter is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDryMatter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDryMatter: %w", err)
	}
	return oldValue.DryMatter, nil
}

// AddDryMatter adds f to dryMatter.
func (m *FeedInfoMutation) AddDryMatter(f float32) {
	if m.adddryMatter != nil {
		*m.adddryMatter += f
	} else {
		m.adddryMatter = &f
	}
}

// AddedDryMatter returns the value that was added to the dryMatter field in this mutation.
func (m *FeedInfoMutation) AddedDryMatter() (r float32, exists bool) {
	v := m.adddryMatter
	if v == nil {
		return
	}
	return *v, true
}

// ResetDryMatter reset all changes of the "dryMatter" field.
func (m *FeedInfoMutation) ResetDryMatter() {
	m.dryMatter = nil
	m.adddryMatter = nil
}

// SetNdf sets the ndf field.
func (m *FeedInfoMutation) SetNdf(f float32) {
	m.ndf = &f
	m.addndf = nil
}

// Ndf returns the ndf value in the mutation.
func (m *FeedInfoMutation) Ndf() (r float32, exists bool) {
	v := m.ndf
	if v == nil {
		return
	}
	return *v, true
}

// OldNdf returns the old ndf value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldNdf(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNdf is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNdf: %w", err)
	}
	return oldValue.Ndf, nil
}

// AddNdf adds f to ndf.
func (m *FeedInfoMutation) AddNdf(f float32) {
	if m.addndf != nil {
		*m.addndf += f
	} else {
		m.addndf = &f
	}
}

// AddedNdf returns the value that was added to the ndf field in this mutation.
func (m *FeedInfoMutation) AddedNdf() (r float32, exists bool) {
	v := m.addndf
	if v == nil {
		return
	}
	return *v, true
}

// ResetNdf reset all changes of the "ndf" field.
func (m *FeedInfoMutation) ResetNdf() {
	m.ndf = nil
	m.addndf = nil
}

// SetAdf sets the adf field.
func (m *FeedInfoMutation) SetAdf(f float32) {
	m.adf = &f
	m.addadf = nil
}

// Adf returns the adf value in the mutation.
func (m *FeedInfoMutation) Adf() (r float32, exists bool) {
	v := m.adf
	if v == nil {
		return
	}
	return *v, true
}

// OldAdf returns the old adf value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldAdf(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdf is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdf: %w", err)
	}
	return oldValue.Adf, nil
}

// AddAdf adds f to adf.
func (m *FeedInfoMutation) AddAdf(f float32) {
	if m.addadf != nil {
		*m.addadf += f
	} else {
		m.addadf = &f
	}
}

// AddedAdf returns the value that was added to the adf field in this mutation.
func (m *FeedInfoMutation) AddedAdf() (r float32, exists bool) {
	v := m.addadf
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdf reset all changes of the "adf" field.
func (m *FeedInfoMutation) ResetAdf() {
	m.adf = nil
	m.addadf = nil
}

// SetEndf sets the endf field.
func (m *FeedInfoMutation) SetEndf(f float32) {
	m.endf = &f
	m.addendf = nil
}

// Endf returns the endf value in the mutation.
func (m *FeedInfoMutation) Endf() (r float32, exists bool) {
	v := m.endf
	if v == nil {
		return
	}
	return *v, true
}

// OldEndf returns the old endf value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldEndf(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndf is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndf: %w", err)
	}
	return oldValue.Endf, nil
}

// AddEndf adds f to endf.
func (m *FeedInfoMutation) AddEndf(f float32) {
	if m.addendf != nil {
		*m.addendf += f
	} else {
		m.addendf = &f
	}
}

// AddedEndf returns the value that was added to the endf field in this mutation.
func (m *FeedInfoMutation) AddedEndf() (r float32, exists bool) {
	v := m.addendf
	if v == nil {
		return
	}
	return *v, true
}

// ResetEndf reset all changes of the "endf" field.
func (m *FeedInfoMutation) ResetEndf() {
	m.endf = nil
	m.addendf = nil
}

// SetLacticAcid sets the lacticAcid field.
func (m *FeedInfoMutation) SetLacticAcid(f float32) {
	m.lacticAcid = &f
	m.addlacticAcid = nil
}

// LacticAcid returns the lacticAcid value in the mutation.
func (m *FeedInfoMutation) LacticAcid() (r float32, exists bool) {
	v := m.lacticAcid
	if v == nil {
		return
	}
	return *v, true
}

// OldLacticAcid returns the old lacticAcid value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldLacticAcid(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLacticAcid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLacticAcid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLacticAcid: %w", err)
	}
	return oldValue.LacticAcid, nil
}

// AddLacticAcid adds f to lacticAcid.
func (m *FeedInfoMutation) AddLacticAcid(f float32) {
	if m.addlacticAcid != nil {
		*m.addlacticAcid += f
	} else {
		m.addlacticAcid = &f
	}
}

// AddedLacticAcid returns the value that was added to the lacticAcid field in this mutation.
func (m *FeedInfoMutation) AddedLacticAcid() (r float32, exists bool) {
	v := m.addlacticAcid
	if v == nil {
		return
	}
	return *v, true
}

// ResetLacticAcid reset all changes of the "lacticAcid" field.
func (m *FeedInfoMutation) ResetLacticAcid() {
	m.lacticAcid = nil
	m.addlacticAcid = nil
}

// SetWsc sets the wsc field.
func (m *FeedInfoMutation) SetWsc(f float32) {
	m.wsc = &f
	m.addwsc = nil
}

// Wsc returns the wsc value in the mutation.
func (m *FeedInfoMutation) Wsc() (r float32, exists bool) {
	v := m.wsc
	if v == nil {
		return
	}
	return *v, true
}

// OldWsc returns the old wsc value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldWsc(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWsc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWsc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWsc: %w", err)
	}
	return oldValue.Wsc, nil
}

// AddWsc adds f to wsc.
func (m *FeedInfoMutation) AddWsc(f float32) {
	if m.addwsc != nil {
		*m.addwsc += f
	} else {
		m.addwsc = &f
	}
}

// AddedWsc returns the value that was added to the wsc field in this mutation.
func (m *FeedInfoMutation) AddedWsc() (r float32, exists bool) {
	v := m.addwsc
	if v == nil {
		return
	}
	return *v, true
}

// ResetWsc reset all changes of the "wsc" field.
func (m *FeedInfoMutation) ResetWsc() {
	m.wsc = nil
	m.addwsc = nil
}

// SetStarch sets the starch field.
func (m *FeedInfoMutation) SetStarch(f float32) {
	m.starch = &f
	m.addstarch = nil
}

// Starch returns the starch value in the mutation.
func (m *FeedInfoMutation) Starch() (r float32, exists bool) {
	v := m.starch
	if v == nil {
		return
	}
	return *v, true
}

// OldStarch returns the old starch value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldStarch(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStarch is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStarch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarch: %w", err)
	}
	return oldValue.Starch, nil
}

// AddStarch adds f to starch.
func (m *FeedInfoMutation) AddStarch(f float32) {
	if m.addstarch != nil {
		*m.addstarch += f
	} else {
		m.addstarch = &f
	}
}

// AddedStarch returns the value that was added to the starch field in this mutation.
func (m *FeedInfoMutation) AddedStarch() (r float32, exists bool) {
	v := m.addstarch
	if v == nil {
		return
	}
	return *v, true
}

// ResetStarch reset all changes of the "starch" field.
func (m *FeedInfoMutation) ResetStarch() {
	m.starch = nil
	m.addstarch = nil
}

// SetSolubleFiber sets the solubleFiber field.
func (m *FeedInfoMutation) SetSolubleFiber(f float32) {
	m.solubleFiber = &f
	m.addsolubleFiber = nil
}

// SolubleFiber returns the solubleFiber value in the mutation.
func (m *FeedInfoMutation) SolubleFiber() (r float32, exists bool) {
	v := m.solubleFiber
	if v == nil {
		return
	}
	return *v, true
}

// OldSolubleFiber returns the old solubleFiber value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldSolubleFiber(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSolubleFiber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSolubleFiber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSolubleFiber: %w", err)
	}
	return oldValue.SolubleFiber, nil
}

// AddSolubleFiber adds f to solubleFiber.
func (m *FeedInfoMutation) AddSolubleFiber(f float32) {
	if m.addsolubleFiber != nil {
		*m.addsolubleFiber += f
	} else {
		m.addsolubleFiber = &f
	}
}

// AddedSolubleFiber returns the value that was added to the solubleFiber field in this mutation.
func (m *FeedInfoMutation) AddedSolubleFiber() (r float32, exists bool) {
	v := m.addsolubleFiber
	if v == nil {
		return
	}
	return *v, true
}

// ResetSolubleFiber reset all changes of the "solubleFiber" field.
func (m *FeedInfoMutation) ResetSolubleFiber() {
	m.solubleFiber = nil
	m.addsolubleFiber = nil
}

// SetTotalProtein sets the totalProtein field.
func (m *FeedInfoMutation) SetTotalProtein(f float32) {
	m.totalProtein = &f
	m.addtotalProtein = nil
}

// TotalProtein returns the totalProtein value in the mutation.
func (m *FeedInfoMutation) TotalProtein() (r float32, exists bool) {
	v := m.totalProtein
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalProtein returns the old totalProtein value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldTotalProtein(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalProtein is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalProtein requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalProtein: %w", err)
	}
	return oldValue.TotalProtein, nil
}

// AddTotalProtein adds f to totalProtein.
func (m *FeedInfoMutation) AddTotalProtein(f float32) {
	if m.addtotalProtein != nil {
		*m.addtotalProtein += f
	} else {
		m.addtotalProtein = &f
	}
}

// AddedTotalProtein returns the value that was added to the totalProtein field in this mutation.
func (m *FeedInfoMutation) AddedTotalProtein() (r float32, exists bool) {
	v := m.addtotalProtein
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalProtein reset all changes of the "totalProtein" field.
func (m *FeedInfoMutation) ResetTotalProtein() {
	m.totalProtein = nil
	m.addtotalProtein = nil
}

// SetSolubleProtein sets the solubleProtein field.
func (m *FeedInfoMutation) SetSolubleProtein(f float32) {
	m.solubleProtein = &f
	m.addsolubleProtein = nil
}

// SolubleProtein returns the solubleProtein value in the mutation.
func (m *FeedInfoMutation) SolubleProtein() (r float32, exists bool) {
	v := m.solubleProtein
	if v == nil {
		return
	}
	return *v, true
}

// OldSolubleProtein returns the old solubleProtein value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldSolubleProtein(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSolubleProtein is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSolubleProtein requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSolubleProtein: %w", err)
	}
	return oldValue.SolubleProtein, nil
}

// AddSolubleProtein adds f to solubleProtein.
func (m *FeedInfoMutation) AddSolubleProtein(f float32) {
	if m.addsolubleProtein != nil {
		*m.addsolubleProtein += f
	} else {
		m.addsolubleProtein = &f
	}
}

// AddedSolubleProtein returns the value that was added to the solubleProtein field in this mutation.
func (m *FeedInfoMutation) AddedSolubleProtein() (r float32, exists bool) {
	v := m.addsolubleProtein
	if v == nil {
		return
	}
	return *v, true
}

// ResetSolubleProtein reset all changes of the "solubleProtein" field.
func (m *FeedInfoMutation) ResetSolubleProtein() {
	m.solubleProtein = nil
	m.addsolubleProtein = nil
}

// SetRdp sets the rdp field.
func (m *FeedInfoMutation) SetRdp(f float32) {
	m.rdp = &f
	m.addrdp = nil
}

// Rdp returns the rdp value in the mutation.
func (m *FeedInfoMutation) Rdp() (r float32, exists bool) {
	v := m.rdp
	if v == nil {
		return
	}
	return *v, true
}

// OldRdp returns the old rdp value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldRdp(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRdp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRdp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRdp: %w", err)
	}
	return oldValue.Rdp, nil
}

// AddRdp adds f to rdp.
func (m *FeedInfoMutation) AddRdp(f float32) {
	if m.addrdp != nil {
		*m.addrdp += f
	} else {
		m.addrdp = &f
	}
}

// AddedRdp returns the value that was added to the rdp field in this mutation.
func (m *FeedInfoMutation) AddedRdp() (r float32, exists bool) {
	v := m.addrdp
	if v == nil {
		return
	}
	return *v, true
}

// ResetRdp reset all changes of the "rdp" field.
func (m *FeedInfoMutation) ResetRdp() {
	m.rdp = nil
	m.addrdp = nil
}

// SetMe sets the me field.
func (m *FeedInfoMutation) SetMe(f float32) {
	m.me = &f
	m.addme = nil
}

// Me returns the me value in the mutation.
func (m *FeedInfoMutation) Me() (r float32, exists bool) {
	v := m.me
	if v == nil {
		return
	}
	return *v, true
}

// OldMe returns the old me value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldMe(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMe is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMe: %w", err)
	}
	return oldValue.Me, nil
}

// AddMe adds f to me.
func (m *FeedInfoMutation) AddMe(f float32) {
	if m.addme != nil {
		*m.addme += f
	} else {
		m.addme = &f
	}
}

// AddedMe returns the value that was added to the me field in this mutation.
func (m *FeedInfoMutation) AddedMe() (r float32, exists bool) {
	v := m.addme
	if v == nil {
		return
	}
	return *v, true
}

// ResetMe reset all changes of the "me" field.
func (m *FeedInfoMutation) ResetMe() {
	m.me = nil
	m.addme = nil
}

// SetNel sets the nel field.
func (m *FeedInfoMutation) SetNel(f float32) {
	m.nel = &f
	m.addnel = nil
}

// Nel returns the nel value in the mutation.
func (m *FeedInfoMutation) Nel() (r float32, exists bool) {
	v := m.nel
	if v == nil {
		return
	}
	return *v, true
}

// OldNel returns the old nel value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldNel(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNel: %w", err)
	}
	return oldValue.Nel, nil
}

// AddNel adds f to nel.
func (m *FeedInfoMutation) AddNel(f float32) {
	if m.addnel != nil {
		*m.addnel += f
	} else {
		m.addnel = &f
	}
}

// AddedNel returns the value that was added to the nel field in this mutation.
func (m *FeedInfoMutation) AddedNel() (r float32, exists bool) {
	v := m.addnel
	if v == nil {
		return
	}
	return *v, true
}

// ResetNel reset all changes of the "nel" field.
func (m *FeedInfoMutation) ResetNel() {
	m.nel = nil
	m.addnel = nil
}

// SetCrudeFat sets the crudeFat field.
func (m *FeedInfoMutation) SetCrudeFat(f float32) {
	m.crudeFat = &f
	m.addcrudeFat = nil
}

// CrudeFat returns the crudeFat value in the mutation.
func (m *FeedInfoMutation) CrudeFat() (r float32, exists bool) {
	v := m.crudeFat
	if v == nil {
		return
	}
	return *v, true
}

// OldCrudeFat returns the old crudeFat value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldCrudeFat(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCrudeFat is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCrudeFat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrudeFat: %w", err)
	}
	return oldValue.CrudeFat, nil
}

// AddCrudeFat adds f to crudeFat.
func (m *FeedInfoMutation) AddCrudeFat(f float32) {
	if m.addcrudeFat != nil {
		*m.addcrudeFat += f
	} else {
		m.addcrudeFat = &f
	}
}

// AddedCrudeFat returns the value that was added to the crudeFat field in this mutation.
func (m *FeedInfoMutation) AddedCrudeFat() (r float32, exists bool) {
	v := m.addcrudeFat
	if v == nil {
		return
	}
	return *v, true
}

// ResetCrudeFat reset all changes of the "crudeFat" field.
func (m *FeedInfoMutation) ResetCrudeFat() {
	m.crudeFat = nil
	m.addcrudeFat = nil
}

// SetTotalFttyAcid sets the totalFttyAcid field.
func (m *FeedInfoMutation) SetTotalFttyAcid(f float32) {
	m.totalFttyAcid = &f
	m.addtotalFttyAcid = nil
}

// TotalFttyAcid returns the totalFttyAcid value in the mutation.
func (m *FeedInfoMutation) TotalFttyAcid() (r float32, exists bool) {
	v := m.totalFttyAcid
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalFttyAcid returns the old totalFttyAcid value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldTotalFttyAcid(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalFttyAcid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalFttyAcid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalFttyAcid: %w", err)
	}
	return oldValue.TotalFttyAcid, nil
}

// AddTotalFttyAcid adds f to totalFttyAcid.
func (m *FeedInfoMutation) AddTotalFttyAcid(f float32) {
	if m.addtotalFttyAcid != nil {
		*m.addtotalFttyAcid += f
	} else {
		m.addtotalFttyAcid = &f
	}
}

// AddedTotalFttyAcid returns the value that was added to the totalFttyAcid field in this mutation.
func (m *FeedInfoMutation) AddedTotalFttyAcid() (r float32, exists bool) {
	v := m.addtotalFttyAcid
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalFttyAcid reset all changes of the "totalFttyAcid" field.
func (m *FeedInfoMutation) ResetTotalFttyAcid() {
	m.totalFttyAcid = nil
	m.addtotalFttyAcid = nil
}

// SetAsh sets the ash field.
func (m *FeedInfoMutation) SetAsh(f float32) {
	m.ash = &f
	m.addash = nil
}

// Ash returns the ash value in the mutation.
func (m *FeedInfoMutation) Ash() (r float32, exists bool) {
	v := m.ash
	if v == nil {
		return
	}
	return *v, true
}

// OldAsh returns the old ash value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldAsh(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAsh is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAsh requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAsh: %w", err)
	}
	return oldValue.Ash, nil
}

// AddAsh adds f to ash.
func (m *FeedInfoMutation) AddAsh(f float32) {
	if m.addash != nil {
		*m.addash += f
	} else {
		m.addash = &f
	}
}

// AddedAsh returns the value that was added to the ash field in this mutation.
func (m *FeedInfoMutation) AddedAsh() (r float32, exists bool) {
	v := m.addash
	if v == nil {
		return
	}
	return *v, true
}

// ResetAsh reset all changes of the "ash" field.
func (m *FeedInfoMutation) ResetAsh() {
	m.ash = nil
	m.addash = nil
}

// SetCa sets the ca field.
func (m *FeedInfoMutation) SetCa(f float32) {
	m.ca = &f
	m.addca = nil
}

// Ca returns the ca value in the mutation.
func (m *FeedInfoMutation) Ca() (r float32, exists bool) {
	v := m.ca
	if v == nil {
		return
	}
	return *v, true
}

// OldCa returns the old ca value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldCa(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCa is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCa: %w", err)
	}
	return oldValue.Ca, nil
}

// AddCa adds f to ca.
func (m *FeedInfoMutation) AddCa(f float32) {
	if m.addca != nil {
		*m.addca += f
	} else {
		m.addca = &f
	}
}

// AddedCa returns the value that was added to the ca field in this mutation.
func (m *FeedInfoMutation) AddedCa() (r float32, exists bool) {
	v := m.addca
	if v == nil {
		return
	}
	return *v, true
}

// ResetCa reset all changes of the "ca" field.
func (m *FeedInfoMutation) ResetCa() {
	m.ca = nil
	m.addca = nil
}

// SetP sets the p field.
func (m *FeedInfoMutation) SetP(f float32) {
	m.p = &f
	m.addp = nil
}

// P returns the p value in the mutation.
func (m *FeedInfoMutation) P() (r float32, exists bool) {
	v := m.p
	if v == nil {
		return
	}
	return *v, true
}

// OldP returns the old p value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldP(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldP is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldP: %w", err)
	}
	return oldValue.P, nil
}

// AddP adds f to p.
func (m *FeedInfoMutation) AddP(f float32) {
	if m.addp != nil {
		*m.addp += f
	} else {
		m.addp = &f
	}
}

// AddedP returns the value that was added to the p field in this mutation.
func (m *FeedInfoMutation) AddedP() (r float32, exists bool) {
	v := m.addp
	if v == nil {
		return
	}
	return *v, true
}

// ResetP reset all changes of the "p" field.
func (m *FeedInfoMutation) ResetP() {
	m.p = nil
	m.addp = nil
}

// SetMg sets the mg field.
func (m *FeedInfoMutation) SetMg(f float32) {
	m.mg = &f
	m.addmg = nil
}

// Mg returns the mg value in the mutation.
func (m *FeedInfoMutation) Mg() (r float32, exists bool) {
	v := m.mg
	if v == nil {
		return
	}
	return *v, true
}

// OldMg returns the old mg value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldMg(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMg is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMg: %w", err)
	}
	return oldValue.Mg, nil
}

// AddMg adds f to mg.
func (m *FeedInfoMutation) AddMg(f float32) {
	if m.addmg != nil {
		*m.addmg += f
	} else {
		m.addmg = &f
	}
}

// AddedMg returns the value that was added to the mg field in this mutation.
func (m *FeedInfoMutation) AddedMg() (r float32, exists bool) {
	v := m.addmg
	if v == nil {
		return
	}
	return *v, true
}

// ResetMg reset all changes of the "mg" field.
func (m *FeedInfoMutation) ResetMg() {
	m.mg = nil
	m.addmg = nil
}

// SetK sets the k field.
func (m *FeedInfoMutation) SetK(f float32) {
	m.k = &f
	m.addk = nil
}

// K returns the k value in the mutation.
func (m *FeedInfoMutation) K() (r float32, exists bool) {
	v := m.k
	if v == nil {
		return
	}
	return *v, true
}

// OldK returns the old k value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldK(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldK is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldK requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK: %w", err)
	}
	return oldValue.K, nil
}

// AddK adds f to k.
func (m *FeedInfoMutation) AddK(f float32) {
	if m.addk != nil {
		*m.addk += f
	} else {
		m.addk = &f
	}
}

// AddedK returns the value that was added to the k field in this mutation.
func (m *FeedInfoMutation) AddedK() (r float32, exists bool) {
	v := m.addk
	if v == nil {
		return
	}
	return *v, true
}

// ResetK reset all changes of the "k" field.
func (m *FeedInfoMutation) ResetK() {
	m.k = nil
	m.addk = nil
}

// SetMn sets the mn field.
func (m *FeedInfoMutation) SetMn(f float32) {
	m.mn = &f
	m.addmn = nil
}

// Mn returns the mn value in the mutation.
func (m *FeedInfoMutation) Mn() (r float32, exists bool) {
	v := m.mn
	if v == nil {
		return
	}
	return *v, true
}

// OldMn returns the old mn value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldMn(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMn: %w", err)
	}
	return oldValue.Mn, nil
}

// AddMn adds f to mn.
func (m *FeedInfoMutation) AddMn(f float32) {
	if m.addmn != nil {
		*m.addmn += f
	} else {
		m.addmn = &f
	}
}

// AddedMn returns the value that was added to the mn field in this mutation.
func (m *FeedInfoMutation) AddedMn() (r float32, exists bool) {
	v := m.addmn
	if v == nil {
		return
	}
	return *v, true
}

// ResetMn reset all changes of the "mn" field.
func (m *FeedInfoMutation) ResetMn() {
	m.mn = nil
	m.addmn = nil
}

// SetCu sets the cu field.
func (m *FeedInfoMutation) SetCu(f float32) {
	m.cu = &f
	m.addcu = nil
}

// Cu returns the cu value in the mutation.
func (m *FeedInfoMutation) Cu() (r float32, exists bool) {
	v := m.cu
	if v == nil {
		return
	}
	return *v, true
}

// OldCu returns the old cu value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldCu(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCu is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCu requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCu: %w", err)
	}
	return oldValue.Cu, nil
}

// AddCu adds f to cu.
func (m *FeedInfoMutation) AddCu(f float32) {
	if m.addcu != nil {
		*m.addcu += f
	} else {
		m.addcu = &f
	}
}

// AddedCu returns the value that was added to the cu field in this mutation.
func (m *FeedInfoMutation) AddedCu() (r float32, exists bool) {
	v := m.addcu
	if v == nil {
		return
	}
	return *v, true
}

// ResetCu reset all changes of the "cu" field.
func (m *FeedInfoMutation) ResetCu() {
	m.cu = nil
	m.addcu = nil
}

// SetFe sets the fe field.
func (m *FeedInfoMutation) SetFe(f float32) {
	m.fe = &f
	m.addfe = nil
}

// Fe returns the fe value in the mutation.
func (m *FeedInfoMutation) Fe() (r float32, exists bool) {
	v := m.fe
	if v == nil {
		return
	}
	return *v, true
}

// OldFe returns the old fe value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldFe(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFe is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFe: %w", err)
	}
	return oldValue.Fe, nil
}

// AddFe adds f to fe.
func (m *FeedInfoMutation) AddFe(f float32) {
	if m.addfe != nil {
		*m.addfe += f
	} else {
		m.addfe = &f
	}
}

// AddedFe returns the value that was added to the fe field in this mutation.
func (m *FeedInfoMutation) AddedFe() (r float32, exists bool) {
	v := m.addfe
	if v == nil {
		return
	}
	return *v, true
}

// ResetFe reset all changes of the "fe" field.
func (m *FeedInfoMutation) ResetFe() {
	m.fe = nil
	m.addfe = nil
}

// SetZn sets the zn field.
func (m *FeedInfoMutation) SetZn(f float32) {
	m.zn = &f
	m.addzn = nil
}

// Zn returns the zn value in the mutation.
func (m *FeedInfoMutation) Zn() (r float32, exists bool) {
	v := m.zn
	if v == nil {
		return
	}
	return *v, true
}

// OldZn returns the old zn value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldZn(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZn is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZn: %w", err)
	}
	return oldValue.Zn, nil
}

// AddZn adds f to zn.
func (m *FeedInfoMutation) AddZn(f float32) {
	if m.addzn != nil {
		*m.addzn += f
	} else {
		m.addzn = &f
	}
}

// AddedZn returns the value that was added to the zn field in this mutation.
func (m *FeedInfoMutation) AddedZn() (r float32, exists bool) {
	v := m.addzn
	if v == nil {
		return
	}
	return *v, true
}

// ResetZn reset all changes of the "zn" field.
func (m *FeedInfoMutation) ResetZn() {
	m.zn = nil
	m.addzn = nil
}

// SetMethionine sets the methionine field.
func (m *FeedInfoMutation) SetMethionine(f float32) {
	m.methionine = &f
	m.addmethionine = nil
}

// Methionine returns the methionine value in the mutation.
func (m *FeedInfoMutation) Methionine() (r float32, exists bool) {
	v := m.methionine
	if v == nil {
		return
	}
	return *v, true
}

// OldMethionine returns the old methionine value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldMethionine(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethionine is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethionine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethionine: %w", err)
	}
	return oldValue.Methionine, nil
}

// AddMethionine adds f to methionine.
func (m *FeedInfoMutation) AddMethionine(f float32) {
	if m.addmethionine != nil {
		*m.addmethionine += f
	} else {
		m.addmethionine = &f
	}
}

// AddedMethionine returns the value that was added to the methionine field in this mutation.
func (m *FeedInfoMutation) AddedMethionine() (r float32, exists bool) {
	v := m.addmethionine
	if v == nil {
		return
	}
	return *v, true
}

// ResetMethionine reset all changes of the "methionine" field.
func (m *FeedInfoMutation) ResetMethionine() {
	m.methionine = nil
	m.addmethionine = nil
}

// SetLysine sets the lysine field.
func (m *FeedInfoMutation) SetLysine(f float32) {
	m.lysine = &f
	m.addlysine = nil
}

// Lysine returns the lysine value in the mutation.
func (m *FeedInfoMutation) Lysine() (r float32, exists bool) {
	v := m.lysine
	if v == nil {
		return
	}
	return *v, true
}

// OldLysine returns the old lysine value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldLysine(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLysine is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLysine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLysine: %w", err)
	}
	return oldValue.Lysine, nil
}

// AddLysine adds f to lysine.
func (m *FeedInfoMutation) AddLysine(f float32) {
	if m.addlysine != nil {
		*m.addlysine += f
	} else {
		m.addlysine = &f
	}
}

// AddedLysine returns the value that was added to the lysine field in this mutation.
func (m *FeedInfoMutation) AddedLysine() (r float32, exists bool) {
	v := m.addlysine
	if v == nil {
		return
	}
	return *v, true
}

// ResetLysine reset all changes of the "lysine" field.
func (m *FeedInfoMutation) ResetLysine() {
	m.lysine = nil
	m.addlysine = nil
}

// SetVitaminA sets the vitaminA field.
func (m *FeedInfoMutation) SetVitaminA(f float32) {
	m.vitaminA = &f
	m.addvitaminA = nil
}

// VitaminA returns the vitaminA value in the mutation.
func (m *FeedInfoMutation) VitaminA() (r float32, exists bool) {
	v := m.vitaminA
	if v == nil {
		return
	}
	return *v, true
}

// OldVitaminA returns the old vitaminA value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldVitaminA(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVitaminA is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVitaminA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVitaminA: %w", err)
	}
	return oldValue.VitaminA, nil
}

// AddVitaminA adds f to vitaminA.
func (m *FeedInfoMutation) AddVitaminA(f float32) {
	if m.addvitaminA != nil {
		*m.addvitaminA += f
	} else {
		m.addvitaminA = &f
	}
}

// AddedVitaminA returns the value that was added to the vitaminA field in this mutation.
func (m *FeedInfoMutation) AddedVitaminA() (r float32, exists bool) {
	v := m.addvitaminA
	if v == nil {
		return
	}
	return *v, true
}

// ResetVitaminA reset all changes of the "vitaminA" field.
func (m *FeedInfoMutation) ResetVitaminA() {
	m.vitaminA = nil
	m.addvitaminA = nil
}

// SetVitaminD3 sets the vitaminD3 field.
func (m *FeedInfoMutation) SetVitaminD3(f float32) {
	m.vitaminD3 = &f
	m.addvitaminD3 = nil
}

// VitaminD3 returns the vitaminD3 value in the mutation.
func (m *FeedInfoMutation) VitaminD3() (r float32, exists bool) {
	v := m.vitaminD3
	if v == nil {
		return
	}
	return *v, true
}

// OldVitaminD3 returns the old vitaminD3 value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldVitaminD3(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVitaminD3 is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVitaminD3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVitaminD3: %w", err)
	}
	return oldValue.VitaminD3, nil
}

// AddVitaminD3 adds f to vitaminD3.
func (m *FeedInfoMutation) AddVitaminD3(f float32) {
	if m.addvitaminD3 != nil {
		*m.addvitaminD3 += f
	} else {
		m.addvitaminD3 = &f
	}
}

// AddedVitaminD3 returns the value that was added to the vitaminD3 field in this mutation.
func (m *FeedInfoMutation) AddedVitaminD3() (r float32, exists bool) {
	v := m.addvitaminD3
	if v == nil {
		return
	}
	return *v, true
}

// ResetVitaminD3 reset all changes of the "vitaminD3" field.
func (m *FeedInfoMutation) ResetVitaminD3() {
	m.vitaminD3 = nil
	m.addvitaminD3 = nil
}

// SetVitaminE sets the vitaminE field.
func (m *FeedInfoMutation) SetVitaminE(f float32) {
	m.vitaminE = &f
	m.addvitaminE = nil
}

// VitaminE returns the vitaminE value in the mutation.
func (m *FeedInfoMutation) VitaminE() (r float32, exists bool) {
	v := m.vitaminE
	if v == nil {
		return
	}
	return *v, true
}

// OldVitaminE returns the old vitaminE value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldVitaminE(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVitaminE is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVitaminE requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVitaminE: %w", err)
	}
	return oldValue.VitaminE, nil
}

// AddVitaminE adds f to vitaminE.
func (m *FeedInfoMutation) AddVitaminE(f float32) {
	if m.addvitaminE != nil {
		*m.addvitaminE += f
	} else {
		m.addvitaminE = &f
	}
}

// AddedVitaminE returns the value that was added to the vitaminE field in this mutation.
func (m *FeedInfoMutation) AddedVitaminE() (r float32, exists bool) {
	v := m.addvitaminE
	if v == nil {
		return
	}
	return *v, true
}

// ResetVitaminE reset all changes of the "vitaminE" field.
func (m *FeedInfoMutation) ResetVitaminE() {
	m.vitaminE = nil
	m.addvitaminE = nil
}

// SetCholine sets the choline field.
func (m *FeedInfoMutation) SetCholine(f float32) {
	m.choline = &f
	m.addcholine = nil
}

// Choline returns the choline value in the mutation.
func (m *FeedInfoMutation) Choline() (r float32, exists bool) {
	v := m.choline
	if v == nil {
		return
	}
	return *v, true
}

// OldCholine returns the old choline value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldCholine(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCholine is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCholine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCholine: %w", err)
	}
	return oldValue.Choline, nil
}

// AddCholine adds f to choline.
func (m *FeedInfoMutation) AddCholine(f float32) {
	if m.addcholine != nil {
		*m.addcholine += f
	} else {
		m.addcholine = &f
	}
}

// AddedCholine returns the value that was added to the choline field in this mutation.
func (m *FeedInfoMutation) AddedCholine() (r float32, exists bool) {
	v := m.addcholine
	if v == nil {
		return
	}
	return *v, true
}

// ResetCholine reset all changes of the "choline" field.
func (m *FeedInfoMutation) ResetCholine() {
	m.choline = nil
	m.addcholine = nil
}

// SetBiotin sets the biotin field.
func (m *FeedInfoMutation) SetBiotin(f float32) {
	m.biotin = &f
	m.addbiotin = nil
}

// Biotin returns the biotin value in the mutation.
func (m *FeedInfoMutation) Biotin() (r float32, exists bool) {
	v := m.biotin
	if v == nil {
		return
	}
	return *v, true
}

// OldBiotin returns the old biotin value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldBiotin(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBiotin is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBiotin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiotin: %w", err)
	}
	return oldValue.Biotin, nil
}

// AddBiotin adds f to biotin.
func (m *FeedInfoMutation) AddBiotin(f float32) {
	if m.addbiotin != nil {
		*m.addbiotin += f
	} else {
		m.addbiotin = &f
	}
}

// AddedBiotin returns the value that was added to the biotin field in this mutation.
func (m *FeedInfoMutation) AddedBiotin() (r float32, exists bool) {
	v := m.addbiotin
	if v == nil {
		return
	}
	return *v, true
}

// ResetBiotin reset all changes of the "biotin" field.
func (m *FeedInfoMutation) ResetBiotin() {
	m.biotin = nil
	m.addbiotin = nil
}

// SetDescription sets the description field.
func (m *FeedInfoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *FeedInfoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old description value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of description.
func (m *FeedInfoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feedinfo.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the field description was cleared in this mutation.
func (m *FeedInfoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldDescription]
	return ok
}

// ResetDescription reset all changes of the "description" field.
func (m *FeedInfoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feedinfo.FieldDescription)
}

// SetTenantId sets the tenantId field.
func (m *FeedInfoMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *FeedInfoMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *FeedInfoMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *FeedInfoMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantId clears the value of tenantId.
func (m *FeedInfoMutation) ClearTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
	m.clearedFields[feedinfo.FieldTenantId] = struct{}{}
}

// TenantIdCleared returns if the field tenantId was cleared in this mutation.
func (m *FeedInfoMutation) TenantIdCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldTenantId]
	return ok
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *FeedInfoMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
	delete(m.clearedFields, feedinfo.FieldTenantId)
}

// SetTenantName sets the tenantName field.
func (m *FeedInfoMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *FeedInfoMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ClearTenantName clears the value of tenantName.
func (m *FeedInfoMutation) ClearTenantName() {
	m.tenantName = nil
	m.clearedFields[feedinfo.FieldTenantName] = struct{}{}
}

// TenantNameCleared returns if the field tenantName was cleared in this mutation.
func (m *FeedInfoMutation) TenantNameCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldTenantName]
	return ok
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *FeedInfoMutation) ResetTenantName() {
	m.tenantName = nil
	delete(m.clearedFields, feedinfo.FieldTenantName)
}

// SetFarmId sets the farmId field.
func (m *FeedInfoMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *FeedInfoMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *FeedInfoMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *FeedInfoMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ClearFarmId clears the value of farmId.
func (m *FeedInfoMutation) ClearFarmId() {
	m.farmId = nil
	m.addfarmId = nil
	m.clearedFields[feedinfo.FieldFarmId] = struct{}{}
}

// FarmIdCleared returns if the field farmId was cleared in this mutation.
func (m *FeedInfoMutation) FarmIdCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldFarmId]
	return ok
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *FeedInfoMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
	delete(m.clearedFields, feedinfo.FieldFarmId)
}

// SetFarmName sets the farmName field.
func (m *FeedInfoMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *FeedInfoMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ClearFarmName clears the value of farmName.
func (m *FeedInfoMutation) ClearFarmName() {
	m.farmName = nil
	m.clearedFields[feedinfo.FieldFarmName] = struct{}{}
}

// FarmNameCleared returns if the field farmName was cleared in this mutation.
func (m *FeedInfoMutation) FarmNameCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldFarmName]
	return ok
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *FeedInfoMutation) ResetFarmName() {
	m.farmName = nil
	delete(m.clearedFields, feedinfo.FieldFarmName)
}

// SetRemarks sets the remarks field.
func (m *FeedInfoMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *FeedInfoMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of remarks.
func (m *FeedInfoMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[feedinfo.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the field remarks was cleared in this mutation.
func (m *FeedInfoMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldRemarks]
	return ok
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *FeedInfoMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, feedinfo.FieldRemarks)
}

// SetCreatedAt sets the createdAt field.
func (m *FeedInfoMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *FeedInfoMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *FeedInfoMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *FeedInfoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedAt clears the value of createdAt.
func (m *FeedInfoMutation) ClearCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
	m.clearedFields[feedinfo.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field createdAt was cleared in this mutation.
func (m *FeedInfoMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *FeedInfoMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
	delete(m.clearedFields, feedinfo.FieldCreatedAt)
}

// SetUpdatedAt sets the updatedAt field.
func (m *FeedInfoMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *FeedInfoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *FeedInfoMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *FeedInfoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedAt clears the value of updatedAt.
func (m *FeedInfoMutation) ClearUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
	m.clearedFields[feedinfo.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updatedAt was cleared in this mutation.
func (m *FeedInfoMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *FeedInfoMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
	delete(m.clearedFields, feedinfo.FieldUpdatedAt)
}

// SetDeleted sets the deleted field.
func (m *FeedInfoMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *FeedInfoMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the FeedInfo.
// If the FeedInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedInfoMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *FeedInfoMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *FeedInfoMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleted clears the value of deleted.
func (m *FeedInfoMutation) ClearDeleted() {
	m.deleted = nil
	m.adddeleted = nil
	m.clearedFields[feedinfo.FieldDeleted] = struct{}{}
}

// DeletedCleared returns if the field deleted was cleared in this mutation.
func (m *FeedInfoMutation) DeletedCleared() bool {
	_, ok := m.clearedFields[feedinfo.FieldDeleted]
	return ok
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *FeedInfoMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
	delete(m.clearedFields, feedinfo.FieldDeleted)
}

// Op returns the operation name.
func (m *FeedInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FeedInfo).
func (m *FeedInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FeedInfoMutation) Fields() []string {
	fields := make([]string, 0, 43)
	if m.name != nil {
		fields = append(fields, feedinfo.FieldName)
	}
	if m.code != nil {
		fields = append(fields, feedinfo.FieldCode)
	}
	if m.moisture != nil {
		fields = append(fields, feedinfo.FieldMoisture)
	}
	if m.dryMatter != nil {
		fields = append(fields, feedinfo.FieldDryMatter)
	}
	if m.ndf != nil {
		fields = append(fields, feedinfo.FieldNdf)
	}
	if m.adf != nil {
		fields = append(fields, feedinfo.FieldAdf)
	}
	if m.endf != nil {
		fields = append(fields, feedinfo.FieldEndf)
	}
	if m.lacticAcid != nil {
		fields = append(fields, feedinfo.FieldLacticAcid)
	}
	if m.wsc != nil {
		fields = append(fields, feedinfo.FieldWsc)
	}
	if m.starch != nil {
		fields = append(fields, feedinfo.FieldStarch)
	}
	if m.solubleFiber != nil {
		fields = append(fields, feedinfo.FieldSolubleFiber)
	}
	if m.totalProtein != nil {
		fields = append(fields, feedinfo.FieldTotalProtein)
	}
	if m.solubleProtein != nil {
		fields = append(fields, feedinfo.FieldSolubleProtein)
	}
	if m.rdp != nil {
		fields = append(fields, feedinfo.FieldRdp)
	}
	if m.me != nil {
		fields = append(fields, feedinfo.FieldMe)
	}
	if m.nel != nil {
		fields = append(fields, feedinfo.FieldNel)
	}
	if m.crudeFat != nil {
		fields = append(fields, feedinfo.FieldCrudeFat)
	}
	if m.totalFttyAcid != nil {
		fields = append(fields, feedinfo.FieldTotalFttyAcid)
	}
	if m.ash != nil {
		fields = append(fields, feedinfo.FieldAsh)
	}
	if m.ca != nil {
		fields = append(fields, feedinfo.FieldCa)
	}
	if m.p != nil {
		fields = append(fields, feedinfo.FieldP)
	}
	if m.mg != nil {
		fields = append(fields, feedinfo.FieldMg)
	}
	if m.k != nil {
		fields = append(fields, feedinfo.FieldK)
	}
	if m.mn != nil {
		fields = append(fields, feedinfo.FieldMn)
	}
	if m.cu != nil {
		fields = append(fields, feedinfo.FieldCu)
	}
	if m.fe != nil {
		fields = append(fields, feedinfo.FieldFe)
	}
	if m.zn != nil {
		fields = append(fields, feedinfo.FieldZn)
	}
	if m.methionine != nil {
		fields = append(fields, feedinfo.FieldMethionine)
	}
	if m.lysine != nil {
		fields = append(fields, feedinfo.FieldLysine)
	}
	if m.vitaminA != nil {
		fields = append(fields, feedinfo.FieldVitaminA)
	}
	if m.vitaminD3 != nil {
		fields = append(fields, feedinfo.FieldVitaminD3)
	}
	if m.vitaminE != nil {
		fields = append(fields, feedinfo.FieldVitaminE)
	}
	if m.choline != nil {
		fields = append(fields, feedinfo.FieldCholine)
	}
	if m.biotin != nil {
		fields = append(fields, feedinfo.FieldBiotin)
	}
	if m.description != nil {
		fields = append(fields, feedinfo.FieldDescription)
	}
	if m.tenantId != nil {
		fields = append(fields, feedinfo.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, feedinfo.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, feedinfo.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, feedinfo.FieldFarmName)
	}
	if m.remarks != nil {
		fields = append(fields, feedinfo.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, feedinfo.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, feedinfo.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, feedinfo.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FeedInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedinfo.FieldName:
		return m.Name()
	case feedinfo.FieldCode:
		return m.Code()
	case feedinfo.FieldMoisture:
		return m.Moisture()
	case feedinfo.FieldDryMatter:
		return m.DryMatter()
	case feedinfo.FieldNdf:
		return m.Ndf()
	case feedinfo.FieldAdf:
		return m.Adf()
	case feedinfo.FieldEndf:
		return m.Endf()
	case feedinfo.FieldLacticAcid:
		return m.LacticAcid()
	case feedinfo.FieldWsc:
		return m.Wsc()
	case feedinfo.FieldStarch:
		return m.Starch()
	case feedinfo.FieldSolubleFiber:
		return m.SolubleFiber()
	case feedinfo.FieldTotalProtein:
		return m.TotalProtein()
	case feedinfo.FieldSolubleProtein:
		return m.SolubleProtein()
	case feedinfo.FieldRdp:
		return m.Rdp()
	case feedinfo.FieldMe:
		return m.Me()
	case feedinfo.FieldNel:
		return m.Nel()
	case feedinfo.FieldCrudeFat:
		return m.CrudeFat()
	case feedinfo.FieldTotalFttyAcid:
		return m.TotalFttyAcid()
	case feedinfo.FieldAsh:
		return m.Ash()
	case feedinfo.FieldCa:
		return m.Ca()
	case feedinfo.FieldP:
		return m.P()
	case feedinfo.FieldMg:
		return m.Mg()
	case feedinfo.FieldK:
		return m.K()
	case feedinfo.FieldMn:
		return m.Mn()
	case feedinfo.FieldCu:
		return m.Cu()
	case feedinfo.FieldFe:
		return m.Fe()
	case feedinfo.FieldZn:
		return m.Zn()
	case feedinfo.FieldMethionine:
		return m.Methionine()
	case feedinfo.FieldLysine:
		return m.Lysine()
	case feedinfo.FieldVitaminA:
		return m.VitaminA()
	case feedinfo.FieldVitaminD3:
		return m.VitaminD3()
	case feedinfo.FieldVitaminE:
		return m.VitaminE()
	case feedinfo.FieldCholine:
		return m.Choline()
	case feedinfo.FieldBiotin:
		return m.Biotin()
	case feedinfo.FieldDescription:
		return m.Description()
	case feedinfo.FieldTenantId:
		return m.TenantId()
	case feedinfo.FieldTenantName:
		return m.TenantName()
	case feedinfo.FieldFarmId:
		return m.FarmId()
	case feedinfo.FieldFarmName:
		return m.FarmName()
	case feedinfo.FieldRemarks:
		return m.Remarks()
	case feedinfo.FieldCreatedAt:
		return m.CreatedAt()
	case feedinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedinfo.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FeedInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedinfo.FieldName:
		return m.OldName(ctx)
	case feedinfo.FieldCode:
		return m.OldCode(ctx)
	case feedinfo.FieldMoisture:
		return m.OldMoisture(ctx)
	case feedinfo.FieldDryMatter:
		return m.OldDryMatter(ctx)
	case feedinfo.FieldNdf:
		return m.OldNdf(ctx)
	case feedinfo.FieldAdf:
		return m.OldAdf(ctx)
	case feedinfo.FieldEndf:
		return m.OldEndf(ctx)
	case feedinfo.FieldLacticAcid:
		return m.OldLacticAcid(ctx)
	case feedinfo.FieldWsc:
		return m.OldWsc(ctx)
	case feedinfo.FieldStarch:
		return m.OldStarch(ctx)
	case feedinfo.FieldSolubleFiber:
		return m.OldSolubleFiber(ctx)
	case feedinfo.FieldTotalProtein:
		return m.OldTotalProtein(ctx)
	case feedinfo.FieldSolubleProtein:
		return m.OldSolubleProtein(ctx)
	case feedinfo.FieldRdp:
		return m.OldRdp(ctx)
	case feedinfo.FieldMe:
		return m.OldMe(ctx)
	case feedinfo.FieldNel:
		return m.OldNel(ctx)
	case feedinfo.FieldCrudeFat:
		return m.OldCrudeFat(ctx)
	case feedinfo.FieldTotalFttyAcid:
		return m.OldTotalFttyAcid(ctx)
	case feedinfo.FieldAsh:
		return m.OldAsh(ctx)
	case feedinfo.FieldCa:
		return m.OldCa(ctx)
	case feedinfo.FieldP:
		return m.OldP(ctx)
	case feedinfo.FieldMg:
		return m.OldMg(ctx)
	case feedinfo.FieldK:
		return m.OldK(ctx)
	case feedinfo.FieldMn:
		return m.OldMn(ctx)
	case feedinfo.FieldCu:
		return m.OldCu(ctx)
	case feedinfo.FieldFe:
		return m.OldFe(ctx)
	case feedinfo.FieldZn:
		return m.OldZn(ctx)
	case feedinfo.FieldMethionine:
		return m.OldMethionine(ctx)
	case feedinfo.FieldLysine:
		return m.OldLysine(ctx)
	case feedinfo.FieldVitaminA:
		return m.OldVitaminA(ctx)
	case feedinfo.FieldVitaminD3:
		return m.OldVitaminD3(ctx)
	case feedinfo.FieldVitaminE:
		return m.OldVitaminE(ctx)
	case feedinfo.FieldCholine:
		return m.OldCholine(ctx)
	case feedinfo.FieldBiotin:
		return m.OldBiotin(ctx)
	case feedinfo.FieldDescription:
		return m.OldDescription(ctx)
	case feedinfo.FieldTenantId:
		return m.OldTenantId(ctx)
	case feedinfo.FieldTenantName:
		return m.OldTenantName(ctx)
	case feedinfo.FieldFarmId:
		return m.OldFarmId(ctx)
	case feedinfo.FieldFarmName:
		return m.OldFarmName(ctx)
	case feedinfo.FieldRemarks:
		return m.OldRemarks(ctx)
	case feedinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feedinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedinfo.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown FeedInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeedInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedinfo.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case feedinfo.FieldMoisture:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoisture(v)
		return nil
	case feedinfo.FieldDryMatter:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDryMatter(v)
		return nil
	case feedinfo.FieldNdf:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNdf(v)
		return nil
	case feedinfo.FieldAdf:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdf(v)
		return nil
	case feedinfo.FieldEndf:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndf(v)
		return nil
	case feedinfo.FieldLacticAcid:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLacticAcid(v)
		return nil
	case feedinfo.FieldWsc:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWsc(v)
		return nil
	case feedinfo.FieldStarch:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarch(v)
		return nil
	case feedinfo.FieldSolubleFiber:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSolubleFiber(v)
		return nil
	case feedinfo.FieldTotalProtein:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalProtein(v)
		return nil
	case feedinfo.FieldSolubleProtein:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSolubleProtein(v)
		return nil
	case feedinfo.FieldRdp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRdp(v)
		return nil
	case feedinfo.FieldMe:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMe(v)
		return nil
	case feedinfo.FieldNel:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNel(v)
		return nil
	case feedinfo.FieldCrudeFat:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrudeFat(v)
		return nil
	case feedinfo.FieldTotalFttyAcid:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalFttyAcid(v)
		return nil
	case feedinfo.FieldAsh:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAsh(v)
		return nil
	case feedinfo.FieldCa:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCa(v)
		return nil
	case feedinfo.FieldP:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetP(v)
		return nil
	case feedinfo.FieldMg:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMg(v)
		return nil
	case feedinfo.FieldK:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK(v)
		return nil
	case feedinfo.FieldMn:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMn(v)
		return nil
	case feedinfo.FieldCu:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCu(v)
		return nil
	case feedinfo.FieldFe:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFe(v)
		return nil
	case feedinfo.FieldZn:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZn(v)
		return nil
	case feedinfo.FieldMethionine:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethionine(v)
		return nil
	case feedinfo.FieldLysine:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLysine(v)
		return nil
	case feedinfo.FieldVitaminA:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVitaminA(v)
		return nil
	case feedinfo.FieldVitaminD3:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVitaminD3(v)
		return nil
	case feedinfo.FieldVitaminE:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVitaminE(v)
		return nil
	case feedinfo.FieldCholine:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCholine(v)
		return nil
	case feedinfo.FieldBiotin:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiotin(v)
		return nil
	case feedinfo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feedinfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case feedinfo.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case feedinfo.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case feedinfo.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case feedinfo.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case feedinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feedinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedinfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown FeedInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FeedInfoMutation) AddedFields() []string {
	var fields []string
	if m.addmoisture != nil {
		fields = append(fields, feedinfo.FieldMoisture)
	}
	if m.adddryMatter != nil {
		fields = append(fields, feedinfo.FieldDryMatter)
	}
	if m.addndf != nil {
		fields = append(fields, feedinfo.FieldNdf)
	}
	if m.addadf != nil {
		fields = append(fields, feedinfo.FieldAdf)
	}
	if m.addendf != nil {
		fields = append(fields, feedinfo.FieldEndf)
	}
	if m.addlacticAcid != nil {
		fields = append(fields, feedinfo.FieldLacticAcid)
	}
	if m.addwsc != nil {
		fields = append(fields, feedinfo.FieldWsc)
	}
	if m.addstarch != nil {
		fields = append(fields, feedinfo.FieldStarch)
	}
	if m.addsolubleFiber != nil {
		fields = append(fields, feedinfo.FieldSolubleFiber)
	}
	if m.addtotalProtein != nil {
		fields = append(fields, feedinfo.FieldTotalProtein)
	}
	if m.addsolubleProtein != nil {
		fields = append(fields, feedinfo.FieldSolubleProtein)
	}
	if m.addrdp != nil {
		fields = append(fields, feedinfo.FieldRdp)
	}
	if m.addme != nil {
		fields = append(fields, feedinfo.FieldMe)
	}
	if m.addnel != nil {
		fields = append(fields, feedinfo.FieldNel)
	}
	if m.addcrudeFat != nil {
		fields = append(fields, feedinfo.FieldCrudeFat)
	}
	if m.addtotalFttyAcid != nil {
		fields = append(fields, feedinfo.FieldTotalFttyAcid)
	}
	if m.addash != nil {
		fields = append(fields, feedinfo.FieldAsh)
	}
	if m.addca != nil {
		fields = append(fields, feedinfo.FieldCa)
	}
	if m.addp != nil {
		fields = append(fields, feedinfo.FieldP)
	}
	if m.addmg != nil {
		fields = append(fields, feedinfo.FieldMg)
	}
	if m.addk != nil {
		fields = append(fields, feedinfo.FieldK)
	}
	if m.addmn != nil {
		fields = append(fields, feedinfo.FieldMn)
	}
	if m.addcu != nil {
		fields = append(fields, feedinfo.FieldCu)
	}
	if m.addfe != nil {
		fields = append(fields, feedinfo.FieldFe)
	}
	if m.addzn != nil {
		fields = append(fields, feedinfo.FieldZn)
	}
	if m.addmethionine != nil {
		fields = append(fields, feedinfo.FieldMethionine)
	}
	if m.addlysine != nil {
		fields = append(fields, feedinfo.FieldLysine)
	}
	if m.addvitaminA != nil {
		fields = append(fields, feedinfo.FieldVitaminA)
	}
	if m.addvitaminD3 != nil {
		fields = append(fields, feedinfo.FieldVitaminD3)
	}
	if m.addvitaminE != nil {
		fields = append(fields, feedinfo.FieldVitaminE)
	}
	if m.addcholine != nil {
		fields = append(fields, feedinfo.FieldCholine)
	}
	if m.addbiotin != nil {
		fields = append(fields, feedinfo.FieldBiotin)
	}
	if m.addtenantId != nil {
		fields = append(fields, feedinfo.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, feedinfo.FieldFarmId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, feedinfo.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, feedinfo.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, feedinfo.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FeedInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedinfo.FieldMoisture:
		return m.AddedMoisture()
	case feedinfo.FieldDryMatter:
		return m.AddedDryMatter()
	case feedinfo.FieldNdf:
		return m.AddedNdf()
	case feedinfo.FieldAdf:
		return m.AddedAdf()
	case feedinfo.FieldEndf:
		return m.AddedEndf()
	case feedinfo.FieldLacticAcid:
		return m.AddedLacticAcid()
	case feedinfo.FieldWsc:
		return m.AddedWsc()
	case feedinfo.FieldStarch:
		return m.AddedStarch()
	case feedinfo.FieldSolubleFiber:
		return m.AddedSolubleFiber()
	case feedinfo.FieldTotalProtein:
		return m.AddedTotalProtein()
	case feedinfo.FieldSolubleProtein:
		return m.AddedSolubleProtein()
	case feedinfo.FieldRdp:
		return m.AddedRdp()
	case feedinfo.FieldMe:
		return m.AddedMe()
	case feedinfo.FieldNel:
		return m.AddedNel()
	case feedinfo.FieldCrudeFat:
		return m.AddedCrudeFat()
	case feedinfo.FieldTotalFttyAcid:
		return m.AddedTotalFttyAcid()
	case feedinfo.FieldAsh:
		return m.AddedAsh()
	case feedinfo.FieldCa:
		return m.AddedCa()
	case feedinfo.FieldP:
		return m.AddedP()
	case feedinfo.FieldMg:
		return m.AddedMg()
	case feedinfo.FieldK:
		return m.AddedK()
	case feedinfo.FieldMn:
		return m.AddedMn()
	case feedinfo.FieldCu:
		return m.AddedCu()
	case feedinfo.FieldFe:
		return m.AddedFe()
	case feedinfo.FieldZn:
		return m.AddedZn()
	case feedinfo.FieldMethionine:
		return m.AddedMethionine()
	case feedinfo.FieldLysine:
		return m.AddedLysine()
	case feedinfo.FieldVitaminA:
		return m.AddedVitaminA()
	case feedinfo.FieldVitaminD3:
		return m.AddedVitaminD3()
	case feedinfo.FieldVitaminE:
		return m.AddedVitaminE()
	case feedinfo.FieldCholine:
		return m.AddedCholine()
	case feedinfo.FieldBiotin:
		return m.AddedBiotin()
	case feedinfo.FieldTenantId:
		return m.AddedTenantId()
	case feedinfo.FieldFarmId:
		return m.AddedFarmId()
	case feedinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case feedinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case feedinfo.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeedInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedinfo.FieldMoisture:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMoisture(v)
		return nil
	case feedinfo.FieldDryMatter:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDryMatter(v)
		return nil
	case feedinfo.FieldNdf:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNdf(v)
		return nil
	case feedinfo.FieldAdf:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdf(v)
		return nil
	case feedinfo.FieldEndf:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEndf(v)
		return nil
	case feedinfo.FieldLacticAcid:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLacticAcid(v)
		return nil
	case feedinfo.FieldWsc:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWsc(v)
		return nil
	case feedinfo.FieldStarch:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStarch(v)
		return nil
	case feedinfo.FieldSolubleFiber:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSolubleFiber(v)
		return nil
	case feedinfo.FieldTotalProtein:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalProtein(v)
		return nil
	case feedinfo.FieldSolubleProtein:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSolubleProtein(v)
		return nil
	case feedinfo.FieldRdp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRdp(v)
		return nil
	case feedinfo.FieldMe:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMe(v)
		return nil
	case feedinfo.FieldNel:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNel(v)
		return nil
	case feedinfo.FieldCrudeFat:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCrudeFat(v)
		return nil
	case feedinfo.FieldTotalFttyAcid:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalFttyAcid(v)
		return nil
	case feedinfo.FieldAsh:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAsh(v)
		return nil
	case feedinfo.FieldCa:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCa(v)
		return nil
	case feedinfo.FieldP:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddP(v)
		return nil
	case feedinfo.FieldMg:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMg(v)
		return nil
	case feedinfo.FieldK:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK(v)
		return nil
	case feedinfo.FieldMn:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMn(v)
		return nil
	case feedinfo.FieldCu:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCu(v)
		return nil
	case feedinfo.FieldFe:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFe(v)
		return nil
	case feedinfo.FieldZn:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddZn(v)
		return nil
	case feedinfo.FieldMethionine:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethionine(v)
		return nil
	case feedinfo.FieldLysine:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLysine(v)
		return nil
	case feedinfo.FieldVitaminA:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVitaminA(v)
		return nil
	case feedinfo.FieldVitaminD3:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVitaminD3(v)
		return nil
	case feedinfo.FieldVitaminE:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVitaminE(v)
		return nil
	case feedinfo.FieldCholine:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCholine(v)
		return nil
	case feedinfo.FieldBiotin:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBiotin(v)
		return nil
	case feedinfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case feedinfo.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case feedinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case feedinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case feedinfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown FeedInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FeedInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feedinfo.FieldDescription) {
		fields = append(fields, feedinfo.FieldDescription)
	}
	if m.FieldCleared(feedinfo.FieldTenantId) {
		fields = append(fields, feedinfo.FieldTenantId)
	}
	if m.FieldCleared(feedinfo.FieldTenantName) {
		fields = append(fields, feedinfo.FieldTenantName)
	}
	if m.FieldCleared(feedinfo.FieldFarmId) {
		fields = append(fields, feedinfo.FieldFarmId)
	}
	if m.FieldCleared(feedinfo.FieldFarmName) {
		fields = append(fields, feedinfo.FieldFarmName)
	}
	if m.FieldCleared(feedinfo.FieldRemarks) {
		fields = append(fields, feedinfo.FieldRemarks)
	}
	if m.FieldCleared(feedinfo.FieldCreatedAt) {
		fields = append(fields, feedinfo.FieldCreatedAt)
	}
	if m.FieldCleared(feedinfo.FieldUpdatedAt) {
		fields = append(fields, feedinfo.FieldUpdatedAt)
	}
	if m.FieldCleared(feedinfo.FieldDeleted) {
		fields = append(fields, feedinfo.FieldDeleted)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FeedInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedInfoMutation) ClearField(name string) error {
	switch name {
	case feedinfo.FieldDescription:
		m.ClearDescription()
		return nil
	case feedinfo.FieldTenantId:
		m.ClearTenantId()
		return nil
	case feedinfo.FieldTenantName:
		m.ClearTenantName()
		return nil
	case feedinfo.FieldFarmId:
		m.ClearFarmId()
		return nil
	case feedinfo.FieldFarmName:
		m.ClearFarmName()
		return nil
	case feedinfo.FieldRemarks:
		m.ClearRemarks()
		return nil
	case feedinfo.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case feedinfo.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case feedinfo.FieldDeleted:
		m.ClearDeleted()
		return nil
	}
	return fmt.Errorf("unknown FeedInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FeedInfoMutation) ResetField(name string) error {
	switch name {
	case feedinfo.FieldName:
		m.ResetName()
		return nil
	case feedinfo.FieldCode:
		m.ResetCode()
		return nil
	case feedinfo.FieldMoisture:
		m.ResetMoisture()
		return nil
	case feedinfo.FieldDryMatter:
		m.ResetDryMatter()
		return nil
	case feedinfo.FieldNdf:
		m.ResetNdf()
		return nil
	case feedinfo.FieldAdf:
		m.ResetAdf()
		return nil
	case feedinfo.FieldEndf:
		m.ResetEndf()
		return nil
	case feedinfo.FieldLacticAcid:
		m.ResetLacticAcid()
		return nil
	case feedinfo.FieldWsc:
		m.ResetWsc()
		return nil
	case feedinfo.FieldStarch:
		m.ResetStarch()
		return nil
	case feedinfo.FieldSolubleFiber:
		m.ResetSolubleFiber()
		return nil
	case feedinfo.FieldTotalProtein:
		m.ResetTotalProtein()
		return nil
	case feedinfo.FieldSolubleProtein:
		m.ResetSolubleProtein()
		return nil
	case feedinfo.FieldRdp:
		m.ResetRdp()
		return nil
	case feedinfo.FieldMe:
		m.ResetMe()
		return nil
	case feedinfo.FieldNel:
		m.ResetNel()
		return nil
	case feedinfo.FieldCrudeFat:
		m.ResetCrudeFat()
		return nil
	case feedinfo.FieldTotalFttyAcid:
		m.ResetTotalFttyAcid()
		return nil
	case feedinfo.FieldAsh:
		m.ResetAsh()
		return nil
	case feedinfo.FieldCa:
		m.ResetCa()
		return nil
	case feedinfo.FieldP:
		m.ResetP()
		return nil
	case feedinfo.FieldMg:
		m.ResetMg()
		return nil
	case feedinfo.FieldK:
		m.ResetK()
		return nil
	case feedinfo.FieldMn:
		m.ResetMn()
		return nil
	case feedinfo.FieldCu:
		m.ResetCu()
		return nil
	case feedinfo.FieldFe:
		m.ResetFe()
		return nil
	case feedinfo.FieldZn:
		m.ResetZn()
		return nil
	case feedinfo.FieldMethionine:
		m.ResetMethionine()
		return nil
	case feedinfo.FieldLysine:
		m.ResetLysine()
		return nil
	case feedinfo.FieldVitaminA:
		m.ResetVitaminA()
		return nil
	case feedinfo.FieldVitaminD3:
		m.ResetVitaminD3()
		return nil
	case feedinfo.FieldVitaminE:
		m.ResetVitaminE()
		return nil
	case feedinfo.FieldCholine:
		m.ResetCholine()
		return nil
	case feedinfo.FieldBiotin:
		m.ResetBiotin()
		return nil
	case feedinfo.FieldDescription:
		m.ResetDescription()
		return nil
	case feedinfo.FieldTenantId:
		m.ResetTenantId()
		return nil
	case feedinfo.FieldTenantName:
		m.ResetTenantName()
		return nil
	case feedinfo.FieldFarmId:
		m.ResetFarmId()
		return nil
	case feedinfo.FieldFarmName:
		m.ResetFarmName()
		return nil
	case feedinfo.FieldRemarks:
		m.ResetRemarks()
		return nil
	case feedinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feedinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedinfo.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown FeedInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FeedInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FeedInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FeedInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FeedInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FeedInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FeedInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FeedInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeedInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FeedInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeedInfo edge %s", name)
}

// FeedRecordMutation represents an operation that mutate the FeedRecords
// nodes in the graph.
type FeedRecordMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	name            *string
	shedName        *string
	date            *int64
	adddate         *int64
	rationCode      *string
	rationName      *string
	rationAmount    *int64
	addrationAmount *int64
	count           *int64
	addcount        *int64
	userName        *string
	tenantId        *int64
	addtenantId     *int64
	tenantName      *string
	remarks         *string
	createdAt       *int64
	addcreatedAt    *int64
	updatedAt       *int64
	addupdatedAt    *int64
	deleted         *int
	adddeleted      *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*FeedRecord, error)
}

var _ ent.Mutation = (*FeedRecordMutation)(nil)

// feedrecordOption allows to manage the mutation configuration using functional options.
type feedrecordOption func(*FeedRecordMutation)

// newFeedRecordMutation creates new mutation for $n.Name.
func newFeedRecordMutation(c config, op Op, opts ...feedrecordOption) *FeedRecordMutation {
	m := &FeedRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedRecordID sets the id field of the mutation.
func withFeedRecordID(id int64) feedrecordOption {
	return func(m *FeedRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedRecord
		)
		m.oldValue = func(ctx context.Context) (*FeedRecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedRecord sets the old FeedRecord of the mutation.
func withFeedRecord(node *FeedRecord) feedrecordOption {
	return func(m *FeedRecordMutation) {
		m.oldValue = func(context.Context) (*FeedRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FeedRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FeedRecordMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FeedRecordMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *FeedRecordMutation) ClearName() {
	m.name = nil
	m.clearedFields[feedrecord.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *FeedRecordMutation) NameCleared() bool {
	_, ok := m.clearedFields[feedrecord.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *FeedRecordMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, feedrecord.FieldName)
}

// SetShedName sets the shedName field.
func (m *FeedRecordMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *FeedRecordMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *FeedRecordMutation) ResetShedName() {
	m.shedName = nil
}

// SetDate sets the date field.
func (m *FeedRecordMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *FeedRecordMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *FeedRecordMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *FeedRecordMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *FeedRecordMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetRationCode sets the rationCode field.
func (m *FeedRecordMutation) SetRationCode(s string) {
	m.rationCode = &s
}

// RationCode returns the rationCode value in the mutation.
func (m *FeedRecordMutation) RationCode() (r string, exists bool) {
	v := m.rationCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRationCode returns the old rationCode value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldRationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRationCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRationCode: %w", err)
	}
	return oldValue.RationCode, nil
}

// ResetRationCode reset all changes of the "rationCode" field.
func (m *FeedRecordMutation) ResetRationCode() {
	m.rationCode = nil
}

// SetRationName sets the rationName field.
func (m *FeedRecordMutation) SetRationName(s string) {
	m.rationName = &s
}

// RationName returns the rationName value in the mutation.
func (m *FeedRecordMutation) RationName() (r string, exists bool) {
	v := m.rationName
	if v == nil {
		return
	}
	return *v, true
}

// OldRationName returns the old rationName value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldRationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRationName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRationName: %w", err)
	}
	return oldValue.RationName, nil
}

// ResetRationName reset all changes of the "rationName" field.
func (m *FeedRecordMutation) ResetRationName() {
	m.rationName = nil
}

// SetRationAmount sets the rationAmount field.
func (m *FeedRecordMutation) SetRationAmount(i int64) {
	m.rationAmount = &i
	m.addrationAmount = nil
}

// RationAmount returns the rationAmount value in the mutation.
func (m *FeedRecordMutation) RationAmount() (r int64, exists bool) {
	v := m.rationAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldRationAmount returns the old rationAmount value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldRationAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRationAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRationAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRationAmount: %w", err)
	}
	return oldValue.RationAmount, nil
}

// AddRationAmount adds i to rationAmount.
func (m *FeedRecordMutation) AddRationAmount(i int64) {
	if m.addrationAmount != nil {
		*m.addrationAmount += i
	} else {
		m.addrationAmount = &i
	}
}

// AddedRationAmount returns the value that was added to the rationAmount field in this mutation.
func (m *FeedRecordMutation) AddedRationAmount() (r int64, exists bool) {
	v := m.addrationAmount
	if v == nil {
		return
	}
	return *v, true
}

// ResetRationAmount reset all changes of the "rationAmount" field.
func (m *FeedRecordMutation) ResetRationAmount() {
	m.rationAmount = nil
	m.addrationAmount = nil
}

// SetCount sets the count field.
func (m *FeedRecordMutation) SetCount(i int64) {
	m.count = &i
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *FeedRecordMutation) Count() (r int64, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to count.
func (m *FeedRecordMutation) AddCount(i int64) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *FeedRecordMutation) AddedCount() (r int64, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *FeedRecordMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetUserName sets the userName field.
func (m *FeedRecordMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *FeedRecordMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *FeedRecordMutation) ResetUserName() {
	m.userName = nil
}

// SetTenantId sets the tenantId field.
func (m *FeedRecordMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *FeedRecordMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *FeedRecordMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *FeedRecordMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *FeedRecordMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *FeedRecordMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *FeedRecordMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *FeedRecordMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *FeedRecordMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *FeedRecordMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *FeedRecordMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *FeedRecordMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *FeedRecordMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *FeedRecordMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *FeedRecordMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *FeedRecordMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *FeedRecordMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *FeedRecordMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *FeedRecordMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *FeedRecordMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *FeedRecordMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *FeedRecordMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *FeedRecordMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the FeedRecord.
// If the FeedRecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FeedRecordMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *FeedRecordMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *FeedRecordMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *FeedRecordMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *FeedRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FeedRecord).
func (m *FeedRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FeedRecordMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, feedrecord.FieldName)
	}
	if m.shedName != nil {
		fields = append(fields, feedrecord.FieldShedName)
	}
	if m.date != nil {
		fields = append(fields, feedrecord.FieldDate)
	}
	if m.rationCode != nil {
		fields = append(fields, feedrecord.FieldRationCode)
	}
	if m.rationName != nil {
		fields = append(fields, feedrecord.FieldRationName)
	}
	if m.rationAmount != nil {
		fields = append(fields, feedrecord.FieldRationAmount)
	}
	if m.count != nil {
		fields = append(fields, feedrecord.FieldCount)
	}
	if m.userName != nil {
		fields = append(fields, feedrecord.FieldUserName)
	}
	if m.tenantId != nil {
		fields = append(fields, feedrecord.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, feedrecord.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, feedrecord.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, feedrecord.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, feedrecord.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, feedrecord.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FeedRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedrecord.FieldName:
		return m.Name()
	case feedrecord.FieldShedName:
		return m.ShedName()
	case feedrecord.FieldDate:
		return m.Date()
	case feedrecord.FieldRationCode:
		return m.RationCode()
	case feedrecord.FieldRationName:
		return m.RationName()
	case feedrecord.FieldRationAmount:
		return m.RationAmount()
	case feedrecord.FieldCount:
		return m.Count()
	case feedrecord.FieldUserName:
		return m.UserName()
	case feedrecord.FieldTenantId:
		return m.TenantId()
	case feedrecord.FieldTenantName:
		return m.TenantName()
	case feedrecord.FieldRemarks:
		return m.Remarks()
	case feedrecord.FieldCreatedAt:
		return m.CreatedAt()
	case feedrecord.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedrecord.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FeedRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedrecord.FieldName:
		return m.OldName(ctx)
	case feedrecord.FieldShedName:
		return m.OldShedName(ctx)
	case feedrecord.FieldDate:
		return m.OldDate(ctx)
	case feedrecord.FieldRationCode:
		return m.OldRationCode(ctx)
	case feedrecord.FieldRationName:
		return m.OldRationName(ctx)
	case feedrecord.FieldRationAmount:
		return m.OldRationAmount(ctx)
	case feedrecord.FieldCount:
		return m.OldCount(ctx)
	case feedrecord.FieldUserName:
		return m.OldUserName(ctx)
	case feedrecord.FieldTenantId:
		return m.OldTenantId(ctx)
	case feedrecord.FieldTenantName:
		return m.OldTenantName(ctx)
	case feedrecord.FieldRemarks:
		return m.OldRemarks(ctx)
	case feedrecord.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feedrecord.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedrecord.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown FeedRecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeedRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedrecord.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case feedrecord.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case feedrecord.FieldRationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRationCode(v)
		return nil
	case feedrecord.FieldRationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRationName(v)
		return nil
	case feedrecord.FieldRationAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRationAmount(v)
		return nil
	case feedrecord.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case feedrecord.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case feedrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case feedrecord.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case feedrecord.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case feedrecord.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feedrecord.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedrecord.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown FeedRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FeedRecordMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, feedrecord.FieldDate)
	}
	if m.addrationAmount != nil {
		fields = append(fields, feedrecord.FieldRationAmount)
	}
	if m.addcount != nil {
		fields = append(fields, feedrecord.FieldCount)
	}
	if m.addtenantId != nil {
		fields = append(fields, feedrecord.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, feedrecord.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, feedrecord.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, feedrecord.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FeedRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedrecord.FieldDate:
		return m.AddedDate()
	case feedrecord.FieldRationAmount:
		return m.AddedRationAmount()
	case feedrecord.FieldCount:
		return m.AddedCount()
	case feedrecord.FieldTenantId:
		return m.AddedTenantId()
	case feedrecord.FieldCreatedAt:
		return m.AddedCreatedAt()
	case feedrecord.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case feedrecord.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FeedRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedrecord.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case feedrecord.FieldRationAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRationAmount(v)
		return nil
	case feedrecord.FieldCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case feedrecord.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case feedrecord.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case feedrecord.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case feedrecord.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown FeedRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FeedRecordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feedrecord.FieldName) {
		fields = append(fields, feedrecord.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FeedRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedRecordMutation) ClearField(name string) error {
	switch name {
	case feedrecord.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown FeedRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FeedRecordMutation) ResetField(name string) error {
	switch name {
	case feedrecord.FieldName:
		m.ResetName()
		return nil
	case feedrecord.FieldShedName:
		m.ResetShedName()
		return nil
	case feedrecord.FieldDate:
		m.ResetDate()
		return nil
	case feedrecord.FieldRationCode:
		m.ResetRationCode()
		return nil
	case feedrecord.FieldRationName:
		m.ResetRationName()
		return nil
	case feedrecord.FieldRationAmount:
		m.ResetRationAmount()
		return nil
	case feedrecord.FieldCount:
		m.ResetCount()
		return nil
	case feedrecord.FieldUserName:
		m.ResetUserName()
		return nil
	case feedrecord.FieldTenantId:
		m.ResetTenantId()
		return nil
	case feedrecord.FieldTenantName:
		m.ResetTenantName()
		return nil
	case feedrecord.FieldRemarks:
		m.ResetRemarks()
		return nil
	case feedrecord.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feedrecord.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedrecord.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown FeedRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FeedRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FeedRecordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FeedRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FeedRecordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FeedRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FeedRecordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FeedRecordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FeedRecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FeedRecordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FeedRecord edge %s", name)
}

// FrozenSemenInfoMutation represents an operation that mutate the FrozenSemenInfos
// nodes in the graph.
type FrozenSemenInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	_type         *string
	regCode       *string
	bullNumber    *string
	birthday      *int64
	addbirthday   *int64
	from          *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*FrozenSemenInfo, error)
}

var _ ent.Mutation = (*FrozenSemenInfoMutation)(nil)

// frozensemeninfoOption allows to manage the mutation configuration using functional options.
type frozensemeninfoOption func(*FrozenSemenInfoMutation)

// newFrozenSemenInfoMutation creates new mutation for $n.Name.
func newFrozenSemenInfoMutation(c config, op Op, opts ...frozensemeninfoOption) *FrozenSemenInfoMutation {
	m := &FrozenSemenInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeFrozenSemenInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrozenSemenInfoID sets the id field of the mutation.
func withFrozenSemenInfoID(id int64) frozensemeninfoOption {
	return func(m *FrozenSemenInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *FrozenSemenInfo
		)
		m.oldValue = func(ctx context.Context) (*FrozenSemenInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FrozenSemenInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrozenSemenInfo sets the old FrozenSemenInfo of the mutation.
func withFrozenSemenInfo(node *FrozenSemenInfo) frozensemeninfoOption {
	return func(m *FrozenSemenInfoMutation) {
		m.oldValue = func(context.Context) (*FrozenSemenInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrozenSemenInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrozenSemenInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FrozenSemenInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *FrozenSemenInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *FrozenSemenInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *FrozenSemenInfoMutation) ClearName() {
	m.name = nil
	m.clearedFields[frozensemeninfo.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *FrozenSemenInfoMutation) NameCleared() bool {
	_, ok := m.clearedFields[frozensemeninfo.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *FrozenSemenInfoMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, frozensemeninfo.FieldName)
}

// SetCode sets the code field.
func (m *FrozenSemenInfoMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *FrozenSemenInfoMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *FrozenSemenInfoMutation) ResetCode() {
	m.code = nil
}

// SetType sets the type field.
func (m *FrozenSemenInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *FrozenSemenInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *FrozenSemenInfoMutation) ResetType() {
	m._type = nil
}

// SetRegCode sets the regCode field.
func (m *FrozenSemenInfoMutation) SetRegCode(s string) {
	m.regCode = &s
}

// RegCode returns the regCode value in the mutation.
func (m *FrozenSemenInfoMutation) RegCode() (r string, exists bool) {
	v := m.regCode
	if v == nil {
		return
	}
	return *v, true
}

// OldRegCode returns the old regCode value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldRegCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegCode: %w", err)
	}
	return oldValue.RegCode, nil
}

// ResetRegCode reset all changes of the "regCode" field.
func (m *FrozenSemenInfoMutation) ResetRegCode() {
	m.regCode = nil
}

// SetBullNumber sets the bullNumber field.
func (m *FrozenSemenInfoMutation) SetBullNumber(s string) {
	m.bullNumber = &s
}

// BullNumber returns the bullNumber value in the mutation.
func (m *FrozenSemenInfoMutation) BullNumber() (r string, exists bool) {
	v := m.bullNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldBullNumber returns the old bullNumber value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldBullNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBullNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBullNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBullNumber: %w", err)
	}
	return oldValue.BullNumber, nil
}

// ResetBullNumber reset all changes of the "bullNumber" field.
func (m *FrozenSemenInfoMutation) ResetBullNumber() {
	m.bullNumber = nil
}

// SetBirthday sets the birthday field.
func (m *FrozenSemenInfoMutation) SetBirthday(i int64) {
	m.birthday = &i
	m.addbirthday = nil
}

// Birthday returns the birthday value in the mutation.
func (m *FrozenSemenInfoMutation) Birthday() (r int64, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old birthday value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldBirthday(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthday is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// AddBirthday adds i to birthday.
func (m *FrozenSemenInfoMutation) AddBirthday(i int64) {
	if m.addbirthday != nil {
		*m.addbirthday += i
	} else {
		m.addbirthday = &i
	}
}

// AddedBirthday returns the value that was added to the birthday field in this mutation.
func (m *FrozenSemenInfoMutation) AddedBirthday() (r int64, exists bool) {
	v := m.addbirthday
	if v == nil {
		return
	}
	return *v, true
}

// ResetBirthday reset all changes of the "birthday" field.
func (m *FrozenSemenInfoMutation) ResetBirthday() {
	m.birthday = nil
	m.addbirthday = nil
}

// SetFrom sets the from field.
func (m *FrozenSemenInfoMutation) SetFrom(s string) {
	m.from = &s
}

// From returns the from value in the mutation.
func (m *FrozenSemenInfoMutation) From() (r string, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old from value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFrom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom reset all changes of the "from" field.
func (m *FrozenSemenInfoMutation) ResetFrom() {
	m.from = nil
}

// SetTenantId sets the tenantId field.
func (m *FrozenSemenInfoMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *FrozenSemenInfoMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *FrozenSemenInfoMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *FrozenSemenInfoMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *FrozenSemenInfoMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *FrozenSemenInfoMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *FrozenSemenInfoMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *FrozenSemenInfoMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *FrozenSemenInfoMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *FrozenSemenInfoMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *FrozenSemenInfoMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *FrozenSemenInfoMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *FrozenSemenInfoMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *FrozenSemenInfoMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *FrozenSemenInfoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *FrozenSemenInfoMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *FrozenSemenInfoMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *FrozenSemenInfoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *FrozenSemenInfoMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *FrozenSemenInfoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *FrozenSemenInfoMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *FrozenSemenInfoMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *FrozenSemenInfoMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the FrozenSemenInfo.
// If the FrozenSemenInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FrozenSemenInfoMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *FrozenSemenInfoMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *FrozenSemenInfoMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *FrozenSemenInfoMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *FrozenSemenInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FrozenSemenInfo).
func (m *FrozenSemenInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FrozenSemenInfoMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, frozensemeninfo.FieldName)
	}
	if m.code != nil {
		fields = append(fields, frozensemeninfo.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, frozensemeninfo.FieldType)
	}
	if m.regCode != nil {
		fields = append(fields, frozensemeninfo.FieldRegCode)
	}
	if m.bullNumber != nil {
		fields = append(fields, frozensemeninfo.FieldBullNumber)
	}
	if m.birthday != nil {
		fields = append(fields, frozensemeninfo.FieldBirthday)
	}
	if m.from != nil {
		fields = append(fields, frozensemeninfo.FieldFrom)
	}
	if m.tenantId != nil {
		fields = append(fields, frozensemeninfo.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, frozensemeninfo.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, frozensemeninfo.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, frozensemeninfo.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, frozensemeninfo.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, frozensemeninfo.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FrozenSemenInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frozensemeninfo.FieldName:
		return m.Name()
	case frozensemeninfo.FieldCode:
		return m.Code()
	case frozensemeninfo.FieldType:
		return m.GetType()
	case frozensemeninfo.FieldRegCode:
		return m.RegCode()
	case frozensemeninfo.FieldBullNumber:
		return m.BullNumber()
	case frozensemeninfo.FieldBirthday:
		return m.Birthday()
	case frozensemeninfo.FieldFrom:
		return m.From()
	case frozensemeninfo.FieldTenantId:
		return m.TenantId()
	case frozensemeninfo.FieldTenantName:
		return m.TenantName()
	case frozensemeninfo.FieldRemarks:
		return m.Remarks()
	case frozensemeninfo.FieldCreatedAt:
		return m.CreatedAt()
	case frozensemeninfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case frozensemeninfo.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FrozenSemenInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frozensemeninfo.FieldName:
		return m.OldName(ctx)
	case frozensemeninfo.FieldCode:
		return m.OldCode(ctx)
	case frozensemeninfo.FieldType:
		return m.OldType(ctx)
	case frozensemeninfo.FieldRegCode:
		return m.OldRegCode(ctx)
	case frozensemeninfo.FieldBullNumber:
		return m.OldBullNumber(ctx)
	case frozensemeninfo.FieldBirthday:
		return m.OldBirthday(ctx)
	case frozensemeninfo.FieldFrom:
		return m.OldFrom(ctx)
	case frozensemeninfo.FieldTenantId:
		return m.OldTenantId(ctx)
	case frozensemeninfo.FieldTenantName:
		return m.OldTenantName(ctx)
	case frozensemeninfo.FieldRemarks:
		return m.OldRemarks(ctx)
	case frozensemeninfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case frozensemeninfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case frozensemeninfo.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown FrozenSemenInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FrozenSemenInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frozensemeninfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case frozensemeninfo.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case frozensemeninfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case frozensemeninfo.FieldRegCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegCode(v)
		return nil
	case frozensemeninfo.FieldBullNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBullNumber(v)
		return nil
	case frozensemeninfo.FieldBirthday:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case frozensemeninfo.FieldFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case frozensemeninfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case frozensemeninfo.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case frozensemeninfo.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case frozensemeninfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case frozensemeninfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case frozensemeninfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown FrozenSemenInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FrozenSemenInfoMutation) AddedFields() []string {
	var fields []string
	if m.addbirthday != nil {
		fields = append(fields, frozensemeninfo.FieldBirthday)
	}
	if m.addtenantId != nil {
		fields = append(fields, frozensemeninfo.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, frozensemeninfo.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, frozensemeninfo.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, frozensemeninfo.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FrozenSemenInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case frozensemeninfo.FieldBirthday:
		return m.AddedBirthday()
	case frozensemeninfo.FieldTenantId:
		return m.AddedTenantId()
	case frozensemeninfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case frozensemeninfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case frozensemeninfo.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FrozenSemenInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case frozensemeninfo.FieldBirthday:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBirthday(v)
		return nil
	case frozensemeninfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case frozensemeninfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case frozensemeninfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case frozensemeninfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown FrozenSemenInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FrozenSemenInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(frozensemeninfo.FieldName) {
		fields = append(fields, frozensemeninfo.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FrozenSemenInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrozenSemenInfoMutation) ClearField(name string) error {
	switch name {
	case frozensemeninfo.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown FrozenSemenInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FrozenSemenInfoMutation) ResetField(name string) error {
	switch name {
	case frozensemeninfo.FieldName:
		m.ResetName()
		return nil
	case frozensemeninfo.FieldCode:
		m.ResetCode()
		return nil
	case frozensemeninfo.FieldType:
		m.ResetType()
		return nil
	case frozensemeninfo.FieldRegCode:
		m.ResetRegCode()
		return nil
	case frozensemeninfo.FieldBullNumber:
		m.ResetBullNumber()
		return nil
	case frozensemeninfo.FieldBirthday:
		m.ResetBirthday()
		return nil
	case frozensemeninfo.FieldFrom:
		m.ResetFrom()
		return nil
	case frozensemeninfo.FieldTenantId:
		m.ResetTenantId()
		return nil
	case frozensemeninfo.FieldTenantName:
		m.ResetTenantName()
		return nil
	case frozensemeninfo.FieldRemarks:
		m.ResetRemarks()
		return nil
	case frozensemeninfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case frozensemeninfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case frozensemeninfo.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown FrozenSemenInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FrozenSemenInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FrozenSemenInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FrozenSemenInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FrozenSemenInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FrozenSemenInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FrozenSemenInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FrozenSemenInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FrozenSemenInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FrozenSemenInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FrozenSemenInfo edge %s", name)
}

// HairStateMutation represents an operation that mutate the HairStates
// nodes in the graph.
type HairStateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*HairState, error)
}

var _ ent.Mutation = (*HairStateMutation)(nil)

// hairstateOption allows to manage the mutation configuration using functional options.
type hairstateOption func(*HairStateMutation)

// newHairStateMutation creates new mutation for $n.Name.
func newHairStateMutation(c config, op Op, opts ...hairstateOption) *HairStateMutation {
	m := &HairStateMutation{
		config:        c,
		op:            op,
		typ:           TypeHairState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHairStateID sets the id field of the mutation.
func withHairStateID(id int64) hairstateOption {
	return func(m *HairStateMutation) {
		var (
			err   error
			once  sync.Once
			value *HairState
		)
		m.oldValue = func(ctx context.Context) (*HairState, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HairState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHairState sets the old HairState of the mutation.
func withHairState(node *HairState) hairstateOption {
	return func(m *HairStateMutation) {
		m.oldValue = func(context.Context) (*HairState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HairStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HairStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HairStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *HairStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *HairStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the HairState.
// If the HairState object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HairStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *HairStateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *HairStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HairState).
func (m *HairStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HairStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, hairstate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HairStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hairstate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HairStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hairstate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown HairState field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HairStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hairstate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown HairState field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HairStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HairStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HairStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HairState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HairStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HairStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HairStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HairState nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HairStateMutation) ResetField(name string) error {
	switch name {
	case hairstate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown HairState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HairStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HairStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HairStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HairStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HairStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HairStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HairStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HairState unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HairStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HairState edge %s", name)
}

// HealthCareMutation represents an operation that mutate the HealthCares
// nodes in the graph.
type HealthCareMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	cattleId      *int64
	addcattleId   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	shedId        *int64
	addshedId     *int64
	shedName      *string
	earNumber     *string
	date          *int64
	adddate       *int64
	reason        *string
	method        *string
	vetName       *string
	hoofArea      *string
	hornMethod    *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	remarks       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*HealthCare, error)
}

var _ ent.Mutation = (*HealthCareMutation)(nil)

// healthcareOption allows to manage the mutation configuration using functional options.
type healthcareOption func(*HealthCareMutation)

// newHealthCareMutation creates new mutation for $n.Name.
func newHealthCareMutation(c config, op Op, opts ...healthcareOption) *HealthCareMutation {
	m := &HealthCareMutation{
		config:        c,
		op:            op,
		typ:           TypeHealthCare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHealthCareID sets the id field of the mutation.
func withHealthCareID(id int64) healthcareOption {
	return func(m *HealthCareMutation) {
		var (
			err   error
			once  sync.Once
			value *HealthCare
		)
		m.oldValue = func(ctx context.Context) (*HealthCare, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HealthCare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHealthCare sets the old HealthCare of the mutation.
func withHealthCare(node *HealthCare) healthcareOption {
	return func(m *HealthCareMutation) {
		m.oldValue = func(context.Context) (*HealthCare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HealthCareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HealthCareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HealthCareMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *HealthCareMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *HealthCareMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *HealthCareMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *HealthCareMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *HealthCareMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *HealthCareMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *HealthCareMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *HealthCareMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *HealthCareMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *HealthCareMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *HealthCareMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *HealthCareMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *HealthCareMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *HealthCareMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *HealthCareMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *HealthCareMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *HealthCareMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *HealthCareMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *HealthCareMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *HealthCareMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *HealthCareMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *HealthCareMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *HealthCareMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *HealthCareMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *HealthCareMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *HealthCareMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *HealthCareMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *HealthCareMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *HealthCareMutation) ResetShedName() {
	m.shedName = nil
}

// SetEarNumber sets the earNumber field.
func (m *HealthCareMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *HealthCareMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *HealthCareMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetDate sets the date field.
func (m *HealthCareMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *HealthCareMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *HealthCareMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *HealthCareMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *HealthCareMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetReason sets the reason field.
func (m *HealthCareMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the reason value in the mutation.
func (m *HealthCareMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old reason value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReason is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason reset all changes of the "reason" field.
func (m *HealthCareMutation) ResetReason() {
	m.reason = nil
}

// SetMethod sets the method field.
func (m *HealthCareMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the method value in the mutation.
func (m *HealthCareMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old method value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod reset all changes of the "method" field.
func (m *HealthCareMutation) ResetMethod() {
	m.method = nil
}

// SetVetName sets the vetName field.
func (m *HealthCareMutation) SetVetName(s string) {
	m.vetName = &s
}

// VetName returns the vetName value in the mutation.
func (m *HealthCareMutation) VetName() (r string, exists bool) {
	v := m.vetName
	if v == nil {
		return
	}
	return *v, true
}

// OldVetName returns the old vetName value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldVetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVetName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVetName: %w", err)
	}
	return oldValue.VetName, nil
}

// ResetVetName reset all changes of the "vetName" field.
func (m *HealthCareMutation) ResetVetName() {
	m.vetName = nil
}

// SetHoofArea sets the hoofArea field.
func (m *HealthCareMutation) SetHoofArea(s string) {
	m.hoofArea = &s
}

// HoofArea returns the hoofArea value in the mutation.
func (m *HealthCareMutation) HoofArea() (r string, exists bool) {
	v := m.hoofArea
	if v == nil {
		return
	}
	return *v, true
}

// OldHoofArea returns the old hoofArea value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldHoofArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHoofArea is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHoofArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoofArea: %w", err)
	}
	return oldValue.HoofArea, nil
}

// ResetHoofArea reset all changes of the "hoofArea" field.
func (m *HealthCareMutation) ResetHoofArea() {
	m.hoofArea = nil
}

// SetHornMethod sets the hornMethod field.
func (m *HealthCareMutation) SetHornMethod(s string) {
	m.hornMethod = &s
}

// HornMethod returns the hornMethod value in the mutation.
func (m *HealthCareMutation) HornMethod() (r string, exists bool) {
	v := m.hornMethod
	if v == nil {
		return
	}
	return *v, true
}

// OldHornMethod returns the old hornMethod value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldHornMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHornMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHornMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHornMethod: %w", err)
	}
	return oldValue.HornMethod, nil
}

// ResetHornMethod reset all changes of the "hornMethod" field.
func (m *HealthCareMutation) ResetHornMethod() {
	m.hornMethod = nil
}

// SetCreatedAt sets the createdAt field.
func (m *HealthCareMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *HealthCareMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *HealthCareMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *HealthCareMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *HealthCareMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *HealthCareMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *HealthCareMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *HealthCareMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *HealthCareMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *HealthCareMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *HealthCareMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *HealthCareMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *HealthCareMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *HealthCareMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *HealthCareMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// SetRemarks sets the remarks field.
func (m *HealthCareMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *HealthCareMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the HealthCare.
// If the HealthCare object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HealthCareMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *HealthCareMutation) ResetRemarks() {
	m.remarks = nil
}

// Op returns the operation name.
func (m *HealthCareMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (HealthCare).
func (m *HealthCareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HealthCareMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.cattleId != nil {
		fields = append(fields, healthcare.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, healthcare.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, healthcare.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, healthcare.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, healthcare.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, healthcare.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, healthcare.FieldShedName)
	}
	if m.earNumber != nil {
		fields = append(fields, healthcare.FieldEarNumber)
	}
	if m.date != nil {
		fields = append(fields, healthcare.FieldDate)
	}
	if m.reason != nil {
		fields = append(fields, healthcare.FieldReason)
	}
	if m.method != nil {
		fields = append(fields, healthcare.FieldMethod)
	}
	if m.vetName != nil {
		fields = append(fields, healthcare.FieldVetName)
	}
	if m.hoofArea != nil {
		fields = append(fields, healthcare.FieldHoofArea)
	}
	if m.hornMethod != nil {
		fields = append(fields, healthcare.FieldHornMethod)
	}
	if m.createdAt != nil {
		fields = append(fields, healthcare.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, healthcare.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, healthcare.FieldDeleted)
	}
	if m.remarks != nil {
		fields = append(fields, healthcare.FieldRemarks)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HealthCareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case healthcare.FieldCattleId:
		return m.CattleId()
	case healthcare.FieldTenantId:
		return m.TenantId()
	case healthcare.FieldTenantName:
		return m.TenantName()
	case healthcare.FieldFarmId:
		return m.FarmId()
	case healthcare.FieldFarmName:
		return m.FarmName()
	case healthcare.FieldShedId:
		return m.ShedId()
	case healthcare.FieldShedName:
		return m.ShedName()
	case healthcare.FieldEarNumber:
		return m.EarNumber()
	case healthcare.FieldDate:
		return m.Date()
	case healthcare.FieldReason:
		return m.Reason()
	case healthcare.FieldMethod:
		return m.Method()
	case healthcare.FieldVetName:
		return m.VetName()
	case healthcare.FieldHoofArea:
		return m.HoofArea()
	case healthcare.FieldHornMethod:
		return m.HornMethod()
	case healthcare.FieldCreatedAt:
		return m.CreatedAt()
	case healthcare.FieldUpdatedAt:
		return m.UpdatedAt()
	case healthcare.FieldDeleted:
		return m.Deleted()
	case healthcare.FieldRemarks:
		return m.Remarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HealthCareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case healthcare.FieldCattleId:
		return m.OldCattleId(ctx)
	case healthcare.FieldTenantId:
		return m.OldTenantId(ctx)
	case healthcare.FieldTenantName:
		return m.OldTenantName(ctx)
	case healthcare.FieldFarmId:
		return m.OldFarmId(ctx)
	case healthcare.FieldFarmName:
		return m.OldFarmName(ctx)
	case healthcare.FieldShedId:
		return m.OldShedId(ctx)
	case healthcare.FieldShedName:
		return m.OldShedName(ctx)
	case healthcare.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case healthcare.FieldDate:
		return m.OldDate(ctx)
	case healthcare.FieldReason:
		return m.OldReason(ctx)
	case healthcare.FieldMethod:
		return m.OldMethod(ctx)
	case healthcare.FieldVetName:
		return m.OldVetName(ctx)
	case healthcare.FieldHoofArea:
		return m.OldHoofArea(ctx)
	case healthcare.FieldHornMethod:
		return m.OldHornMethod(ctx)
	case healthcare.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case healthcare.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case healthcare.FieldDeleted:
		return m.OldDeleted(ctx)
	case healthcare.FieldRemarks:
		return m.OldRemarks(ctx)
	}
	return nil, fmt.Errorf("unknown HealthCare field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HealthCareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case healthcare.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case healthcare.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case healthcare.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case healthcare.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case healthcare.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case healthcare.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case healthcare.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case healthcare.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case healthcare.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case healthcare.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case healthcare.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case healthcare.FieldVetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVetName(v)
		return nil
	case healthcare.FieldHoofArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoofArea(v)
		return nil
	case healthcare.FieldHornMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHornMethod(v)
		return nil
	case healthcare.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case healthcare.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case healthcare.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case healthcare.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	}
	return fmt.Errorf("unknown HealthCare field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HealthCareMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, healthcare.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, healthcare.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, healthcare.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, healthcare.FieldShedId)
	}
	if m.adddate != nil {
		fields = append(fields, healthcare.FieldDate)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, healthcare.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, healthcare.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, healthcare.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HealthCareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case healthcare.FieldCattleId:
		return m.AddedCattleId()
	case healthcare.FieldTenantId:
		return m.AddedTenantId()
	case healthcare.FieldFarmId:
		return m.AddedFarmId()
	case healthcare.FieldShedId:
		return m.AddedShedId()
	case healthcare.FieldDate:
		return m.AddedDate()
	case healthcare.FieldCreatedAt:
		return m.AddedCreatedAt()
	case healthcare.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case healthcare.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HealthCareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case healthcare.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case healthcare.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case healthcare.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case healthcare.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case healthcare.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case healthcare.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case healthcare.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case healthcare.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown HealthCare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HealthCareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HealthCareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HealthCareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HealthCare nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HealthCareMutation) ResetField(name string) error {
	switch name {
	case healthcare.FieldCattleId:
		m.ResetCattleId()
		return nil
	case healthcare.FieldTenantId:
		m.ResetTenantId()
		return nil
	case healthcare.FieldTenantName:
		m.ResetTenantName()
		return nil
	case healthcare.FieldFarmId:
		m.ResetFarmId()
		return nil
	case healthcare.FieldFarmName:
		m.ResetFarmName()
		return nil
	case healthcare.FieldShedId:
		m.ResetShedId()
		return nil
	case healthcare.FieldShedName:
		m.ResetShedName()
		return nil
	case healthcare.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case healthcare.FieldDate:
		m.ResetDate()
		return nil
	case healthcare.FieldReason:
		m.ResetReason()
		return nil
	case healthcare.FieldMethod:
		m.ResetMethod()
		return nil
	case healthcare.FieldVetName:
		m.ResetVetName()
		return nil
	case healthcare.FieldHoofArea:
		m.ResetHoofArea()
		return nil
	case healthcare.FieldHornMethod:
		m.ResetHornMethod()
		return nil
	case healthcare.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case healthcare.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case healthcare.FieldDeleted:
		m.ResetDeleted()
		return nil
	case healthcare.FieldRemarks:
		m.ResetRemarks()
		return nil
	}
	return fmt.Errorf("unknown HealthCare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HealthCareMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HealthCareMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HealthCareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HealthCareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HealthCareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HealthCareMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HealthCareMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown HealthCare unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HealthCareMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown HealthCare edge %s", name)
}

// ImmunityMutation represents an operation that mutate the Immunities
// nodes in the graph.
type ImmunityMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	cattleId      *int64
	addcattleId   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	shedId        *int64
	addshedId     *int64
	shedName      *string
	name          *string
	earNumber     *string
	date          *int64
	adddate       *int64
	itemId        *int
	additemId     *int
	itemName      *string
	userName      *string
	drug          *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Immunity, error)
}

var _ ent.Mutation = (*ImmunityMutation)(nil)

// immunityOption allows to manage the mutation configuration using functional options.
type immunityOption func(*ImmunityMutation)

// newImmunityMutation creates new mutation for $n.Name.
func newImmunityMutation(c config, op Op, opts ...immunityOption) *ImmunityMutation {
	m := &ImmunityMutation{
		config:        c,
		op:            op,
		typ:           TypeImmunity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImmunityID sets the id field of the mutation.
func withImmunityID(id int64) immunityOption {
	return func(m *ImmunityMutation) {
		var (
			err   error
			once  sync.Once
			value *Immunity
		)
		m.oldValue = func(ctx context.Context) (*Immunity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Immunity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImmunity sets the old Immunity of the mutation.
func withImmunity(node *Immunity) immunityOption {
	return func(m *ImmunityMutation) {
		m.oldValue = func(context.Context) (*Immunity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImmunityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImmunityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ImmunityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *ImmunityMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *ImmunityMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *ImmunityMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *ImmunityMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *ImmunityMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *ImmunityMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *ImmunityMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *ImmunityMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *ImmunityMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *ImmunityMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *ImmunityMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *ImmunityMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *ImmunityMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *ImmunityMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *ImmunityMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *ImmunityMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *ImmunityMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *ImmunityMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *ImmunityMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *ImmunityMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *ImmunityMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *ImmunityMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *ImmunityMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *ImmunityMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *ImmunityMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *ImmunityMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *ImmunityMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *ImmunityMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *ImmunityMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *ImmunityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ImmunityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ImmunityMutation) ResetName() {
	m.name = nil
}

// SetEarNumber sets the earNumber field.
func (m *ImmunityMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *ImmunityMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *ImmunityMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetDate sets the date field.
func (m *ImmunityMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *ImmunityMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *ImmunityMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *ImmunityMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *ImmunityMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetItemId sets the itemId field.
func (m *ImmunityMutation) SetItemId(i int) {
	m.itemId = &i
	m.additemId = nil
}

// ItemId returns the itemId value in the mutation.
func (m *ImmunityMutation) ItemId() (r int, exists bool) {
	v := m.itemId
	if v == nil {
		return
	}
	return *v, true
}

// OldItemId returns the old itemId value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldItemId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemId: %w", err)
	}
	return oldValue.ItemId, nil
}

// AddItemId adds i to itemId.
func (m *ImmunityMutation) AddItemId(i int) {
	if m.additemId != nil {
		*m.additemId += i
	} else {
		m.additemId = &i
	}
}

// AddedItemId returns the value that was added to the itemId field in this mutation.
func (m *ImmunityMutation) AddedItemId() (r int, exists bool) {
	v := m.additemId
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemId reset all changes of the "itemId" field.
func (m *ImmunityMutation) ResetItemId() {
	m.itemId = nil
	m.additemId = nil
}

// SetItemName sets the itemName field.
func (m *ImmunityMutation) SetItemName(s string) {
	m.itemName = &s
}

// ItemName returns the itemName value in the mutation.
func (m *ImmunityMutation) ItemName() (r string, exists bool) {
	v := m.itemName
	if v == nil {
		return
	}
	return *v, true
}

// OldItemName returns the old itemName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldItemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemName: %w", err)
	}
	return oldValue.ItemName, nil
}

// ResetItemName reset all changes of the "itemName" field.
func (m *ImmunityMutation) ResetItemName() {
	m.itemName = nil
}

// SetUserName sets the userName field.
func (m *ImmunityMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *ImmunityMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *ImmunityMutation) ResetUserName() {
	m.userName = nil
}

// SetDrug sets the drug field.
func (m *ImmunityMutation) SetDrug(s string) {
	m.drug = &s
}

// Drug returns the drug value in the mutation.
func (m *ImmunityMutation) Drug() (r string, exists bool) {
	v := m.drug
	if v == nil {
		return
	}
	return *v, true
}

// OldDrug returns the old drug value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldDrug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDrug is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDrug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrug: %w", err)
	}
	return oldValue.Drug, nil
}

// ResetDrug reset all changes of the "drug" field.
func (m *ImmunityMutation) ResetDrug() {
	m.drug = nil
}

// SetRemarks sets the remarks field.
func (m *ImmunityMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ImmunityMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ImmunityMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ImmunityMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ImmunityMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ImmunityMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ImmunityMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ImmunityMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ImmunityMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ImmunityMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ImmunityMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ImmunityMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ImmunityMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ImmunityMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ImmunityMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Immunity.
// If the Immunity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ImmunityMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ImmunityMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ImmunityMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ImmunityMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ImmunityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Immunity).
func (m *ImmunityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ImmunityMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.cattleId != nil {
		fields = append(fields, immunity.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, immunity.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, immunity.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, immunity.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, immunity.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, immunity.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, immunity.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, immunity.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, immunity.FieldEarNumber)
	}
	if m.date != nil {
		fields = append(fields, immunity.FieldDate)
	}
	if m.itemId != nil {
		fields = append(fields, immunity.FieldItemId)
	}
	if m.itemName != nil {
		fields = append(fields, immunity.FieldItemName)
	}
	if m.userName != nil {
		fields = append(fields, immunity.FieldUserName)
	}
	if m.drug != nil {
		fields = append(fields, immunity.FieldDrug)
	}
	if m.remarks != nil {
		fields = append(fields, immunity.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, immunity.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, immunity.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, immunity.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ImmunityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case immunity.FieldCattleId:
		return m.CattleId()
	case immunity.FieldTenantId:
		return m.TenantId()
	case immunity.FieldTenantName:
		return m.TenantName()
	case immunity.FieldFarmId:
		return m.FarmId()
	case immunity.FieldFarmName:
		return m.FarmName()
	case immunity.FieldShedId:
		return m.ShedId()
	case immunity.FieldShedName:
		return m.ShedName()
	case immunity.FieldName:
		return m.Name()
	case immunity.FieldEarNumber:
		return m.EarNumber()
	case immunity.FieldDate:
		return m.Date()
	case immunity.FieldItemId:
		return m.ItemId()
	case immunity.FieldItemName:
		return m.ItemName()
	case immunity.FieldUserName:
		return m.UserName()
	case immunity.FieldDrug:
		return m.Drug()
	case immunity.FieldRemarks:
		return m.Remarks()
	case immunity.FieldCreatedAt:
		return m.CreatedAt()
	case immunity.FieldUpdatedAt:
		return m.UpdatedAt()
	case immunity.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ImmunityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case immunity.FieldCattleId:
		return m.OldCattleId(ctx)
	case immunity.FieldTenantId:
		return m.OldTenantId(ctx)
	case immunity.FieldTenantName:
		return m.OldTenantName(ctx)
	case immunity.FieldFarmId:
		return m.OldFarmId(ctx)
	case immunity.FieldFarmName:
		return m.OldFarmName(ctx)
	case immunity.FieldShedId:
		return m.OldShedId(ctx)
	case immunity.FieldShedName:
		return m.OldShedName(ctx)
	case immunity.FieldName:
		return m.OldName(ctx)
	case immunity.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case immunity.FieldDate:
		return m.OldDate(ctx)
	case immunity.FieldItemId:
		return m.OldItemId(ctx)
	case immunity.FieldItemName:
		return m.OldItemName(ctx)
	case immunity.FieldUserName:
		return m.OldUserName(ctx)
	case immunity.FieldDrug:
		return m.OldDrug(ctx)
	case immunity.FieldRemarks:
		return m.OldRemarks(ctx)
	case immunity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case immunity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case immunity.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Immunity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ImmunityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case immunity.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case immunity.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case immunity.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case immunity.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case immunity.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case immunity.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case immunity.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case immunity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case immunity.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case immunity.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case immunity.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemId(v)
		return nil
	case immunity.FieldItemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemName(v)
		return nil
	case immunity.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case immunity.FieldDrug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrug(v)
		return nil
	case immunity.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case immunity.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case immunity.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case immunity.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Immunity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ImmunityMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, immunity.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, immunity.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, immunity.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, immunity.FieldShedId)
	}
	if m.adddate != nil {
		fields = append(fields, immunity.FieldDate)
	}
	if m.additemId != nil {
		fields = append(fields, immunity.FieldItemId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, immunity.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, immunity.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, immunity.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ImmunityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case immunity.FieldCattleId:
		return m.AddedCattleId()
	case immunity.FieldTenantId:
		return m.AddedTenantId()
	case immunity.FieldFarmId:
		return m.AddedFarmId()
	case immunity.FieldShedId:
		return m.AddedShedId()
	case immunity.FieldDate:
		return m.AddedDate()
	case immunity.FieldItemId:
		return m.AddedItemId()
	case immunity.FieldCreatedAt:
		return m.AddedCreatedAt()
	case immunity.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case immunity.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ImmunityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case immunity.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case immunity.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case immunity.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case immunity.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case immunity.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case immunity.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemId(v)
		return nil
	case immunity.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case immunity.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case immunity.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Immunity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ImmunityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ImmunityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImmunityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Immunity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ImmunityMutation) ResetField(name string) error {
	switch name {
	case immunity.FieldCattleId:
		m.ResetCattleId()
		return nil
	case immunity.FieldTenantId:
		m.ResetTenantId()
		return nil
	case immunity.FieldTenantName:
		m.ResetTenantName()
		return nil
	case immunity.FieldFarmId:
		m.ResetFarmId()
		return nil
	case immunity.FieldFarmName:
		m.ResetFarmName()
		return nil
	case immunity.FieldShedId:
		m.ResetShedId()
		return nil
	case immunity.FieldShedName:
		m.ResetShedName()
		return nil
	case immunity.FieldName:
		m.ResetName()
		return nil
	case immunity.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case immunity.FieldDate:
		m.ResetDate()
		return nil
	case immunity.FieldItemId:
		m.ResetItemId()
		return nil
	case immunity.FieldItemName:
		m.ResetItemName()
		return nil
	case immunity.FieldUserName:
		m.ResetUserName()
		return nil
	case immunity.FieldDrug:
		m.ResetDrug()
		return nil
	case immunity.FieldRemarks:
		m.ResetRemarks()
		return nil
	case immunity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case immunity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case immunity.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Immunity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ImmunityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ImmunityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ImmunityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ImmunityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ImmunityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ImmunityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ImmunityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Immunity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ImmunityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Immunity edge %s", name)
}

// InspectionMutation represents an operation that mutate the Inspections
// nodes in the graph.
type InspectionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	cattleId      *int64
	addcattleId   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	shedId        *int64
	addshedId     *int64
	shedName      *string
	name          *string
	earNumber     *string
	date          *int64
	adddate       *int64
	itemId        *int
	additemId     *int
	itemName      *string
	methodId      *int
	addmethodId   *int
	methodName    *string
	byId          *int64
	addbyId       *int64
	byName        *string
	resultId      *int64
	addresultId   *int64
	resultName    *string
	handleId      *int
	addhandleId   *int
	handleName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Inspection, error)
}

var _ ent.Mutation = (*InspectionMutation)(nil)

// inspectionOption allows to manage the mutation configuration using functional options.
type inspectionOption func(*InspectionMutation)

// newInspectionMutation creates new mutation for $n.Name.
func newInspectionMutation(c config, op Op, opts ...inspectionOption) *InspectionMutation {
	m := &InspectionMutation{
		config:        c,
		op:            op,
		typ:           TypeInspection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInspectionID sets the id field of the mutation.
func withInspectionID(id int64) inspectionOption {
	return func(m *InspectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Inspection
		)
		m.oldValue = func(ctx context.Context) (*Inspection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inspection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInspection sets the old Inspection of the mutation.
func withInspection(node *Inspection) inspectionOption {
	return func(m *InspectionMutation) {
		m.oldValue = func(context.Context) (*Inspection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InspectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InspectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InspectionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *InspectionMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *InspectionMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *InspectionMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *InspectionMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *InspectionMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *InspectionMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *InspectionMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *InspectionMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *InspectionMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *InspectionMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *InspectionMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *InspectionMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *InspectionMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *InspectionMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *InspectionMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *InspectionMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *InspectionMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *InspectionMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *InspectionMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *InspectionMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *InspectionMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *InspectionMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *InspectionMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *InspectionMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *InspectionMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *InspectionMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *InspectionMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *InspectionMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *InspectionMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *InspectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *InspectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *InspectionMutation) ResetName() {
	m.name = nil
}

// SetEarNumber sets the earNumber field.
func (m *InspectionMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *InspectionMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *InspectionMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetDate sets the date field.
func (m *InspectionMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *InspectionMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *InspectionMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *InspectionMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *InspectionMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetItemId sets the itemId field.
func (m *InspectionMutation) SetItemId(i int) {
	m.itemId = &i
	m.additemId = nil
}

// ItemId returns the itemId value in the mutation.
func (m *InspectionMutation) ItemId() (r int, exists bool) {
	v := m.itemId
	if v == nil {
		return
	}
	return *v, true
}

// OldItemId returns the old itemId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldItemId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemId: %w", err)
	}
	return oldValue.ItemId, nil
}

// AddItemId adds i to itemId.
func (m *InspectionMutation) AddItemId(i int) {
	if m.additemId != nil {
		*m.additemId += i
	} else {
		m.additemId = &i
	}
}

// AddedItemId returns the value that was added to the itemId field in this mutation.
func (m *InspectionMutation) AddedItemId() (r int, exists bool) {
	v := m.additemId
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemId reset all changes of the "itemId" field.
func (m *InspectionMutation) ResetItemId() {
	m.itemId = nil
	m.additemId = nil
}

// SetItemName sets the itemName field.
func (m *InspectionMutation) SetItemName(s string) {
	m.itemName = &s
}

// ItemName returns the itemName value in the mutation.
func (m *InspectionMutation) ItemName() (r string, exists bool) {
	v := m.itemName
	if v == nil {
		return
	}
	return *v, true
}

// OldItemName returns the old itemName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldItemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldItemName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldItemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemName: %w", err)
	}
	return oldValue.ItemName, nil
}

// ResetItemName reset all changes of the "itemName" field.
func (m *InspectionMutation) ResetItemName() {
	m.itemName = nil
}

// SetMethodId sets the methodId field.
func (m *InspectionMutation) SetMethodId(i int) {
	m.methodId = &i
	m.addmethodId = nil
}

// MethodId returns the methodId value in the mutation.
func (m *InspectionMutation) MethodId() (r int, exists bool) {
	v := m.methodId
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodId returns the old methodId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldMethodId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodId: %w", err)
	}
	return oldValue.MethodId, nil
}

// AddMethodId adds i to methodId.
func (m *InspectionMutation) AddMethodId(i int) {
	if m.addmethodId != nil {
		*m.addmethodId += i
	} else {
		m.addmethodId = &i
	}
}

// AddedMethodId returns the value that was added to the methodId field in this mutation.
func (m *InspectionMutation) AddedMethodId() (r int, exists bool) {
	v := m.addmethodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetMethodId reset all changes of the "methodId" field.
func (m *InspectionMutation) ResetMethodId() {
	m.methodId = nil
	m.addmethodId = nil
}

// SetMethodName sets the methodName field.
func (m *InspectionMutation) SetMethodName(s string) {
	m.methodName = &s
}

// MethodName returns the methodName value in the mutation.
func (m *InspectionMutation) MethodName() (r string, exists bool) {
	v := m.methodName
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodName returns the old methodName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethodName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodName: %w", err)
	}
	return oldValue.MethodName, nil
}

// ResetMethodName reset all changes of the "methodName" field.
func (m *InspectionMutation) ResetMethodName() {
	m.methodName = nil
}

// SetById sets the byId field.
func (m *InspectionMutation) SetById(i int64) {
	m.byId = &i
	m.addbyId = nil
}

// ById returns the byId value in the mutation.
func (m *InspectionMutation) ById() (r int64, exists bool) {
	v := m.byId
	if v == nil {
		return
	}
	return *v, true
}

// OldById returns the old byId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldById(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldById is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldById requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldById: %w", err)
	}
	return oldValue.ById, nil
}

// AddById adds i to byId.
func (m *InspectionMutation) AddById(i int64) {
	if m.addbyId != nil {
		*m.addbyId += i
	} else {
		m.addbyId = &i
	}
}

// AddedById returns the value that was added to the byId field in this mutation.
func (m *InspectionMutation) AddedById() (r int64, exists bool) {
	v := m.addbyId
	if v == nil {
		return
	}
	return *v, true
}

// ResetById reset all changes of the "byId" field.
func (m *InspectionMutation) ResetById() {
	m.byId = nil
	m.addbyId = nil
}

// SetByName sets the byName field.
func (m *InspectionMutation) SetByName(s string) {
	m.byName = &s
}

// ByName returns the byName value in the mutation.
func (m *InspectionMutation) ByName() (r string, exists bool) {
	v := m.byName
	if v == nil {
		return
	}
	return *v, true
}

// OldByName returns the old byName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldByName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldByName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldByName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldByName: %w", err)
	}
	return oldValue.ByName, nil
}

// ResetByName reset all changes of the "byName" field.
func (m *InspectionMutation) ResetByName() {
	m.byName = nil
}

// SetResultId sets the resultId field.
func (m *InspectionMutation) SetResultId(i int64) {
	m.resultId = &i
	m.addresultId = nil
}

// ResultId returns the resultId value in the mutation.
func (m *InspectionMutation) ResultId() (r int64, exists bool) {
	v := m.resultId
	if v == nil {
		return
	}
	return *v, true
}

// OldResultId returns the old resultId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldResultId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResultId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResultId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultId: %w", err)
	}
	return oldValue.ResultId, nil
}

// AddResultId adds i to resultId.
func (m *InspectionMutation) AddResultId(i int64) {
	if m.addresultId != nil {
		*m.addresultId += i
	} else {
		m.addresultId = &i
	}
}

// AddedResultId returns the value that was added to the resultId field in this mutation.
func (m *InspectionMutation) AddedResultId() (r int64, exists bool) {
	v := m.addresultId
	if v == nil {
		return
	}
	return *v, true
}

// ResetResultId reset all changes of the "resultId" field.
func (m *InspectionMutation) ResetResultId() {
	m.resultId = nil
	m.addresultId = nil
}

// SetResultName sets the resultName field.
func (m *InspectionMutation) SetResultName(s string) {
	m.resultName = &s
}

// ResultName returns the resultName value in the mutation.
func (m *InspectionMutation) ResultName() (r string, exists bool) {
	v := m.resultName
	if v == nil {
		return
	}
	return *v, true
}

// OldResultName returns the old resultName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldResultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResultName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultName: %w", err)
	}
	return oldValue.ResultName, nil
}

// ResetResultName reset all changes of the "resultName" field.
func (m *InspectionMutation) ResetResultName() {
	m.resultName = nil
}

// SetHandleId sets the handleId field.
func (m *InspectionMutation) SetHandleId(i int) {
	m.handleId = &i
	m.addhandleId = nil
}

// HandleId returns the handleId value in the mutation.
func (m *InspectionMutation) HandleId() (r int, exists bool) {
	v := m.handleId
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleId returns the old handleId value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldHandleId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHandleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHandleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleId: %w", err)
	}
	return oldValue.HandleId, nil
}

// AddHandleId adds i to handleId.
func (m *InspectionMutation) AddHandleId(i int) {
	if m.addhandleId != nil {
		*m.addhandleId += i
	} else {
		m.addhandleId = &i
	}
}

// AddedHandleId returns the value that was added to the handleId field in this mutation.
func (m *InspectionMutation) AddedHandleId() (r int, exists bool) {
	v := m.addhandleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetHandleId reset all changes of the "handleId" field.
func (m *InspectionMutation) ResetHandleId() {
	m.handleId = nil
	m.addhandleId = nil
}

// SetHandleName sets the handleName field.
func (m *InspectionMutation) SetHandleName(s string) {
	m.handleName = &s
}

// HandleName returns the handleName value in the mutation.
func (m *InspectionMutation) HandleName() (r string, exists bool) {
	v := m.handleName
	if v == nil {
		return
	}
	return *v, true
}

// OldHandleName returns the old handleName value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldHandleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHandleName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHandleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHandleName: %w", err)
	}
	return oldValue.HandleName, nil
}

// ResetHandleName reset all changes of the "handleName" field.
func (m *InspectionMutation) ResetHandleName() {
	m.handleName = nil
}

// SetRemarks sets the remarks field.
func (m *InspectionMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *InspectionMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *InspectionMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *InspectionMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *InspectionMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *InspectionMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *InspectionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *InspectionMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *InspectionMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *InspectionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *InspectionMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *InspectionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *InspectionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *InspectionMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *InspectionMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Inspection.
// If the Inspection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InspectionMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *InspectionMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *InspectionMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *InspectionMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *InspectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inspection).
func (m *InspectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InspectionMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.cattleId != nil {
		fields = append(fields, inspection.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, inspection.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, inspection.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, inspection.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, inspection.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, inspection.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, inspection.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, inspection.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, inspection.FieldEarNumber)
	}
	if m.date != nil {
		fields = append(fields, inspection.FieldDate)
	}
	if m.itemId != nil {
		fields = append(fields, inspection.FieldItemId)
	}
	if m.itemName != nil {
		fields = append(fields, inspection.FieldItemName)
	}
	if m.methodId != nil {
		fields = append(fields, inspection.FieldMethodId)
	}
	if m.methodName != nil {
		fields = append(fields, inspection.FieldMethodName)
	}
	if m.byId != nil {
		fields = append(fields, inspection.FieldById)
	}
	if m.byName != nil {
		fields = append(fields, inspection.FieldByName)
	}
	if m.resultId != nil {
		fields = append(fields, inspection.FieldResultId)
	}
	if m.resultName != nil {
		fields = append(fields, inspection.FieldResultName)
	}
	if m.handleId != nil {
		fields = append(fields, inspection.FieldHandleId)
	}
	if m.handleName != nil {
		fields = append(fields, inspection.FieldHandleName)
	}
	if m.remarks != nil {
		fields = append(fields, inspection.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, inspection.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, inspection.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, inspection.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InspectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inspection.FieldCattleId:
		return m.CattleId()
	case inspection.FieldTenantId:
		return m.TenantId()
	case inspection.FieldTenantName:
		return m.TenantName()
	case inspection.FieldFarmId:
		return m.FarmId()
	case inspection.FieldFarmName:
		return m.FarmName()
	case inspection.FieldShedId:
		return m.ShedId()
	case inspection.FieldShedName:
		return m.ShedName()
	case inspection.FieldName:
		return m.Name()
	case inspection.FieldEarNumber:
		return m.EarNumber()
	case inspection.FieldDate:
		return m.Date()
	case inspection.FieldItemId:
		return m.ItemId()
	case inspection.FieldItemName:
		return m.ItemName()
	case inspection.FieldMethodId:
		return m.MethodId()
	case inspection.FieldMethodName:
		return m.MethodName()
	case inspection.FieldById:
		return m.ById()
	case inspection.FieldByName:
		return m.ByName()
	case inspection.FieldResultId:
		return m.ResultId()
	case inspection.FieldResultName:
		return m.ResultName()
	case inspection.FieldHandleId:
		return m.HandleId()
	case inspection.FieldHandleName:
		return m.HandleName()
	case inspection.FieldRemarks:
		return m.Remarks()
	case inspection.FieldCreatedAt:
		return m.CreatedAt()
	case inspection.FieldUpdatedAt:
		return m.UpdatedAt()
	case inspection.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InspectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inspection.FieldCattleId:
		return m.OldCattleId(ctx)
	case inspection.FieldTenantId:
		return m.OldTenantId(ctx)
	case inspection.FieldTenantName:
		return m.OldTenantName(ctx)
	case inspection.FieldFarmId:
		return m.OldFarmId(ctx)
	case inspection.FieldFarmName:
		return m.OldFarmName(ctx)
	case inspection.FieldShedId:
		return m.OldShedId(ctx)
	case inspection.FieldShedName:
		return m.OldShedName(ctx)
	case inspection.FieldName:
		return m.OldName(ctx)
	case inspection.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case inspection.FieldDate:
		return m.OldDate(ctx)
	case inspection.FieldItemId:
		return m.OldItemId(ctx)
	case inspection.FieldItemName:
		return m.OldItemName(ctx)
	case inspection.FieldMethodId:
		return m.OldMethodId(ctx)
	case inspection.FieldMethodName:
		return m.OldMethodName(ctx)
	case inspection.FieldById:
		return m.OldById(ctx)
	case inspection.FieldByName:
		return m.OldByName(ctx)
	case inspection.FieldResultId:
		return m.OldResultId(ctx)
	case inspection.FieldResultName:
		return m.OldResultName(ctx)
	case inspection.FieldHandleId:
		return m.OldHandleId(ctx)
	case inspection.FieldHandleName:
		return m.OldHandleName(ctx)
	case inspection.FieldRemarks:
		return m.OldRemarks(ctx)
	case inspection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inspection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inspection.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Inspection field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InspectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inspection.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case inspection.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case inspection.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case inspection.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case inspection.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case inspection.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case inspection.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case inspection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inspection.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case inspection.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case inspection.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemId(v)
		return nil
	case inspection.FieldItemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemName(v)
		return nil
	case inspection.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodId(v)
		return nil
	case inspection.FieldMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodName(v)
		return nil
	case inspection.FieldById:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetById(v)
		return nil
	case inspection.FieldByName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetByName(v)
		return nil
	case inspection.FieldResultId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultId(v)
		return nil
	case inspection.FieldResultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultName(v)
		return nil
	case inspection.FieldHandleId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleId(v)
		return nil
	case inspection.FieldHandleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHandleName(v)
		return nil
	case inspection.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case inspection.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inspection.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inspection.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Inspection field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InspectionMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, inspection.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, inspection.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, inspection.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, inspection.FieldShedId)
	}
	if m.adddate != nil {
		fields = append(fields, inspection.FieldDate)
	}
	if m.additemId != nil {
		fields = append(fields, inspection.FieldItemId)
	}
	if m.addmethodId != nil {
		fields = append(fields, inspection.FieldMethodId)
	}
	if m.addbyId != nil {
		fields = append(fields, inspection.FieldById)
	}
	if m.addresultId != nil {
		fields = append(fields, inspection.FieldResultId)
	}
	if m.addhandleId != nil {
		fields = append(fields, inspection.FieldHandleId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, inspection.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, inspection.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, inspection.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InspectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inspection.FieldCattleId:
		return m.AddedCattleId()
	case inspection.FieldTenantId:
		return m.AddedTenantId()
	case inspection.FieldFarmId:
		return m.AddedFarmId()
	case inspection.FieldShedId:
		return m.AddedShedId()
	case inspection.FieldDate:
		return m.AddedDate()
	case inspection.FieldItemId:
		return m.AddedItemId()
	case inspection.FieldMethodId:
		return m.AddedMethodId()
	case inspection.FieldById:
		return m.AddedById()
	case inspection.FieldResultId:
		return m.AddedResultId()
	case inspection.FieldHandleId:
		return m.AddedHandleId()
	case inspection.FieldCreatedAt:
		return m.AddedCreatedAt()
	case inspection.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case inspection.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InspectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inspection.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case inspection.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case inspection.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case inspection.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case inspection.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case inspection.FieldItemId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemId(v)
		return nil
	case inspection.FieldMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethodId(v)
		return nil
	case inspection.FieldById:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddById(v)
		return nil
	case inspection.FieldResultId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResultId(v)
		return nil
	case inspection.FieldHandleId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHandleId(v)
		return nil
	case inspection.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case inspection.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case inspection.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Inspection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InspectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InspectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InspectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Inspection nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InspectionMutation) ResetField(name string) error {
	switch name {
	case inspection.FieldCattleId:
		m.ResetCattleId()
		return nil
	case inspection.FieldTenantId:
		m.ResetTenantId()
		return nil
	case inspection.FieldTenantName:
		m.ResetTenantName()
		return nil
	case inspection.FieldFarmId:
		m.ResetFarmId()
		return nil
	case inspection.FieldFarmName:
		m.ResetFarmName()
		return nil
	case inspection.FieldShedId:
		m.ResetShedId()
		return nil
	case inspection.FieldShedName:
		m.ResetShedName()
		return nil
	case inspection.FieldName:
		m.ResetName()
		return nil
	case inspection.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case inspection.FieldDate:
		m.ResetDate()
		return nil
	case inspection.FieldItemId:
		m.ResetItemId()
		return nil
	case inspection.FieldItemName:
		m.ResetItemName()
		return nil
	case inspection.FieldMethodId:
		m.ResetMethodId()
		return nil
	case inspection.FieldMethodName:
		m.ResetMethodName()
		return nil
	case inspection.FieldById:
		m.ResetById()
		return nil
	case inspection.FieldByName:
		m.ResetByName()
		return nil
	case inspection.FieldResultId:
		m.ResetResultId()
		return nil
	case inspection.FieldResultName:
		m.ResetResultName()
		return nil
	case inspection.FieldHandleId:
		m.ResetHandleId()
		return nil
	case inspection.FieldHandleName:
		m.ResetHandleName()
		return nil
	case inspection.FieldRemarks:
		m.ResetRemarks()
		return nil
	case inspection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inspection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inspection.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Inspection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InspectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InspectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InspectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InspectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InspectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InspectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InspectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Inspection unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InspectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Inspection edge %s", name)
}

// InventoryFlowMutation represents an operation that mutate the InventoryFlows
// nodes in the graph.
type InventoryFlowMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	sysMaterialId     *int64
	addsysMaterialId  *int64
	materialId        *int64
	addmaterialId     *int64
	materialName      *string
	materialCode      *string
	seqNumber         *string
	date              *int64
	adddate           *int64
	_type             *int
	add_type          *int
	status            *string
	count             *int
	addcount          *int
	unit              *string
	before            *int64
	addbefore         *int64
	after             *int64
	addafter          *int64
	userName          *string
	tenantId          *int64
	addtenantId       *int64
	tenantName        *string
	farmId            *int64
	addfarmId         *int64
	farmName          *string
	remarks           *string
	isChecked         *bool
	reportFileAddress *string
	createdAt         *int64
	addcreatedAt      *int64
	updatedAt         *int64
	addupdatedAt      *int64
	deleted           *int
	adddeleted        *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*InventoryFlow, error)
}

var _ ent.Mutation = (*InventoryFlowMutation)(nil)

// inventoryflowOption allows to manage the mutation configuration using functional options.
type inventoryflowOption func(*InventoryFlowMutation)

// newInventoryFlowMutation creates new mutation for $n.Name.
func newInventoryFlowMutation(c config, op Op, opts ...inventoryflowOption) *InventoryFlowMutation {
	m := &InventoryFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryFlowID sets the id field of the mutation.
func withInventoryFlowID(id int64) inventoryflowOption {
	return func(m *InventoryFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryFlow
		)
		m.oldValue = func(ctx context.Context) (*InventoryFlow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryFlow sets the old InventoryFlow of the mutation.
func withInventoryFlow(node *InventoryFlow) inventoryflowOption {
	return func(m *InventoryFlowMutation) {
		m.oldValue = func(context.Context) (*InventoryFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InventoryFlowMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSysMaterialId sets the sysMaterialId field.
func (m *InventoryFlowMutation) SetSysMaterialId(i int64) {
	m.sysMaterialId = &i
	m.addsysMaterialId = nil
}

// SysMaterialId returns the sysMaterialId value in the mutation.
func (m *InventoryFlowMutation) SysMaterialId() (r int64, exists bool) {
	v := m.sysMaterialId
	if v == nil {
		return
	}
	return *v, true
}

// OldSysMaterialId returns the old sysMaterialId value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldSysMaterialId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSysMaterialId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSysMaterialId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSysMaterialId: %w", err)
	}
	return oldValue.SysMaterialId, nil
}

// AddSysMaterialId adds i to sysMaterialId.
func (m *InventoryFlowMutation) AddSysMaterialId(i int64) {
	if m.addsysMaterialId != nil {
		*m.addsysMaterialId += i
	} else {
		m.addsysMaterialId = &i
	}
}

// AddedSysMaterialId returns the value that was added to the sysMaterialId field in this mutation.
func (m *InventoryFlowMutation) AddedSysMaterialId() (r int64, exists bool) {
	v := m.addsysMaterialId
	if v == nil {
		return
	}
	return *v, true
}

// ResetSysMaterialId reset all changes of the "sysMaterialId" field.
func (m *InventoryFlowMutation) ResetSysMaterialId() {
	m.sysMaterialId = nil
	m.addsysMaterialId = nil
}

// SetMaterialId sets the materialId field.
func (m *InventoryFlowMutation) SetMaterialId(i int64) {
	m.materialId = &i
	m.addmaterialId = nil
}

// MaterialId returns the materialId value in the mutation.
func (m *InventoryFlowMutation) MaterialId() (r int64, exists bool) {
	v := m.materialId
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialId returns the old materialId value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldMaterialId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialId: %w", err)
	}
	return oldValue.MaterialId, nil
}

// AddMaterialId adds i to materialId.
func (m *InventoryFlowMutation) AddMaterialId(i int64) {
	if m.addmaterialId != nil {
		*m.addmaterialId += i
	} else {
		m.addmaterialId = &i
	}
}

// AddedMaterialId returns the value that was added to the materialId field in this mutation.
func (m *InventoryFlowMutation) AddedMaterialId() (r int64, exists bool) {
	v := m.addmaterialId
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaterialId reset all changes of the "materialId" field.
func (m *InventoryFlowMutation) ResetMaterialId() {
	m.materialId = nil
	m.addmaterialId = nil
}

// SetMaterialName sets the materialName field.
func (m *InventoryFlowMutation) SetMaterialName(s string) {
	m.materialName = &s
}

// MaterialName returns the materialName value in the mutation.
func (m *InventoryFlowMutation) MaterialName() (r string, exists bool) {
	v := m.materialName
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialName returns the old materialName value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldMaterialName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialName: %w", err)
	}
	return oldValue.MaterialName, nil
}

// ResetMaterialName reset all changes of the "materialName" field.
func (m *InventoryFlowMutation) ResetMaterialName() {
	m.materialName = nil
}

// SetMaterialCode sets the materialCode field.
func (m *InventoryFlowMutation) SetMaterialCode(s string) {
	m.materialCode = &s
}

// MaterialCode returns the materialCode value in the mutation.
func (m *InventoryFlowMutation) MaterialCode() (r string, exists bool) {
	v := m.materialCode
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialCode returns the old materialCode value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldMaterialCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialCode: %w", err)
	}
	return oldValue.MaterialCode, nil
}

// ResetMaterialCode reset all changes of the "materialCode" field.
func (m *InventoryFlowMutation) ResetMaterialCode() {
	m.materialCode = nil
}

// SetSeqNumber sets the seqNumber field.
func (m *InventoryFlowMutation) SetSeqNumber(s string) {
	m.seqNumber = &s
}

// SeqNumber returns the seqNumber value in the mutation.
func (m *InventoryFlowMutation) SeqNumber() (r string, exists bool) {
	v := m.seqNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNumber returns the old seqNumber value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldSeqNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeqNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeqNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNumber: %w", err)
	}
	return oldValue.SeqNumber, nil
}

// ResetSeqNumber reset all changes of the "seqNumber" field.
func (m *InventoryFlowMutation) ResetSeqNumber() {
	m.seqNumber = nil
}

// SetDate sets the date field.
func (m *InventoryFlowMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *InventoryFlowMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *InventoryFlowMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *InventoryFlowMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *InventoryFlowMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetType sets the type field.
func (m *InventoryFlowMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *InventoryFlowMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *InventoryFlowMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *InventoryFlowMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *InventoryFlowMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStatus sets the status field.
func (m *InventoryFlowMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the status value in the mutation.
func (m *InventoryFlowMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus reset all changes of the "status" field.
func (m *InventoryFlowMutation) ResetStatus() {
	m.status = nil
}

// SetCount sets the count field.
func (m *InventoryFlowMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the count value in the mutation.
func (m *InventoryFlowMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old count value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to count.
func (m *InventoryFlowMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the count field in this mutation.
func (m *InventoryFlowMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount reset all changes of the "count" field.
func (m *InventoryFlowMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetUnit sets the unit field.
func (m *InventoryFlowMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the unit value in the mutation.
func (m *InventoryFlowMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old unit value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit reset all changes of the "unit" field.
func (m *InventoryFlowMutation) ResetUnit() {
	m.unit = nil
}

// SetBefore sets the before field.
func (m *InventoryFlowMutation) SetBefore(i int64) {
	m.before = &i
	m.addbefore = nil
}

// Before returns the before value in the mutation.
func (m *InventoryFlowMutation) Before() (r int64, exists bool) {
	v := m.before
	if v == nil {
		return
	}
	return *v, true
}

// OldBefore returns the old before value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldBefore(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBefore is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBefore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBefore: %w", err)
	}
	return oldValue.Before, nil
}

// AddBefore adds i to before.
func (m *InventoryFlowMutation) AddBefore(i int64) {
	if m.addbefore != nil {
		*m.addbefore += i
	} else {
		m.addbefore = &i
	}
}

// AddedBefore returns the value that was added to the before field in this mutation.
func (m *InventoryFlowMutation) AddedBefore() (r int64, exists bool) {
	v := m.addbefore
	if v == nil {
		return
	}
	return *v, true
}

// ResetBefore reset all changes of the "before" field.
func (m *InventoryFlowMutation) ResetBefore() {
	m.before = nil
	m.addbefore = nil
}

// SetAfter sets the after field.
func (m *InventoryFlowMutation) SetAfter(i int64) {
	m.after = &i
	m.addafter = nil
}

// After returns the after value in the mutation.
func (m *InventoryFlowMutation) After() (r int64, exists bool) {
	v := m.after
	if v == nil {
		return
	}
	return *v, true
}

// OldAfter returns the old after value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldAfter(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAfter is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfter: %w", err)
	}
	return oldValue.After, nil
}

// AddAfter adds i to after.
func (m *InventoryFlowMutation) AddAfter(i int64) {
	if m.addafter != nil {
		*m.addafter += i
	} else {
		m.addafter = &i
	}
}

// AddedAfter returns the value that was added to the after field in this mutation.
func (m *InventoryFlowMutation) AddedAfter() (r int64, exists bool) {
	v := m.addafter
	if v == nil {
		return
	}
	return *v, true
}

// ResetAfter reset all changes of the "after" field.
func (m *InventoryFlowMutation) ResetAfter() {
	m.after = nil
	m.addafter = nil
}

// SetUserName sets the userName field.
func (m *InventoryFlowMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *InventoryFlowMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *InventoryFlowMutation) ResetUserName() {
	m.userName = nil
}

// SetTenantId sets the tenantId field.
func (m *InventoryFlowMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *InventoryFlowMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *InventoryFlowMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *InventoryFlowMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *InventoryFlowMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *InventoryFlowMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *InventoryFlowMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *InventoryFlowMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *InventoryFlowMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *InventoryFlowMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *InventoryFlowMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *InventoryFlowMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *InventoryFlowMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *InventoryFlowMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *InventoryFlowMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *InventoryFlowMutation) ResetFarmName() {
	m.farmName = nil
}

// SetRemarks sets the remarks field.
func (m *InventoryFlowMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *InventoryFlowMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *InventoryFlowMutation) ResetRemarks() {
	m.remarks = nil
}

// SetIsChecked sets the isChecked field.
func (m *InventoryFlowMutation) SetIsChecked(b bool) {
	m.isChecked = &b
}

// IsChecked returns the isChecked value in the mutation.
func (m *InventoryFlowMutation) IsChecked() (r bool, exists bool) {
	v := m.isChecked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsChecked returns the old isChecked value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldIsChecked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsChecked is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsChecked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsChecked: %w", err)
	}
	return oldValue.IsChecked, nil
}

// ResetIsChecked reset all changes of the "isChecked" field.
func (m *InventoryFlowMutation) ResetIsChecked() {
	m.isChecked = nil
}

// SetReportFileAddress sets the reportFileAddress field.
func (m *InventoryFlowMutation) SetReportFileAddress(s string) {
	m.reportFileAddress = &s
}

// ReportFileAddress returns the reportFileAddress value in the mutation.
func (m *InventoryFlowMutation) ReportFileAddress() (r string, exists bool) {
	v := m.reportFileAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldReportFileAddress returns the old reportFileAddress value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldReportFileAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReportFileAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReportFileAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportFileAddress: %w", err)
	}
	return oldValue.ReportFileAddress, nil
}

// ResetReportFileAddress reset all changes of the "reportFileAddress" field.
func (m *InventoryFlowMutation) ResetReportFileAddress() {
	m.reportFileAddress = nil
}

// SetCreatedAt sets the createdAt field.
func (m *InventoryFlowMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *InventoryFlowMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *InventoryFlowMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *InventoryFlowMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *InventoryFlowMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *InventoryFlowMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *InventoryFlowMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *InventoryFlowMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *InventoryFlowMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *InventoryFlowMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *InventoryFlowMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *InventoryFlowMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the InventoryFlow.
// If the InventoryFlow object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InventoryFlowMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *InventoryFlowMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *InventoryFlowMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *InventoryFlowMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *InventoryFlowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InventoryFlow).
func (m *InventoryFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InventoryFlowMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.sysMaterialId != nil {
		fields = append(fields, inventoryflow.FieldSysMaterialId)
	}
	if m.materialId != nil {
		fields = append(fields, inventoryflow.FieldMaterialId)
	}
	if m.materialName != nil {
		fields = append(fields, inventoryflow.FieldMaterialName)
	}
	if m.materialCode != nil {
		fields = append(fields, inventoryflow.FieldMaterialCode)
	}
	if m.seqNumber != nil {
		fields = append(fields, inventoryflow.FieldSeqNumber)
	}
	if m.date != nil {
		fields = append(fields, inventoryflow.FieldDate)
	}
	if m._type != nil {
		fields = append(fields, inventoryflow.FieldType)
	}
	if m.status != nil {
		fields = append(fields, inventoryflow.FieldStatus)
	}
	if m.count != nil {
		fields = append(fields, inventoryflow.FieldCount)
	}
	if m.unit != nil {
		fields = append(fields, inventoryflow.FieldUnit)
	}
	if m.before != nil {
		fields = append(fields, inventoryflow.FieldBefore)
	}
	if m.after != nil {
		fields = append(fields, inventoryflow.FieldAfter)
	}
	if m.userName != nil {
		fields = append(fields, inventoryflow.FieldUserName)
	}
	if m.tenantId != nil {
		fields = append(fields, inventoryflow.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, inventoryflow.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, inventoryflow.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, inventoryflow.FieldFarmName)
	}
	if m.remarks != nil {
		fields = append(fields, inventoryflow.FieldRemarks)
	}
	if m.isChecked != nil {
		fields = append(fields, inventoryflow.FieldIsChecked)
	}
	if m.reportFileAddress != nil {
		fields = append(fields, inventoryflow.FieldReportFileAddress)
	}
	if m.createdAt != nil {
		fields = append(fields, inventoryflow.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, inventoryflow.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, inventoryflow.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InventoryFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryflow.FieldSysMaterialId:
		return m.SysMaterialId()
	case inventoryflow.FieldMaterialId:
		return m.MaterialId()
	case inventoryflow.FieldMaterialName:
		return m.MaterialName()
	case inventoryflow.FieldMaterialCode:
		return m.MaterialCode()
	case inventoryflow.FieldSeqNumber:
		return m.SeqNumber()
	case inventoryflow.FieldDate:
		return m.Date()
	case inventoryflow.FieldType:
		return m.GetType()
	case inventoryflow.FieldStatus:
		return m.Status()
	case inventoryflow.FieldCount:
		return m.Count()
	case inventoryflow.FieldUnit:
		return m.Unit()
	case inventoryflow.FieldBefore:
		return m.Before()
	case inventoryflow.FieldAfter:
		return m.After()
	case inventoryflow.FieldUserName:
		return m.UserName()
	case inventoryflow.FieldTenantId:
		return m.TenantId()
	case inventoryflow.FieldTenantName:
		return m.TenantName()
	case inventoryflow.FieldFarmId:
		return m.FarmId()
	case inventoryflow.FieldFarmName:
		return m.FarmName()
	case inventoryflow.FieldRemarks:
		return m.Remarks()
	case inventoryflow.FieldIsChecked:
		return m.IsChecked()
	case inventoryflow.FieldReportFileAddress:
		return m.ReportFileAddress()
	case inventoryflow.FieldCreatedAt:
		return m.CreatedAt()
	case inventoryflow.FieldUpdatedAt:
		return m.UpdatedAt()
	case inventoryflow.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InventoryFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryflow.FieldSysMaterialId:
		return m.OldSysMaterialId(ctx)
	case inventoryflow.FieldMaterialId:
		return m.OldMaterialId(ctx)
	case inventoryflow.FieldMaterialName:
		return m.OldMaterialName(ctx)
	case inventoryflow.FieldMaterialCode:
		return m.OldMaterialCode(ctx)
	case inventoryflow.FieldSeqNumber:
		return m.OldSeqNumber(ctx)
	case inventoryflow.FieldDate:
		return m.OldDate(ctx)
	case inventoryflow.FieldType:
		return m.OldType(ctx)
	case inventoryflow.FieldStatus:
		return m.OldStatus(ctx)
	case inventoryflow.FieldCount:
		return m.OldCount(ctx)
	case inventoryflow.FieldUnit:
		return m.OldUnit(ctx)
	case inventoryflow.FieldBefore:
		return m.OldBefore(ctx)
	case inventoryflow.FieldAfter:
		return m.OldAfter(ctx)
	case inventoryflow.FieldUserName:
		return m.OldUserName(ctx)
	case inventoryflow.FieldTenantId:
		return m.OldTenantId(ctx)
	case inventoryflow.FieldTenantName:
		return m.OldTenantName(ctx)
	case inventoryflow.FieldFarmId:
		return m.OldFarmId(ctx)
	case inventoryflow.FieldFarmName:
		return m.OldFarmName(ctx)
	case inventoryflow.FieldRemarks:
		return m.OldRemarks(ctx)
	case inventoryflow.FieldIsChecked:
		return m.OldIsChecked(ctx)
	case inventoryflow.FieldReportFileAddress:
		return m.OldReportFileAddress(ctx)
	case inventoryflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inventoryflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inventoryflow.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryFlow field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InventoryFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryflow.FieldSysMaterialId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSysMaterialId(v)
		return nil
	case inventoryflow.FieldMaterialId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialId(v)
		return nil
	case inventoryflow.FieldMaterialName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialName(v)
		return nil
	case inventoryflow.FieldMaterialCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialCode(v)
		return nil
	case inventoryflow.FieldSeqNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNumber(v)
		return nil
	case inventoryflow.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case inventoryflow.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case inventoryflow.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case inventoryflow.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case inventoryflow.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case inventoryflow.FieldBefore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBefore(v)
		return nil
	case inventoryflow.FieldAfter:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfter(v)
		return nil
	case inventoryflow.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case inventoryflow.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case inventoryflow.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case inventoryflow.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case inventoryflow.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case inventoryflow.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case inventoryflow.FieldIsChecked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsChecked(v)
		return nil
	case inventoryflow.FieldReportFileAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportFileAddress(v)
		return nil
	case inventoryflow.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inventoryflow.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inventoryflow.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InventoryFlowMutation) AddedFields() []string {
	var fields []string
	if m.addsysMaterialId != nil {
		fields = append(fields, inventoryflow.FieldSysMaterialId)
	}
	if m.addmaterialId != nil {
		fields = append(fields, inventoryflow.FieldMaterialId)
	}
	if m.adddate != nil {
		fields = append(fields, inventoryflow.FieldDate)
	}
	if m.add_type != nil {
		fields = append(fields, inventoryflow.FieldType)
	}
	if m.addcount != nil {
		fields = append(fields, inventoryflow.FieldCount)
	}
	if m.addbefore != nil {
		fields = append(fields, inventoryflow.FieldBefore)
	}
	if m.addafter != nil {
		fields = append(fields, inventoryflow.FieldAfter)
	}
	if m.addtenantId != nil {
		fields = append(fields, inventoryflow.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, inventoryflow.FieldFarmId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, inventoryflow.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, inventoryflow.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, inventoryflow.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InventoryFlowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventoryflow.FieldSysMaterialId:
		return m.AddedSysMaterialId()
	case inventoryflow.FieldMaterialId:
		return m.AddedMaterialId()
	case inventoryflow.FieldDate:
		return m.AddedDate()
	case inventoryflow.FieldType:
		return m.AddedType()
	case inventoryflow.FieldCount:
		return m.AddedCount()
	case inventoryflow.FieldBefore:
		return m.AddedBefore()
	case inventoryflow.FieldAfter:
		return m.AddedAfter()
	case inventoryflow.FieldTenantId:
		return m.AddedTenantId()
	case inventoryflow.FieldFarmId:
		return m.AddedFarmId()
	case inventoryflow.FieldCreatedAt:
		return m.AddedCreatedAt()
	case inventoryflow.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case inventoryflow.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InventoryFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventoryflow.FieldSysMaterialId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSysMaterialId(v)
		return nil
	case inventoryflow.FieldMaterialId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialId(v)
		return nil
	case inventoryflow.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case inventoryflow.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case inventoryflow.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case inventoryflow.FieldBefore:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBefore(v)
		return nil
	case inventoryflow.FieldAfter:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfter(v)
		return nil
	case inventoryflow.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case inventoryflow.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case inventoryflow.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case inventoryflow.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case inventoryflow.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InventoryFlowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InventoryFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryFlowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InventoryFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InventoryFlowMutation) ResetField(name string) error {
	switch name {
	case inventoryflow.FieldSysMaterialId:
		m.ResetSysMaterialId()
		return nil
	case inventoryflow.FieldMaterialId:
		m.ResetMaterialId()
		return nil
	case inventoryflow.FieldMaterialName:
		m.ResetMaterialName()
		return nil
	case inventoryflow.FieldMaterialCode:
		m.ResetMaterialCode()
		return nil
	case inventoryflow.FieldSeqNumber:
		m.ResetSeqNumber()
		return nil
	case inventoryflow.FieldDate:
		m.ResetDate()
		return nil
	case inventoryflow.FieldType:
		m.ResetType()
		return nil
	case inventoryflow.FieldStatus:
		m.ResetStatus()
		return nil
	case inventoryflow.FieldCount:
		m.ResetCount()
		return nil
	case inventoryflow.FieldUnit:
		m.ResetUnit()
		return nil
	case inventoryflow.FieldBefore:
		m.ResetBefore()
		return nil
	case inventoryflow.FieldAfter:
		m.ResetAfter()
		return nil
	case inventoryflow.FieldUserName:
		m.ResetUserName()
		return nil
	case inventoryflow.FieldTenantId:
		m.ResetTenantId()
		return nil
	case inventoryflow.FieldTenantName:
		m.ResetTenantName()
		return nil
	case inventoryflow.FieldFarmId:
		m.ResetFarmId()
		return nil
	case inventoryflow.FieldFarmName:
		m.ResetFarmName()
		return nil
	case inventoryflow.FieldRemarks:
		m.ResetRemarks()
		return nil
	case inventoryflow.FieldIsChecked:
		m.ResetIsChecked()
		return nil
	case inventoryflow.FieldReportFileAddress:
		m.ResetReportFileAddress()
		return nil
	case inventoryflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inventoryflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inventoryflow.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown InventoryFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InventoryFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InventoryFlowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InventoryFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InventoryFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InventoryFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InventoryFlowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InventoryFlowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown InventoryFlow unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InventoryFlowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown InventoryFlow edge %s", name)
}

// MaterialMutation represents an operation that mutate the Materials
// nodes in the graph.
type MaterialMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	materialId    *int64
	addmaterialId *int64
	categoryId    *int
	addcategoryId *int
	categoryName  *string
	userName      *string
	inventory     *int64
	addinventory  *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Material, error)
}

var _ ent.Mutation = (*MaterialMutation)(nil)

// materialOption allows to manage the mutation configuration using functional options.
type materialOption func(*MaterialMutation)

// newMaterialMutation creates new mutation for $n.Name.
func newMaterialMutation(c config, op Op, opts ...materialOption) *MaterialMutation {
	m := &MaterialMutation{
		config:        c,
		op:            op,
		typ:           TypeMaterial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaterialID sets the id field of the mutation.
func withMaterialID(id int64) materialOption {
	return func(m *MaterialMutation) {
		var (
			err   error
			once  sync.Once
			value *Material
		)
		m.oldValue = func(ctx context.Context) (*Material, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Material.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaterial sets the old Material of the mutation.
func withMaterial(node *Material) materialOption {
	return func(m *MaterialMutation) {
		m.oldValue = func(context.Context) (*Material, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaterialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaterialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MaterialMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MaterialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MaterialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MaterialMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *MaterialMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *MaterialMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *MaterialMutation) ResetCode() {
	m.code = nil
}

// SetMaterialId sets the materialId field.
func (m *MaterialMutation) SetMaterialId(i int64) {
	m.materialId = &i
	m.addmaterialId = nil
}

// MaterialId returns the materialId value in the mutation.
func (m *MaterialMutation) MaterialId() (r int64, exists bool) {
	v := m.materialId
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialId returns the old materialId value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldMaterialId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialId: %w", err)
	}
	return oldValue.MaterialId, nil
}

// AddMaterialId adds i to materialId.
func (m *MaterialMutation) AddMaterialId(i int64) {
	if m.addmaterialId != nil {
		*m.addmaterialId += i
	} else {
		m.addmaterialId = &i
	}
}

// AddedMaterialId returns the value that was added to the materialId field in this mutation.
func (m *MaterialMutation) AddedMaterialId() (r int64, exists bool) {
	v := m.addmaterialId
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaterialId reset all changes of the "materialId" field.
func (m *MaterialMutation) ResetMaterialId() {
	m.materialId = nil
	m.addmaterialId = nil
}

// SetCategoryId sets the categoryId field.
func (m *MaterialMutation) SetCategoryId(i int) {
	m.categoryId = &i
	m.addcategoryId = nil
}

// CategoryId returns the categoryId value in the mutation.
func (m *MaterialMutation) CategoryId() (r int, exists bool) {
	v := m.categoryId
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryId returns the old categoryId value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCategoryId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryId: %w", err)
	}
	return oldValue.CategoryId, nil
}

// AddCategoryId adds i to categoryId.
func (m *MaterialMutation) AddCategoryId(i int) {
	if m.addcategoryId != nil {
		*m.addcategoryId += i
	} else {
		m.addcategoryId = &i
	}
}

// AddedCategoryId returns the value that was added to the categoryId field in this mutation.
func (m *MaterialMutation) AddedCategoryId() (r int, exists bool) {
	v := m.addcategoryId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryId reset all changes of the "categoryId" field.
func (m *MaterialMutation) ResetCategoryId() {
	m.categoryId = nil
	m.addcategoryId = nil
}

// SetCategoryName sets the categoryName field.
func (m *MaterialMutation) SetCategoryName(s string) {
	m.categoryName = &s
}

// CategoryName returns the categoryName value in the mutation.
func (m *MaterialMutation) CategoryName() (r string, exists bool) {
	v := m.categoryName
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryName returns the old categoryName value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCategoryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryName: %w", err)
	}
	return oldValue.CategoryName, nil
}

// ResetCategoryName reset all changes of the "categoryName" field.
func (m *MaterialMutation) ResetCategoryName() {
	m.categoryName = nil
}

// SetUserName sets the userName field.
func (m *MaterialMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *MaterialMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *MaterialMutation) ResetUserName() {
	m.userName = nil
}

// SetInventory sets the inventory field.
func (m *MaterialMutation) SetInventory(i int64) {
	m.inventory = &i
	m.addinventory = nil
}

// Inventory returns the inventory value in the mutation.
func (m *MaterialMutation) Inventory() (r int64, exists bool) {
	v := m.inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldInventory returns the old inventory value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldInventory(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInventory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventory: %w", err)
	}
	return oldValue.Inventory, nil
}

// AddInventory adds i to inventory.
func (m *MaterialMutation) AddInventory(i int64) {
	if m.addinventory != nil {
		*m.addinventory += i
	} else {
		m.addinventory = &i
	}
}

// AddedInventory returns the value that was added to the inventory field in this mutation.
func (m *MaterialMutation) AddedInventory() (r int64, exists bool) {
	v := m.addinventory
	if v == nil {
		return
	}
	return *v, true
}

// ResetInventory reset all changes of the "inventory" field.
func (m *MaterialMutation) ResetInventory() {
	m.inventory = nil
	m.addinventory = nil
}

// SetTenantId sets the tenantId field.
func (m *MaterialMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *MaterialMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *MaterialMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *MaterialMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *MaterialMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *MaterialMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *MaterialMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *MaterialMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *MaterialMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *MaterialMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *MaterialMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *MaterialMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *MaterialMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *MaterialMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *MaterialMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *MaterialMutation) ResetFarmName() {
	m.farmName = nil
}

// SetRemarks sets the remarks field.
func (m *MaterialMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *MaterialMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *MaterialMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *MaterialMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *MaterialMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *MaterialMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *MaterialMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *MaterialMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *MaterialMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *MaterialMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *MaterialMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *MaterialMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *MaterialMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *MaterialMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *MaterialMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Material.
// If the Material object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *MaterialMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *MaterialMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *MaterialMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *MaterialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Material).
func (m *MaterialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MaterialMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, material.FieldName)
	}
	if m.code != nil {
		fields = append(fields, material.FieldCode)
	}
	if m.materialId != nil {
		fields = append(fields, material.FieldMaterialId)
	}
	if m.categoryId != nil {
		fields = append(fields, material.FieldCategoryId)
	}
	if m.categoryName != nil {
		fields = append(fields, material.FieldCategoryName)
	}
	if m.userName != nil {
		fields = append(fields, material.FieldUserName)
	}
	if m.inventory != nil {
		fields = append(fields, material.FieldInventory)
	}
	if m.tenantId != nil {
		fields = append(fields, material.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, material.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, material.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, material.FieldFarmName)
	}
	if m.remarks != nil {
		fields = append(fields, material.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, material.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, material.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, material.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MaterialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case material.FieldName:
		return m.Name()
	case material.FieldCode:
		return m.Code()
	case material.FieldMaterialId:
		return m.MaterialId()
	case material.FieldCategoryId:
		return m.CategoryId()
	case material.FieldCategoryName:
		return m.CategoryName()
	case material.FieldUserName:
		return m.UserName()
	case material.FieldInventory:
		return m.Inventory()
	case material.FieldTenantId:
		return m.TenantId()
	case material.FieldTenantName:
		return m.TenantName()
	case material.FieldFarmId:
		return m.FarmId()
	case material.FieldFarmName:
		return m.FarmName()
	case material.FieldRemarks:
		return m.Remarks()
	case material.FieldCreatedAt:
		return m.CreatedAt()
	case material.FieldUpdatedAt:
		return m.UpdatedAt()
	case material.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MaterialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case material.FieldName:
		return m.OldName(ctx)
	case material.FieldCode:
		return m.OldCode(ctx)
	case material.FieldMaterialId:
		return m.OldMaterialId(ctx)
	case material.FieldCategoryId:
		return m.OldCategoryId(ctx)
	case material.FieldCategoryName:
		return m.OldCategoryName(ctx)
	case material.FieldUserName:
		return m.OldUserName(ctx)
	case material.FieldInventory:
		return m.OldInventory(ctx)
	case material.FieldTenantId:
		return m.OldTenantId(ctx)
	case material.FieldTenantName:
		return m.OldTenantName(ctx)
	case material.FieldFarmId:
		return m.OldFarmId(ctx)
	case material.FieldFarmName:
		return m.OldFarmName(ctx)
	case material.FieldRemarks:
		return m.OldRemarks(ctx)
	case material.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case material.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case material.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Material field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case material.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case material.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case material.FieldMaterialId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialId(v)
		return nil
	case material.FieldCategoryId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryId(v)
		return nil
	case material.FieldCategoryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryName(v)
		return nil
	case material.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case material.FieldInventory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventory(v)
		return nil
	case material.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case material.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case material.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case material.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case material.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case material.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case material.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case material.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Material field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MaterialMutation) AddedFields() []string {
	var fields []string
	if m.addmaterialId != nil {
		fields = append(fields, material.FieldMaterialId)
	}
	if m.addcategoryId != nil {
		fields = append(fields, material.FieldCategoryId)
	}
	if m.addinventory != nil {
		fields = append(fields, material.FieldInventory)
	}
	if m.addtenantId != nil {
		fields = append(fields, material.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, material.FieldFarmId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, material.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, material.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, material.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MaterialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case material.FieldMaterialId:
		return m.AddedMaterialId()
	case material.FieldCategoryId:
		return m.AddedCategoryId()
	case material.FieldInventory:
		return m.AddedInventory()
	case material.FieldTenantId:
		return m.AddedTenantId()
	case material.FieldFarmId:
		return m.AddedFarmId()
	case material.FieldCreatedAt:
		return m.AddedCreatedAt()
	case material.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case material.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case material.FieldMaterialId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialId(v)
		return nil
	case material.FieldCategoryId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryId(v)
		return nil
	case material.FieldInventory:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInventory(v)
		return nil
	case material.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case material.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case material.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case material.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case material.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Material numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MaterialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MaterialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaterialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Material nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MaterialMutation) ResetField(name string) error {
	switch name {
	case material.FieldName:
		m.ResetName()
		return nil
	case material.FieldCode:
		m.ResetCode()
		return nil
	case material.FieldMaterialId:
		m.ResetMaterialId()
		return nil
	case material.FieldCategoryId:
		m.ResetCategoryId()
		return nil
	case material.FieldCategoryName:
		m.ResetCategoryName()
		return nil
	case material.FieldUserName:
		m.ResetUserName()
		return nil
	case material.FieldInventory:
		m.ResetInventory()
		return nil
	case material.FieldTenantId:
		m.ResetTenantId()
		return nil
	case material.FieldTenantName:
		m.ResetTenantName()
		return nil
	case material.FieldFarmId:
		m.ResetFarmId()
		return nil
	case material.FieldFarmName:
		m.ResetFarmName()
		return nil
	case material.FieldRemarks:
		m.ResetRemarks()
		return nil
	case material.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case material.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case material.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Material field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MaterialMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MaterialMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MaterialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MaterialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MaterialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MaterialMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MaterialMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Material unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MaterialMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Material edge %s", name)
}

// MaterialTestMutation represents an operation that mutate the MaterialTests
// nodes in the graph.
type MaterialTestMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	name                *string
	code                *string
	seqNumber           *string
	addSeqNumber        *string
	date                *int64
	adddate             *int64
	_type               *int
	add_type            *int
	category            *int
	addcategory         *int
	materialCategory    *int
	addmaterialCategory *int
	userName            *string
	tenantId            *int64
	addtenantId         *int64
	tenantName          *string
	remarks             *string
	createdAt           *int64
	addcreatedAt        *int64
	updatedAt           *int64
	addupdatedAt        *int64
	deleted             *int
	adddeleted          *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*MaterialTest, error)
}

var _ ent.Mutation = (*MaterialTestMutation)(nil)

// materialtestOption allows to manage the mutation configuration using functional options.
type materialtestOption func(*MaterialTestMutation)

// newMaterialTestMutation creates new mutation for $n.Name.
func newMaterialTestMutation(c config, op Op, opts ...materialtestOption) *MaterialTestMutation {
	m := &MaterialTestMutation{
		config:        c,
		op:            op,
		typ:           TypeMaterialTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaterialTestID sets the id field of the mutation.
func withMaterialTestID(id int64) materialtestOption {
	return func(m *MaterialTestMutation) {
		var (
			err   error
			once  sync.Once
			value *MaterialTest
		)
		m.oldValue = func(ctx context.Context) (*MaterialTest, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MaterialTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaterialTest sets the old MaterialTest of the mutation.
func withMaterialTest(node *MaterialTest) materialtestOption {
	return func(m *MaterialTestMutation) {
		m.oldValue = func(context.Context) (*MaterialTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaterialTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaterialTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MaterialTestMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MaterialTestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MaterialTestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MaterialTestMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *MaterialTestMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *MaterialTestMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *MaterialTestMutation) ResetCode() {
	m.code = nil
}

// SetSeqNumber sets the seqNumber field.
func (m *MaterialTestMutation) SetSeqNumber(s string) {
	m.seqNumber = &s
}

// SeqNumber returns the seqNumber value in the mutation.
func (m *MaterialTestMutation) SeqNumber() (r string, exists bool) {
	v := m.seqNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldSeqNumber returns the old seqNumber value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldSeqNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeqNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeqNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeqNumber: %w", err)
	}
	return oldValue.SeqNumber, nil
}

// ResetSeqNumber reset all changes of the "seqNumber" field.
func (m *MaterialTestMutation) ResetSeqNumber() {
	m.seqNumber = nil
}

// SetAddSeqNumber sets the addSeqNumber field.
func (m *MaterialTestMutation) SetAddSeqNumber(s string) {
	m.addSeqNumber = &s
}

// AddSeqNumber returns the addSeqNumber value in the mutation.
func (m *MaterialTestMutation) AddSeqNumber() (r string, exists bool) {
	v := m.addSeqNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldAddSeqNumber returns the old addSeqNumber value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldAddSeqNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddSeqNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddSeqNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddSeqNumber: %w", err)
	}
	return oldValue.AddSeqNumber, nil
}

// ResetAddSeqNumber reset all changes of the "addSeqNumber" field.
func (m *MaterialTestMutation) ResetAddSeqNumber() {
	m.addSeqNumber = nil
}

// SetDate sets the date field.
func (m *MaterialTestMutation) SetDate(i int64) {
	m.date = &i
	m.adddate = nil
}

// Date returns the date value in the mutation.
func (m *MaterialTestMutation) Date() (r int64, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old date value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// AddDate adds i to date.
func (m *MaterialTestMutation) AddDate(i int64) {
	if m.adddate != nil {
		*m.adddate += i
	} else {
		m.adddate = &i
	}
}

// AddedDate returns the value that was added to the date field in this mutation.
func (m *MaterialTestMutation) AddedDate() (r int64, exists bool) {
	v := m.adddate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDate reset all changes of the "date" field.
func (m *MaterialTestMutation) ResetDate() {
	m.date = nil
	m.adddate = nil
}

// SetType sets the type field.
func (m *MaterialTestMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *MaterialTestMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *MaterialTestMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *MaterialTestMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *MaterialTestMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetCategory sets the category field.
func (m *MaterialTestMutation) SetCategory(i int) {
	m.category = &i
	m.addcategory = nil
}

// Category returns the category value in the mutation.
func (m *MaterialTestMutation) Category() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old category value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldCategory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// AddCategory adds i to category.
func (m *MaterialTestMutation) AddCategory(i int) {
	if m.addcategory != nil {
		*m.addcategory += i
	} else {
		m.addcategory = &i
	}
}

// AddedCategory returns the value that was added to the category field in this mutation.
func (m *MaterialTestMutation) AddedCategory() (r int, exists bool) {
	v := m.addcategory
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategory reset all changes of the "category" field.
func (m *MaterialTestMutation) ResetCategory() {
	m.category = nil
	m.addcategory = nil
}

// SetMaterialCategory sets the materialCategory field.
func (m *MaterialTestMutation) SetMaterialCategory(i int) {
	m.materialCategory = &i
	m.addmaterialCategory = nil
}

// MaterialCategory returns the materialCategory value in the mutation.
func (m *MaterialTestMutation) MaterialCategory() (r int, exists bool) {
	v := m.materialCategory
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialCategory returns the old materialCategory value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldMaterialCategory(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMaterialCategory is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMaterialCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialCategory: %w", err)
	}
	return oldValue.MaterialCategory, nil
}

// AddMaterialCategory adds i to materialCategory.
func (m *MaterialTestMutation) AddMaterialCategory(i int) {
	if m.addmaterialCategory != nil {
		*m.addmaterialCategory += i
	} else {
		m.addmaterialCategory = &i
	}
}

// AddedMaterialCategory returns the value that was added to the materialCategory field in this mutation.
func (m *MaterialTestMutation) AddedMaterialCategory() (r int, exists bool) {
	v := m.addmaterialCategory
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaterialCategory reset all changes of the "materialCategory" field.
func (m *MaterialTestMutation) ResetMaterialCategory() {
	m.materialCategory = nil
	m.addmaterialCategory = nil
}

// SetUserName sets the userName field.
func (m *MaterialTestMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *MaterialTestMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *MaterialTestMutation) ResetUserName() {
	m.userName = nil
}

// SetTenantId sets the tenantId field.
func (m *MaterialTestMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *MaterialTestMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *MaterialTestMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *MaterialTestMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *MaterialTestMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *MaterialTestMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *MaterialTestMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *MaterialTestMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *MaterialTestMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *MaterialTestMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *MaterialTestMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *MaterialTestMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *MaterialTestMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *MaterialTestMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *MaterialTestMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *MaterialTestMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *MaterialTestMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *MaterialTestMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *MaterialTestMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *MaterialTestMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *MaterialTestMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *MaterialTestMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *MaterialTestMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the MaterialTest.
// If the MaterialTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MaterialTestMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *MaterialTestMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *MaterialTestMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *MaterialTestMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *MaterialTestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MaterialTest).
func (m *MaterialTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MaterialTestMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.name != nil {
		fields = append(fields, materialtest.FieldName)
	}
	if m.code != nil {
		fields = append(fields, materialtest.FieldCode)
	}
	if m.seqNumber != nil {
		fields = append(fields, materialtest.FieldSeqNumber)
	}
	if m.addSeqNumber != nil {
		fields = append(fields, materialtest.FieldAddSeqNumber)
	}
	if m.date != nil {
		fields = append(fields, materialtest.FieldDate)
	}
	if m._type != nil {
		fields = append(fields, materialtest.FieldType)
	}
	if m.category != nil {
		fields = append(fields, materialtest.FieldCategory)
	}
	if m.materialCategory != nil {
		fields = append(fields, materialtest.FieldMaterialCategory)
	}
	if m.userName != nil {
		fields = append(fields, materialtest.FieldUserName)
	}
	if m.tenantId != nil {
		fields = append(fields, materialtest.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, materialtest.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, materialtest.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, materialtest.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, materialtest.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, materialtest.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MaterialTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case materialtest.FieldName:
		return m.Name()
	case materialtest.FieldCode:
		return m.Code()
	case materialtest.FieldSeqNumber:
		return m.SeqNumber()
	case materialtest.FieldAddSeqNumber:
		return m.AddSeqNumber()
	case materialtest.FieldDate:
		return m.Date()
	case materialtest.FieldType:
		return m.GetType()
	case materialtest.FieldCategory:
		return m.Category()
	case materialtest.FieldMaterialCategory:
		return m.MaterialCategory()
	case materialtest.FieldUserName:
		return m.UserName()
	case materialtest.FieldTenantId:
		return m.TenantId()
	case materialtest.FieldTenantName:
		return m.TenantName()
	case materialtest.FieldRemarks:
		return m.Remarks()
	case materialtest.FieldCreatedAt:
		return m.CreatedAt()
	case materialtest.FieldUpdatedAt:
		return m.UpdatedAt()
	case materialtest.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MaterialTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case materialtest.FieldName:
		return m.OldName(ctx)
	case materialtest.FieldCode:
		return m.OldCode(ctx)
	case materialtest.FieldSeqNumber:
		return m.OldSeqNumber(ctx)
	case materialtest.FieldAddSeqNumber:
		return m.OldAddSeqNumber(ctx)
	case materialtest.FieldDate:
		return m.OldDate(ctx)
	case materialtest.FieldType:
		return m.OldType(ctx)
	case materialtest.FieldCategory:
		return m.OldCategory(ctx)
	case materialtest.FieldMaterialCategory:
		return m.OldMaterialCategory(ctx)
	case materialtest.FieldUserName:
		return m.OldUserName(ctx)
	case materialtest.FieldTenantId:
		return m.OldTenantId(ctx)
	case materialtest.FieldTenantName:
		return m.OldTenantName(ctx)
	case materialtest.FieldRemarks:
		return m.OldRemarks(ctx)
	case materialtest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case materialtest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case materialtest.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown MaterialTest field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case materialtest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case materialtest.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case materialtest.FieldSeqNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeqNumber(v)
		return nil
	case materialtest.FieldAddSeqNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddSeqNumber(v)
		return nil
	case materialtest.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case materialtest.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case materialtest.FieldCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case materialtest.FieldMaterialCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialCategory(v)
		return nil
	case materialtest.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case materialtest.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case materialtest.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case materialtest.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case materialtest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case materialtest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case materialtest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown MaterialTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MaterialTestMutation) AddedFields() []string {
	var fields []string
	if m.adddate != nil {
		fields = append(fields, materialtest.FieldDate)
	}
	if m.add_type != nil {
		fields = append(fields, materialtest.FieldType)
	}
	if m.addcategory != nil {
		fields = append(fields, materialtest.FieldCategory)
	}
	if m.addmaterialCategory != nil {
		fields = append(fields, materialtest.FieldMaterialCategory)
	}
	if m.addtenantId != nil {
		fields = append(fields, materialtest.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, materialtest.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, materialtest.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, materialtest.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MaterialTestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case materialtest.FieldDate:
		return m.AddedDate()
	case materialtest.FieldType:
		return m.AddedType()
	case materialtest.FieldCategory:
		return m.AddedCategory()
	case materialtest.FieldMaterialCategory:
		return m.AddedMaterialCategory()
	case materialtest.FieldTenantId:
		return m.AddedTenantId()
	case materialtest.FieldCreatedAt:
		return m.AddedCreatedAt()
	case materialtest.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case materialtest.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MaterialTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case materialtest.FieldDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDate(v)
		return nil
	case materialtest.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case materialtest.FieldCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategory(v)
		return nil
	case materialtest.FieldMaterialCategory:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialCategory(v)
		return nil
	case materialtest.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case materialtest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case materialtest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case materialtest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown MaterialTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MaterialTestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MaterialTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaterialTestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MaterialTest nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MaterialTestMutation) ResetField(name string) error {
	switch name {
	case materialtest.FieldName:
		m.ResetName()
		return nil
	case materialtest.FieldCode:
		m.ResetCode()
		return nil
	case materialtest.FieldSeqNumber:
		m.ResetSeqNumber()
		return nil
	case materialtest.FieldAddSeqNumber:
		m.ResetAddSeqNumber()
		return nil
	case materialtest.FieldDate:
		m.ResetDate()
		return nil
	case materialtest.FieldType:
		m.ResetType()
		return nil
	case materialtest.FieldCategory:
		m.ResetCategory()
		return nil
	case materialtest.FieldMaterialCategory:
		m.ResetMaterialCategory()
		return nil
	case materialtest.FieldUserName:
		m.ResetUserName()
		return nil
	case materialtest.FieldTenantId:
		m.ResetTenantId()
		return nil
	case materialtest.FieldTenantName:
		m.ResetTenantName()
		return nil
	case materialtest.FieldRemarks:
		m.ResetRemarks()
		return nil
	case materialtest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case materialtest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case materialtest.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown MaterialTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MaterialTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MaterialTestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MaterialTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MaterialTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MaterialTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MaterialTestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MaterialTestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MaterialTest unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MaterialTestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MaterialTest edge %s", name)
}

// MedicineMutation represents an operation that mutate the Medicines
// nodes in the graph.
type MedicineMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	cattleId      *int64
	addcattleId   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	shedId        *int64
	addshedId     *int64
	shedName      *string
	epid          *int64
	addepid       *int64
	earNumber     *string
	medicineName  *string
	dose          *int64
	adddose       *int64
	unit          *string
	dateStart     *int64
	adddateStart  *int64
	dateEnd       *int64
	adddateEnd    *int64
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	remarks       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Medicine, error)
}

var _ ent.Mutation = (*MedicineMutation)(nil)

// medicineOption allows to manage the mutation configuration using functional options.
type medicineOption func(*MedicineMutation)

// newMedicineMutation creates new mutation for $n.Name.
func newMedicineMutation(c config, op Op, opts ...medicineOption) *MedicineMutation {
	m := &MedicineMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicineID sets the id field of the mutation.
func withMedicineID(id int64) medicineOption {
	return func(m *MedicineMutation) {
		var (
			err   error
			once  sync.Once
			value *Medicine
		)
		m.oldValue = func(ctx context.Context) (*Medicine, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medicine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicine sets the old Medicine of the mutation.
func withMedicine(node *Medicine) medicineOption {
	return func(m *MedicineMutation) {
		m.oldValue = func(context.Context) (*Medicine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MedicineMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *MedicineMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *MedicineMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *MedicineMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *MedicineMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *MedicineMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *MedicineMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *MedicineMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *MedicineMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *MedicineMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *MedicineMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *MedicineMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *MedicineMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *MedicineMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *MedicineMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *MedicineMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *MedicineMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *MedicineMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *MedicineMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *MedicineMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *MedicineMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *MedicineMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *MedicineMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *MedicineMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *MedicineMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *MedicineMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *MedicineMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *MedicineMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *MedicineMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *MedicineMutation) ResetShedName() {
	m.shedName = nil
}

// SetEpid sets the epid field.
func (m *MedicineMutation) SetEpid(i int64) {
	m.epid = &i
	m.addepid = nil
}

// Epid returns the epid value in the mutation.
func (m *MedicineMutation) Epid() (r int64, exists bool) {
	v := m.epid
	if v == nil {
		return
	}
	return *v, true
}

// OldEpid returns the old epid value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldEpid(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEpid is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEpid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpid: %w", err)
	}
	return oldValue.Epid, nil
}

// AddEpid adds i to epid.
func (m *MedicineMutation) AddEpid(i int64) {
	if m.addepid != nil {
		*m.addepid += i
	} else {
		m.addepid = &i
	}
}

// AddedEpid returns the value that was added to the epid field in this mutation.
func (m *MedicineMutation) AddedEpid() (r int64, exists bool) {
	v := m.addepid
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpid reset all changes of the "epid" field.
func (m *MedicineMutation) ResetEpid() {
	m.epid = nil
	m.addepid = nil
}

// SetEarNumber sets the earNumber field.
func (m *MedicineMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *MedicineMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *MedicineMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetMedicineName sets the medicineName field.
func (m *MedicineMutation) SetMedicineName(s string) {
	m.medicineName = &s
}

// MedicineName returns the medicineName value in the mutation.
func (m *MedicineMutation) MedicineName() (r string, exists bool) {
	v := m.medicineName
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicineName returns the old medicineName value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldMedicineName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicineName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicineName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicineName: %w", err)
	}
	return oldValue.MedicineName, nil
}

// ResetMedicineName reset all changes of the "medicineName" field.
func (m *MedicineMutation) ResetMedicineName() {
	m.medicineName = nil
}

// SetDose sets the dose field.
func (m *MedicineMutation) SetDose(i int64) {
	m.dose = &i
	m.adddose = nil
}

// Dose returns the dose value in the mutation.
func (m *MedicineMutation) Dose() (r int64, exists bool) {
	v := m.dose
	if v == nil {
		return
	}
	return *v, true
}

// OldDose returns the old dose value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldDose(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDose is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDose: %w", err)
	}
	return oldValue.Dose, nil
}

// AddDose adds i to dose.
func (m *MedicineMutation) AddDose(i int64) {
	if m.adddose != nil {
		*m.adddose += i
	} else {
		m.adddose = &i
	}
}

// AddedDose returns the value that was added to the dose field in this mutation.
func (m *MedicineMutation) AddedDose() (r int64, exists bool) {
	v := m.adddose
	if v == nil {
		return
	}
	return *v, true
}

// ResetDose reset all changes of the "dose" field.
func (m *MedicineMutation) ResetDose() {
	m.dose = nil
	m.adddose = nil
}

// SetUnit sets the unit field.
func (m *MedicineMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the unit value in the mutation.
func (m *MedicineMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old unit value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnit is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit reset all changes of the "unit" field.
func (m *MedicineMutation) ResetUnit() {
	m.unit = nil
}

// SetDateStart sets the dateStart field.
func (m *MedicineMutation) SetDateStart(i int64) {
	m.dateStart = &i
	m.adddateStart = nil
}

// DateStart returns the dateStart value in the mutation.
func (m *MedicineMutation) DateStart() (r int64, exists bool) {
	v := m.dateStart
	if v == nil {
		return
	}
	return *v, true
}

// OldDateStart returns the old dateStart value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldDateStart(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateStart is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateStart: %w", err)
	}
	return oldValue.DateStart, nil
}

// AddDateStart adds i to dateStart.
func (m *MedicineMutation) AddDateStart(i int64) {
	if m.adddateStart != nil {
		*m.adddateStart += i
	} else {
		m.adddateStart = &i
	}
}

// AddedDateStart returns the value that was added to the dateStart field in this mutation.
func (m *MedicineMutation) AddedDateStart() (r int64, exists bool) {
	v := m.adddateStart
	if v == nil {
		return
	}
	return *v, true
}

// ResetDateStart reset all changes of the "dateStart" field.
func (m *MedicineMutation) ResetDateStart() {
	m.dateStart = nil
	m.adddateStart = nil
}

// SetDateEnd sets the dateEnd field.
func (m *MedicineMutation) SetDateEnd(i int64) {
	m.dateEnd = &i
	m.adddateEnd = nil
}

// DateEnd returns the dateEnd value in the mutation.
func (m *MedicineMutation) DateEnd() (r int64, exists bool) {
	v := m.dateEnd
	if v == nil {
		return
	}
	return *v, true
}

// OldDateEnd returns the old dateEnd value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldDateEnd(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateEnd is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateEnd: %w", err)
	}
	return oldValue.DateEnd, nil
}

// AddDateEnd adds i to dateEnd.
func (m *MedicineMutation) AddDateEnd(i int64) {
	if m.adddateEnd != nil {
		*m.adddateEnd += i
	} else {
		m.adddateEnd = &i
	}
}

// AddedDateEnd returns the value that was added to the dateEnd field in this mutation.
func (m *MedicineMutation) AddedDateEnd() (r int64, exists bool) {
	v := m.adddateEnd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDateEnd reset all changes of the "dateEnd" field.
func (m *MedicineMutation) ResetDateEnd() {
	m.dateEnd = nil
	m.adddateEnd = nil
}

// SetCreatedAt sets the createdAt field.
func (m *MedicineMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *MedicineMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *MedicineMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *MedicineMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *MedicineMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *MedicineMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *MedicineMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *MedicineMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *MedicineMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *MedicineMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *MedicineMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *MedicineMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *MedicineMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *MedicineMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *MedicineMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// SetRemarks sets the remarks field.
func (m *MedicineMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *MedicineMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *MedicineMutation) ResetRemarks() {
	m.remarks = nil
}

// Op returns the operation name.
func (m *MedicineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Medicine).
func (m *MedicineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MedicineMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.cattleId != nil {
		fields = append(fields, medicine.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, medicine.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, medicine.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, medicine.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, medicine.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, medicine.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, medicine.FieldShedName)
	}
	if m.epid != nil {
		fields = append(fields, medicine.FieldEpid)
	}
	if m.earNumber != nil {
		fields = append(fields, medicine.FieldEarNumber)
	}
	if m.medicineName != nil {
		fields = append(fields, medicine.FieldMedicineName)
	}
	if m.dose != nil {
		fields = append(fields, medicine.FieldDose)
	}
	if m.unit != nil {
		fields = append(fields, medicine.FieldUnit)
	}
	if m.dateStart != nil {
		fields = append(fields, medicine.FieldDateStart)
	}
	if m.dateEnd != nil {
		fields = append(fields, medicine.FieldDateEnd)
	}
	if m.createdAt != nil {
		fields = append(fields, medicine.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, medicine.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, medicine.FieldDeleted)
	}
	if m.remarks != nil {
		fields = append(fields, medicine.FieldRemarks)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MedicineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldCattleId:
		return m.CattleId()
	case medicine.FieldTenantId:
		return m.TenantId()
	case medicine.FieldTenantName:
		return m.TenantName()
	case medicine.FieldFarmId:
		return m.FarmId()
	case medicine.FieldFarmName:
		return m.FarmName()
	case medicine.FieldShedId:
		return m.ShedId()
	case medicine.FieldShedName:
		return m.ShedName()
	case medicine.FieldEpid:
		return m.Epid()
	case medicine.FieldEarNumber:
		return m.EarNumber()
	case medicine.FieldMedicineName:
		return m.MedicineName()
	case medicine.FieldDose:
		return m.Dose()
	case medicine.FieldUnit:
		return m.Unit()
	case medicine.FieldDateStart:
		return m.DateStart()
	case medicine.FieldDateEnd:
		return m.DateEnd()
	case medicine.FieldCreatedAt:
		return m.CreatedAt()
	case medicine.FieldUpdatedAt:
		return m.UpdatedAt()
	case medicine.FieldDeleted:
		return m.Deleted()
	case medicine.FieldRemarks:
		return m.Remarks()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MedicineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicine.FieldCattleId:
		return m.OldCattleId(ctx)
	case medicine.FieldTenantId:
		return m.OldTenantId(ctx)
	case medicine.FieldTenantName:
		return m.OldTenantName(ctx)
	case medicine.FieldFarmId:
		return m.OldFarmId(ctx)
	case medicine.FieldFarmName:
		return m.OldFarmName(ctx)
	case medicine.FieldShedId:
		return m.OldShedId(ctx)
	case medicine.FieldShedName:
		return m.OldShedName(ctx)
	case medicine.FieldEpid:
		return m.OldEpid(ctx)
	case medicine.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case medicine.FieldMedicineName:
		return m.OldMedicineName(ctx)
	case medicine.FieldDose:
		return m.OldDose(ctx)
	case medicine.FieldUnit:
		return m.OldUnit(ctx)
	case medicine.FieldDateStart:
		return m.OldDateStart(ctx)
	case medicine.FieldDateEnd:
		return m.OldDateEnd(ctx)
	case medicine.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case medicine.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case medicine.FieldDeleted:
		return m.OldDeleted(ctx)
	case medicine.FieldRemarks:
		return m.OldRemarks(ctx)
	}
	return nil, fmt.Errorf("unknown Medicine field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case medicine.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case medicine.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case medicine.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case medicine.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case medicine.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case medicine.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case medicine.FieldEpid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpid(v)
		return nil
	case medicine.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case medicine.FieldMedicineName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicineName(v)
		return nil
	case medicine.FieldDose:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDose(v)
		return nil
	case medicine.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case medicine.FieldDateStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateStart(v)
		return nil
	case medicine.FieldDateEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateEnd(v)
		return nil
	case medicine.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case medicine.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case medicine.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case medicine.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MedicineMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, medicine.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, medicine.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, medicine.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, medicine.FieldShedId)
	}
	if m.addepid != nil {
		fields = append(fields, medicine.FieldEpid)
	}
	if m.adddose != nil {
		fields = append(fields, medicine.FieldDose)
	}
	if m.adddateStart != nil {
		fields = append(fields, medicine.FieldDateStart)
	}
	if m.adddateEnd != nil {
		fields = append(fields, medicine.FieldDateEnd)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, medicine.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, medicine.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, medicine.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MedicineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldCattleId:
		return m.AddedCattleId()
	case medicine.FieldTenantId:
		return m.AddedTenantId()
	case medicine.FieldFarmId:
		return m.AddedFarmId()
	case medicine.FieldShedId:
		return m.AddedShedId()
	case medicine.FieldEpid:
		return m.AddedEpid()
	case medicine.FieldDose:
		return m.AddedDose()
	case medicine.FieldDateStart:
		return m.AddedDateStart()
	case medicine.FieldDateEnd:
		return m.AddedDateEnd()
	case medicine.FieldCreatedAt:
		return m.AddedCreatedAt()
	case medicine.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case medicine.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case medicine.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case medicine.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case medicine.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case medicine.FieldEpid:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpid(v)
		return nil
	case medicine.FieldDose:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDose(v)
		return nil
	case medicine.FieldDateStart:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDateStart(v)
		return nil
	case medicine.FieldDateEnd:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDateEnd(v)
		return nil
	case medicine.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case medicine.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case medicine.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MedicineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MedicineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medicine nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MedicineMutation) ResetField(name string) error {
	switch name {
	case medicine.FieldCattleId:
		m.ResetCattleId()
		return nil
	case medicine.FieldTenantId:
		m.ResetTenantId()
		return nil
	case medicine.FieldTenantName:
		m.ResetTenantName()
		return nil
	case medicine.FieldFarmId:
		m.ResetFarmId()
		return nil
	case medicine.FieldFarmName:
		m.ResetFarmName()
		return nil
	case medicine.FieldShedId:
		m.ResetShedId()
		return nil
	case medicine.FieldShedName:
		m.ResetShedName()
		return nil
	case medicine.FieldEpid:
		m.ResetEpid()
		return nil
	case medicine.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case medicine.FieldMedicineName:
		m.ResetMedicineName()
		return nil
	case medicine.FieldDose:
		m.ResetDose()
		return nil
	case medicine.FieldUnit:
		m.ResetUnit()
		return nil
	case medicine.FieldDateStart:
		m.ResetDateStart()
		return nil
	case medicine.FieldDateEnd:
		m.ResetDateEnd()
		return nil
	case medicine.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case medicine.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case medicine.FieldDeleted:
		m.ResetDeleted()
		return nil
	case medicine.FieldRemarks:
		m.ResetRemarks()
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MedicineMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MedicineMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MedicineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MedicineMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MedicineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MedicineMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MedicineMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Medicine unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MedicineMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Medicine edge %s", name)
}

// OperationMutation represents an operation that mutate the Operations
// nodes in the graph.
type OperationMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	userId        *int64
	adduserId     *int64
	userName      *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	api           *string
	ip            *string
	method        *string
	createdAt     *int64
	addcreatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Operation, error)
}

var _ ent.Mutation = (*OperationMutation)(nil)

// operationOption allows to manage the mutation configuration using functional options.
type operationOption func(*OperationMutation)

// newOperationMutation creates new mutation for $n.Name.
func newOperationMutation(c config, op Op, opts ...operationOption) *OperationMutation {
	m := &OperationMutation{
		config:        c,
		op:            op,
		typ:           TypeOperation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperationID sets the id field of the mutation.
func withOperationID(id int64) operationOption {
	return func(m *OperationMutation) {
		var (
			err   error
			once  sync.Once
			value *Operation
		)
		m.oldValue = func(ctx context.Context) (*Operation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperation sets the old Operation of the mutation.
func withOperation(node *Operation) operationOption {
	return func(m *OperationMutation) {
		m.oldValue = func(context.Context) (*Operation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OperationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserId sets the userId field.
func (m *OperationMutation) SetUserId(i int64) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the userId value in the mutation.
func (m *OperationMutation) UserId() (r int64, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old userId value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldUserId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to userId.
func (m *OperationMutation) AddUserId(i int64) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the userId field in this mutation.
func (m *OperationMutation) AddedUserId() (r int64, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId reset all changes of the "userId" field.
func (m *OperationMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetUserName sets the userName field.
func (m *OperationMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *OperationMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *OperationMutation) ResetUserName() {
	m.userName = nil
}

// SetTenantId sets the tenantId field.
func (m *OperationMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *OperationMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *OperationMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *OperationMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *OperationMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *OperationMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *OperationMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *OperationMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetAPI sets the api field.
func (m *OperationMutation) SetAPI(s string) {
	m.api = &s
}

// API returns the api value in the mutation.
func (m *OperationMutation) API() (r string, exists bool) {
	v := m.api
	if v == nil {
		return
	}
	return *v, true
}

// OldAPI returns the old api value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldAPI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAPI is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPI: %w", err)
	}
	return oldValue.API, nil
}

// ResetAPI reset all changes of the "api" field.
func (m *OperationMutation) ResetAPI() {
	m.api = nil
}

// SetIP sets the ip field.
func (m *OperationMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the ip value in the mutation.
func (m *OperationMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old ip value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP reset all changes of the "ip" field.
func (m *OperationMutation) ResetIP() {
	m.ip = nil
}

// SetMethod sets the method field.
func (m *OperationMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the method value in the mutation.
func (m *OperationMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old method value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethod is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod reset all changes of the "method" field.
func (m *OperationMutation) ResetMethod() {
	m.method = nil
}

// SetCreatedAt sets the createdAt field.
func (m *OperationMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *OperationMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *OperationMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *OperationMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *OperationMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *OperationMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *OperationMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Operation.
// If the Operation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperationMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *OperationMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *OperationMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *OperationMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *OperationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Operation).
func (m *OperationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OperationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.userId != nil {
		fields = append(fields, operation.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, operation.FieldUserName)
	}
	if m.tenantId != nil {
		fields = append(fields, operation.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, operation.FieldTenantName)
	}
	if m.api != nil {
		fields = append(fields, operation.FieldAPI)
	}
	if m.ip != nil {
		fields = append(fields, operation.FieldIP)
	}
	if m.method != nil {
		fields = append(fields, operation.FieldMethod)
	}
	if m.createdAt != nil {
		fields = append(fields, operation.FieldCreatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, operation.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OperationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operation.FieldUserId:
		return m.UserId()
	case operation.FieldUserName:
		return m.UserName()
	case operation.FieldTenantId:
		return m.TenantId()
	case operation.FieldTenantName:
		return m.TenantName()
	case operation.FieldAPI:
		return m.API()
	case operation.FieldIP:
		return m.IP()
	case operation.FieldMethod:
		return m.Method()
	case operation.FieldCreatedAt:
		return m.CreatedAt()
	case operation.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OperationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operation.FieldUserId:
		return m.OldUserId(ctx)
	case operation.FieldUserName:
		return m.OldUserName(ctx)
	case operation.FieldTenantId:
		return m.OldTenantId(ctx)
	case operation.FieldTenantName:
		return m.OldTenantName(ctx)
	case operation.FieldAPI:
		return m.OldAPI(ctx)
	case operation.FieldIP:
		return m.OldIP(ctx)
	case operation.FieldMethod:
		return m.OldMethod(ctx)
	case operation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case operation.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Operation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operation.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case operation.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case operation.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case operation.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case operation.FieldAPI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPI(v)
		return nil
	case operation.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case operation.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case operation.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case operation.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Operation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OperationMutation) AddedFields() []string {
	var fields []string
	if m.adduserId != nil {
		fields = append(fields, operation.FieldUserId)
	}
	if m.addtenantId != nil {
		fields = append(fields, operation.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, operation.FieldCreatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, operation.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OperationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case operation.FieldUserId:
		return m.AddedUserId()
	case operation.FieldTenantId:
		return m.AddedTenantId()
	case operation.FieldCreatedAt:
		return m.AddedCreatedAt()
	case operation.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case operation.FieldUserId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case operation.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case operation.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case operation.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Operation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OperationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OperationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Operation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OperationMutation) ResetField(name string) error {
	switch name {
	case operation.FieldUserId:
		m.ResetUserId()
		return nil
	case operation.FieldUserName:
		m.ResetUserName()
		return nil
	case operation.FieldTenantId:
		m.ResetTenantId()
		return nil
	case operation.FieldTenantName:
		m.ResetTenantName()
		return nil
	case operation.FieldAPI:
		m.ResetAPI()
		return nil
	case operation.FieldIP:
		m.ResetIP()
		return nil
	case operation.FieldMethod:
		m.ResetMethod()
		return nil
	case operation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case operation.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Operation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OperationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OperationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OperationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OperationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OperationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OperationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OperationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Operation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OperationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Operation edge %s", name)
}

// PositionMutation represents an operation that mutate the Positions
// nodes in the graph.
type PositionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	_order        *int
	add_order     *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Position, error)
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows to manage the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for $n.Name.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the id field of the mutation.
func withPositionID(id int64) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PositionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PositionMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *PositionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *PositionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *PositionMutation) ResetCode() {
	m.code = nil
}

// SetTenantId sets the tenantId field.
func (m *PositionMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *PositionMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *PositionMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *PositionMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *PositionMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *PositionMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *PositionMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *PositionMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetOrder sets the order field.
func (m *PositionMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the order value in the mutation.
func (m *PositionMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old order value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to order.
func (m *PositionMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the order field in this mutation.
func (m *PositionMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder reset all changes of the "order" field.
func (m *PositionMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRemarks sets the remarks field.
func (m *PositionMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *PositionMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *PositionMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *PositionMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *PositionMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *PositionMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *PositionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *PositionMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *PositionMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *PositionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *PositionMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *PositionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *PositionMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *PositionMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *PositionMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Position.
// If the Position object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *PositionMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *PositionMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *PositionMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, position.FieldName)
	}
	if m.code != nil {
		fields = append(fields, position.FieldCode)
	}
	if m.tenantId != nil {
		fields = append(fields, position.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, position.FieldTenantName)
	}
	if m._order != nil {
		fields = append(fields, position.FieldOrder)
	}
	if m.remarks != nil {
		fields = append(fields, position.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, position.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldName:
		return m.Name()
	case position.FieldCode:
		return m.Code()
	case position.FieldTenantId:
		return m.TenantId()
	case position.FieldTenantName:
		return m.TenantName()
	case position.FieldOrder:
		return m.Order()
	case position.FieldRemarks:
		return m.Remarks()
	case position.FieldCreatedAt:
		return m.CreatedAt()
	case position.FieldUpdatedAt:
		return m.UpdatedAt()
	case position.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldName:
		return m.OldName(ctx)
	case position.FieldCode:
		return m.OldCode(ctx)
	case position.FieldTenantId:
		return m.OldTenantId(ctx)
	case position.FieldTenantName:
		return m.OldTenantName(ctx)
	case position.FieldOrder:
		return m.OldOrder(ctx)
	case position.FieldRemarks:
		return m.OldRemarks(ctx)
	case position.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case position.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case position.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case position.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case position.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case position.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case position.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case position.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case position.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case position.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PositionMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, position.FieldTenantId)
	}
	if m.add_order != nil {
		fields = append(fields, position.FieldOrder)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, position.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case position.FieldTenantId:
		return m.AddedTenantId()
	case position.FieldOrder:
		return m.AddedOrder()
	case position.FieldCreatedAt:
		return m.AddedCreatedAt()
	case position.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case position.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case position.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case position.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case position.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case position.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldName:
		m.ResetName()
		return nil
	case position.FieldCode:
		m.ResetCode()
		return nil
	case position.FieldTenantId:
		m.ResetTenantId()
		return nil
	case position.FieldTenantName:
		m.ResetTenantName()
		return nil
	case position.FieldOrder:
		m.ResetOrder()
		return nil
	case position.FieldRemarks:
		m.ResetRemarks()
		return nil
	case position.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case position.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case position.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Position edge %s", name)
}

// PositionApiMutation represents an operation that mutate the PositionApis
// nodes in the graph.
type PositionApiMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	positionId    *int64
	addpositionId *int64
	apis          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PositionApi, error)
}

var _ ent.Mutation = (*PositionApiMutation)(nil)

// positionapiOption allows to manage the mutation configuration using functional options.
type positionapiOption func(*PositionApiMutation)

// newPositionApiMutation creates new mutation for $n.Name.
func newPositionApiMutation(c config, op Op, opts ...positionapiOption) *PositionApiMutation {
	m := &PositionApiMutation{
		config:        c,
		op:            op,
		typ:           TypePositionApi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionApiID sets the id field of the mutation.
func withPositionApiID(id int64) positionapiOption {
	return func(m *PositionApiMutation) {
		var (
			err   error
			once  sync.Once
			value *PositionApi
		)
		m.oldValue = func(ctx context.Context) (*PositionApi, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PositionApi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPositionApi sets the old PositionApi of the mutation.
func withPositionApi(node *PositionApi) positionapiOption {
	return func(m *PositionApiMutation) {
		m.oldValue = func(context.Context) (*PositionApi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionApiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionApiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PositionApiMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPositionId sets the positionId field.
func (m *PositionApiMutation) SetPositionId(i int64) {
	m.positionId = &i
	m.addpositionId = nil
}

// PositionId returns the positionId value in the mutation.
func (m *PositionApiMutation) PositionId() (r int64, exists bool) {
	v := m.positionId
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionId returns the old positionId value of the PositionApi.
// If the PositionApi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionApiMutation) OldPositionId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionId: %w", err)
	}
	return oldValue.PositionId, nil
}

// AddPositionId adds i to positionId.
func (m *PositionApiMutation) AddPositionId(i int64) {
	if m.addpositionId != nil {
		*m.addpositionId += i
	} else {
		m.addpositionId = &i
	}
}

// AddedPositionId returns the value that was added to the positionId field in this mutation.
func (m *PositionApiMutation) AddedPositionId() (r int64, exists bool) {
	v := m.addpositionId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPositionId reset all changes of the "positionId" field.
func (m *PositionApiMutation) ResetPositionId() {
	m.positionId = nil
	m.addpositionId = nil
}

// SetApis sets the apis field.
func (m *PositionApiMutation) SetApis(s string) {
	m.apis = &s
}

// Apis returns the apis value in the mutation.
func (m *PositionApiMutation) Apis() (r string, exists bool) {
	v := m.apis
	if v == nil {
		return
	}
	return *v, true
}

// OldApis returns the old apis value of the PositionApi.
// If the PositionApi object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PositionApiMutation) OldApis(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApis is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApis: %w", err)
	}
	return oldValue.Apis, nil
}

// ResetApis reset all changes of the "apis" field.
func (m *PositionApiMutation) ResetApis() {
	m.apis = nil
}

// Op returns the operation name.
func (m *PositionApiMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PositionApi).
func (m *PositionApiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PositionApiMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.positionId != nil {
		fields = append(fields, positionapi.FieldPositionId)
	}
	if m.apis != nil {
		fields = append(fields, positionapi.FieldApis)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PositionApiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case positionapi.FieldPositionId:
		return m.PositionId()
	case positionapi.FieldApis:
		return m.Apis()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PositionApiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case positionapi.FieldPositionId:
		return m.OldPositionId(ctx)
	case positionapi.FieldApis:
		return m.OldApis(ctx)
	}
	return nil, fmt.Errorf("unknown PositionApi field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionApiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case positionapi.FieldPositionId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionId(v)
		return nil
	case positionapi.FieldApis:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApis(v)
		return nil
	}
	return fmt.Errorf("unknown PositionApi field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PositionApiMutation) AddedFields() []string {
	var fields []string
	if m.addpositionId != nil {
		fields = append(fields, positionapi.FieldPositionId)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PositionApiMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case positionapi.FieldPositionId:
		return m.AddedPositionId()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PositionApiMutation) AddField(name string, value ent.Value) error {
	switch name {
	case positionapi.FieldPositionId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionId(v)
		return nil
	}
	return fmt.Errorf("unknown PositionApi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PositionApiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PositionApiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionApiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PositionApi nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PositionApiMutation) ResetField(name string) error {
	switch name {
	case positionapi.FieldPositionId:
		m.ResetPositionId()
		return nil
	case positionapi.FieldApis:
		m.ResetApis()
		return nil
	}
	return fmt.Errorf("unknown PositionApi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PositionApiMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PositionApiMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PositionApiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PositionApiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PositionApiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PositionApiMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PositionApiMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PositionApi unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PositionApiMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PositionApi edge %s", name)
}

// PregnancyTestMutation represents an operation that mutate the PregnancyTests
// nodes in the graph.
type PregnancyTestMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int64
	cattleId                 *int64
	addcattleId              *int64
	tenantId                 *int64
	addtenantId              *int64
	tenantName               *string
	farmId                   *int64
	addfarmId                *int64
	farmName                 *string
	shedId                   *int64
	addshedId                *int64
	shedName                 *string
	name                     *string
	earNumber                *string
	times                    *int
	addtimes                 *int
	breedingAt               *int64
	addbreedingAt            *int64
	testAt                   *int64
	addtestAt                *int64
	pregnancyTestTypeId      *int
	addpregnancyTestTypeId   *int
	pregnancyTestTypeName    *string
	pregnancyTestMethodId    *int
	addpregnancyTestMethodId *int
	pregnancyTestMethodName  *string
	pregnancyTestResultId    *int
	addpregnancyTestResultId *int
	pregnancyTestResultName  *string
	userName                 *string
	remarks                  *string
	createdAt                *int64
	addcreatedAt             *int64
	updatedAt                *int64
	addupdatedAt             *int64
	deleted                  *int
	adddeleted               *int
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*PregnancyTest, error)
}

var _ ent.Mutation = (*PregnancyTestMutation)(nil)

// pregnancytestOption allows to manage the mutation configuration using functional options.
type pregnancytestOption func(*PregnancyTestMutation)

// newPregnancyTestMutation creates new mutation for $n.Name.
func newPregnancyTestMutation(c config, op Op, opts ...pregnancytestOption) *PregnancyTestMutation {
	m := &PregnancyTestMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestID sets the id field of the mutation.
func withPregnancyTestID(id int64) pregnancytestOption {
	return func(m *PregnancyTestMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTest
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTest, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTest sets the old PregnancyTest of the mutation.
func withPregnancyTest(node *PregnancyTest) pregnancytestOption {
	return func(m *PregnancyTestMutation) {
		m.oldValue = func(context.Context) (*PregnancyTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCattleId sets the cattleId field.
func (m *PregnancyTestMutation) SetCattleId(i int64) {
	m.cattleId = &i
	m.addcattleId = nil
}

// CattleId returns the cattleId value in the mutation.
func (m *PregnancyTestMutation) CattleId() (r int64, exists bool) {
	v := m.cattleId
	if v == nil {
		return
	}
	return *v, true
}

// OldCattleId returns the old cattleId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldCattleId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCattleId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCattleId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCattleId: %w", err)
	}
	return oldValue.CattleId, nil
}

// AddCattleId adds i to cattleId.
func (m *PregnancyTestMutation) AddCattleId(i int64) {
	if m.addcattleId != nil {
		*m.addcattleId += i
	} else {
		m.addcattleId = &i
	}
}

// AddedCattleId returns the value that was added to the cattleId field in this mutation.
func (m *PregnancyTestMutation) AddedCattleId() (r int64, exists bool) {
	v := m.addcattleId
	if v == nil {
		return
	}
	return *v, true
}

// ResetCattleId reset all changes of the "cattleId" field.
func (m *PregnancyTestMutation) ResetCattleId() {
	m.cattleId = nil
	m.addcattleId = nil
}

// SetTenantId sets the tenantId field.
func (m *PregnancyTestMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *PregnancyTestMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *PregnancyTestMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *PregnancyTestMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *PregnancyTestMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *PregnancyTestMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *PregnancyTestMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *PregnancyTestMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetFarmId sets the farmId field.
func (m *PregnancyTestMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *PregnancyTestMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *PregnancyTestMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *PregnancyTestMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *PregnancyTestMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *PregnancyTestMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *PregnancyTestMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *PregnancyTestMutation) ResetFarmName() {
	m.farmName = nil
}

// SetShedId sets the shedId field.
func (m *PregnancyTestMutation) SetShedId(i int64) {
	m.shedId = &i
	m.addshedId = nil
}

// ShedId returns the shedId value in the mutation.
func (m *PregnancyTestMutation) ShedId() (r int64, exists bool) {
	v := m.shedId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedId returns the old shedId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldShedId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedId: %w", err)
	}
	return oldValue.ShedId, nil
}

// AddShedId adds i to shedId.
func (m *PregnancyTestMutation) AddShedId(i int64) {
	if m.addshedId != nil {
		*m.addshedId += i
	} else {
		m.addshedId = &i
	}
}

// AddedShedId returns the value that was added to the shedId field in this mutation.
func (m *PregnancyTestMutation) AddedShedId() (r int64, exists bool) {
	v := m.addshedId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedId reset all changes of the "shedId" field.
func (m *PregnancyTestMutation) ResetShedId() {
	m.shedId = nil
	m.addshedId = nil
}

// SetShedName sets the shedName field.
func (m *PregnancyTestMutation) SetShedName(s string) {
	m.shedName = &s
}

// ShedName returns the shedName value in the mutation.
func (m *PregnancyTestMutation) ShedName() (r string, exists bool) {
	v := m.shedName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedName returns the old shedName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldShedName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedName: %w", err)
	}
	return oldValue.ShedName, nil
}

// ResetShedName reset all changes of the "shedName" field.
func (m *PregnancyTestMutation) ResetShedName() {
	m.shedName = nil
}

// SetName sets the name field.
func (m *PregnancyTestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of name.
func (m *PregnancyTestMutation) ClearName() {
	m.name = nil
	m.clearedFields[pregnancytest.FieldName] = struct{}{}
}

// NameCleared returns if the field name was cleared in this mutation.
func (m *PregnancyTestMutation) NameCleared() bool {
	_, ok := m.clearedFields[pregnancytest.FieldName]
	return ok
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, pregnancytest.FieldName)
}

// SetEarNumber sets the earNumber field.
func (m *PregnancyTestMutation) SetEarNumber(s string) {
	m.earNumber = &s
}

// EarNumber returns the earNumber value in the mutation.
func (m *PregnancyTestMutation) EarNumber() (r string, exists bool) {
	v := m.earNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEarNumber returns the old earNumber value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldEarNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEarNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEarNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEarNumber: %w", err)
	}
	return oldValue.EarNumber, nil
}

// ResetEarNumber reset all changes of the "earNumber" field.
func (m *PregnancyTestMutation) ResetEarNumber() {
	m.earNumber = nil
}

// SetTimes sets the times field.
func (m *PregnancyTestMutation) SetTimes(i int) {
	m.times = &i
	m.addtimes = nil
}

// Times returns the times value in the mutation.
func (m *PregnancyTestMutation) Times() (r int, exists bool) {
	v := m.times
	if v == nil {
		return
	}
	return *v, true
}

// OldTimes returns the old times value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimes is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimes: %w", err)
	}
	return oldValue.Times, nil
}

// AddTimes adds i to times.
func (m *PregnancyTestMutation) AddTimes(i int) {
	if m.addtimes != nil {
		*m.addtimes += i
	} else {
		m.addtimes = &i
	}
}

// AddedTimes returns the value that was added to the times field in this mutation.
func (m *PregnancyTestMutation) AddedTimes() (r int, exists bool) {
	v := m.addtimes
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimes reset all changes of the "times" field.
func (m *PregnancyTestMutation) ResetTimes() {
	m.times = nil
	m.addtimes = nil
}

// SetBreedingAt sets the breedingAt field.
func (m *PregnancyTestMutation) SetBreedingAt(i int64) {
	m.breedingAt = &i
	m.addbreedingAt = nil
}

// BreedingAt returns the breedingAt value in the mutation.
func (m *PregnancyTestMutation) BreedingAt() (r int64, exists bool) {
	v := m.breedingAt
	if v == nil {
		return
	}
	return *v, true
}

// OldBreedingAt returns the old breedingAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldBreedingAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBreedingAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBreedingAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreedingAt: %w", err)
	}
	return oldValue.BreedingAt, nil
}

// AddBreedingAt adds i to breedingAt.
func (m *PregnancyTestMutation) AddBreedingAt(i int64) {
	if m.addbreedingAt != nil {
		*m.addbreedingAt += i
	} else {
		m.addbreedingAt = &i
	}
}

// AddedBreedingAt returns the value that was added to the breedingAt field in this mutation.
func (m *PregnancyTestMutation) AddedBreedingAt() (r int64, exists bool) {
	v := m.addbreedingAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetBreedingAt reset all changes of the "breedingAt" field.
func (m *PregnancyTestMutation) ResetBreedingAt() {
	m.breedingAt = nil
	m.addbreedingAt = nil
}

// SetTestAt sets the testAt field.
func (m *PregnancyTestMutation) SetTestAt(i int64) {
	m.testAt = &i
	m.addtestAt = nil
}

// TestAt returns the testAt value in the mutation.
func (m *PregnancyTestMutation) TestAt() (r int64, exists bool) {
	v := m.testAt
	if v == nil {
		return
	}
	return *v, true
}

// OldTestAt returns the old testAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldTestAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTestAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTestAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestAt: %w", err)
	}
	return oldValue.TestAt, nil
}

// AddTestAt adds i to testAt.
func (m *PregnancyTestMutation) AddTestAt(i int64) {
	if m.addtestAt != nil {
		*m.addtestAt += i
	} else {
		m.addtestAt = &i
	}
}

// AddedTestAt returns the value that was added to the testAt field in this mutation.
func (m *PregnancyTestMutation) AddedTestAt() (r int64, exists bool) {
	v := m.addtestAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetTestAt reset all changes of the "testAt" field.
func (m *PregnancyTestMutation) ResetTestAt() {
	m.testAt = nil
	m.addtestAt = nil
}

// SetPregnancyTestTypeId sets the pregnancyTestTypeId field.
func (m *PregnancyTestMutation) SetPregnancyTestTypeId(i int) {
	m.pregnancyTestTypeId = &i
	m.addpregnancyTestTypeId = nil
}

// PregnancyTestTypeId returns the pregnancyTestTypeId value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestTypeId() (r int, exists bool) {
	v := m.pregnancyTestTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestTypeId returns the old pregnancyTestTypeId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestTypeId: %w", err)
	}
	return oldValue.PregnancyTestTypeId, nil
}

// AddPregnancyTestTypeId adds i to pregnancyTestTypeId.
func (m *PregnancyTestMutation) AddPregnancyTestTypeId(i int) {
	if m.addpregnancyTestTypeId != nil {
		*m.addpregnancyTestTypeId += i
	} else {
		m.addpregnancyTestTypeId = &i
	}
}

// AddedPregnancyTestTypeId returns the value that was added to the pregnancyTestTypeId field in this mutation.
func (m *PregnancyTestMutation) AddedPregnancyTestTypeId() (r int, exists bool) {
	v := m.addpregnancyTestTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyTestTypeId reset all changes of the "pregnancyTestTypeId" field.
func (m *PregnancyTestMutation) ResetPregnancyTestTypeId() {
	m.pregnancyTestTypeId = nil
	m.addpregnancyTestTypeId = nil
}

// SetPregnancyTestTypeName sets the pregnancyTestTypeName field.
func (m *PregnancyTestMutation) SetPregnancyTestTypeName(s string) {
	m.pregnancyTestTypeName = &s
}

// PregnancyTestTypeName returns the pregnancyTestTypeName value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestTypeName() (r string, exists bool) {
	v := m.pregnancyTestTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestTypeName returns the old pregnancyTestTypeName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestTypeName: %w", err)
	}
	return oldValue.PregnancyTestTypeName, nil
}

// ResetPregnancyTestTypeName reset all changes of the "pregnancyTestTypeName" field.
func (m *PregnancyTestMutation) ResetPregnancyTestTypeName() {
	m.pregnancyTestTypeName = nil
}

// SetPregnancyTestMethodId sets the pregnancyTestMethodId field.
func (m *PregnancyTestMutation) SetPregnancyTestMethodId(i int) {
	m.pregnancyTestMethodId = &i
	m.addpregnancyTestMethodId = nil
}

// PregnancyTestMethodId returns the pregnancyTestMethodId value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestMethodId() (r int, exists bool) {
	v := m.pregnancyTestMethodId
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestMethodId returns the old pregnancyTestMethodId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestMethodId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestMethodId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestMethodId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestMethodId: %w", err)
	}
	return oldValue.PregnancyTestMethodId, nil
}

// AddPregnancyTestMethodId adds i to pregnancyTestMethodId.
func (m *PregnancyTestMutation) AddPregnancyTestMethodId(i int) {
	if m.addpregnancyTestMethodId != nil {
		*m.addpregnancyTestMethodId += i
	} else {
		m.addpregnancyTestMethodId = &i
	}
}

// AddedPregnancyTestMethodId returns the value that was added to the pregnancyTestMethodId field in this mutation.
func (m *PregnancyTestMutation) AddedPregnancyTestMethodId() (r int, exists bool) {
	v := m.addpregnancyTestMethodId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyTestMethodId reset all changes of the "pregnancyTestMethodId" field.
func (m *PregnancyTestMutation) ResetPregnancyTestMethodId() {
	m.pregnancyTestMethodId = nil
	m.addpregnancyTestMethodId = nil
}

// SetPregnancyTestMethodName sets the pregnancyTestMethodName field.
func (m *PregnancyTestMutation) SetPregnancyTestMethodName(s string) {
	m.pregnancyTestMethodName = &s
}

// PregnancyTestMethodName returns the pregnancyTestMethodName value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestMethodName() (r string, exists bool) {
	v := m.pregnancyTestMethodName
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestMethodName returns the old pregnancyTestMethodName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestMethodName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestMethodName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestMethodName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestMethodName: %w", err)
	}
	return oldValue.PregnancyTestMethodName, nil
}

// ResetPregnancyTestMethodName reset all changes of the "pregnancyTestMethodName" field.
func (m *PregnancyTestMutation) ResetPregnancyTestMethodName() {
	m.pregnancyTestMethodName = nil
}

// SetPregnancyTestResultId sets the pregnancyTestResultId field.
func (m *PregnancyTestMutation) SetPregnancyTestResultId(i int) {
	m.pregnancyTestResultId = &i
	m.addpregnancyTestResultId = nil
}

// PregnancyTestResultId returns the pregnancyTestResultId value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestResultId() (r int, exists bool) {
	v := m.pregnancyTestResultId
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestResultId returns the old pregnancyTestResultId value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestResultId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestResultId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestResultId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestResultId: %w", err)
	}
	return oldValue.PregnancyTestResultId, nil
}

// AddPregnancyTestResultId adds i to pregnancyTestResultId.
func (m *PregnancyTestMutation) AddPregnancyTestResultId(i int) {
	if m.addpregnancyTestResultId != nil {
		*m.addpregnancyTestResultId += i
	} else {
		m.addpregnancyTestResultId = &i
	}
}

// AddedPregnancyTestResultId returns the value that was added to the pregnancyTestResultId field in this mutation.
func (m *PregnancyTestMutation) AddedPregnancyTestResultId() (r int, exists bool) {
	v := m.addpregnancyTestResultId
	if v == nil {
		return
	}
	return *v, true
}

// ResetPregnancyTestResultId reset all changes of the "pregnancyTestResultId" field.
func (m *PregnancyTestMutation) ResetPregnancyTestResultId() {
	m.pregnancyTestResultId = nil
	m.addpregnancyTestResultId = nil
}

// SetPregnancyTestResultName sets the pregnancyTestResultName field.
func (m *PregnancyTestMutation) SetPregnancyTestResultName(s string) {
	m.pregnancyTestResultName = &s
}

// PregnancyTestResultName returns the pregnancyTestResultName value in the mutation.
func (m *PregnancyTestMutation) PregnancyTestResultName() (r string, exists bool) {
	v := m.pregnancyTestResultName
	if v == nil {
		return
	}
	return *v, true
}

// OldPregnancyTestResultName returns the old pregnancyTestResultName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldPregnancyTestResultName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPregnancyTestResultName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPregnancyTestResultName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPregnancyTestResultName: %w", err)
	}
	return oldValue.PregnancyTestResultName, nil
}

// ResetPregnancyTestResultName reset all changes of the "pregnancyTestResultName" field.
func (m *PregnancyTestMutation) ResetPregnancyTestResultName() {
	m.pregnancyTestResultName = nil
}

// SetUserName sets the userName field.
func (m *PregnancyTestMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *PregnancyTestMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *PregnancyTestMutation) ResetUserName() {
	m.userName = nil
}

// SetRemarks sets the remarks field.
func (m *PregnancyTestMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *PregnancyTestMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *PregnancyTestMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *PregnancyTestMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *PregnancyTestMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *PregnancyTestMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *PregnancyTestMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *PregnancyTestMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *PregnancyTestMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *PregnancyTestMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *PregnancyTestMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *PregnancyTestMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *PregnancyTestMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *PregnancyTestMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *PregnancyTestMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the PregnancyTest.
// If the PregnancyTest object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *PregnancyTestMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *PregnancyTestMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *PregnancyTestMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *PregnancyTestMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTest).
func (m *PregnancyTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.cattleId != nil {
		fields = append(fields, pregnancytest.FieldCattleId)
	}
	if m.tenantId != nil {
		fields = append(fields, pregnancytest.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, pregnancytest.FieldTenantName)
	}
	if m.farmId != nil {
		fields = append(fields, pregnancytest.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, pregnancytest.FieldFarmName)
	}
	if m.shedId != nil {
		fields = append(fields, pregnancytest.FieldShedId)
	}
	if m.shedName != nil {
		fields = append(fields, pregnancytest.FieldShedName)
	}
	if m.name != nil {
		fields = append(fields, pregnancytest.FieldName)
	}
	if m.earNumber != nil {
		fields = append(fields, pregnancytest.FieldEarNumber)
	}
	if m.times != nil {
		fields = append(fields, pregnancytest.FieldTimes)
	}
	if m.breedingAt != nil {
		fields = append(fields, pregnancytest.FieldBreedingAt)
	}
	if m.testAt != nil {
		fields = append(fields, pregnancytest.FieldTestAt)
	}
	if m.pregnancyTestTypeId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestTypeId)
	}
	if m.pregnancyTestTypeName != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestTypeName)
	}
	if m.pregnancyTestMethodId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestMethodId)
	}
	if m.pregnancyTestMethodName != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestMethodName)
	}
	if m.pregnancyTestResultId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestResultId)
	}
	if m.pregnancyTestResultName != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestResultName)
	}
	if m.userName != nil {
		fields = append(fields, pregnancytest.FieldUserName)
	}
	if m.remarks != nil {
		fields = append(fields, pregnancytest.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, pregnancytest.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, pregnancytest.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, pregnancytest.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytest.FieldCattleId:
		return m.CattleId()
	case pregnancytest.FieldTenantId:
		return m.TenantId()
	case pregnancytest.FieldTenantName:
		return m.TenantName()
	case pregnancytest.FieldFarmId:
		return m.FarmId()
	case pregnancytest.FieldFarmName:
		return m.FarmName()
	case pregnancytest.FieldShedId:
		return m.ShedId()
	case pregnancytest.FieldShedName:
		return m.ShedName()
	case pregnancytest.FieldName:
		return m.Name()
	case pregnancytest.FieldEarNumber:
		return m.EarNumber()
	case pregnancytest.FieldTimes:
		return m.Times()
	case pregnancytest.FieldBreedingAt:
		return m.BreedingAt()
	case pregnancytest.FieldTestAt:
		return m.TestAt()
	case pregnancytest.FieldPregnancyTestTypeId:
		return m.PregnancyTestTypeId()
	case pregnancytest.FieldPregnancyTestTypeName:
		return m.PregnancyTestTypeName()
	case pregnancytest.FieldPregnancyTestMethodId:
		return m.PregnancyTestMethodId()
	case pregnancytest.FieldPregnancyTestMethodName:
		return m.PregnancyTestMethodName()
	case pregnancytest.FieldPregnancyTestResultId:
		return m.PregnancyTestResultId()
	case pregnancytest.FieldPregnancyTestResultName:
		return m.PregnancyTestResultName()
	case pregnancytest.FieldUserName:
		return m.UserName()
	case pregnancytest.FieldRemarks:
		return m.Remarks()
	case pregnancytest.FieldCreatedAt:
		return m.CreatedAt()
	case pregnancytest.FieldUpdatedAt:
		return m.UpdatedAt()
	case pregnancytest.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytest.FieldCattleId:
		return m.OldCattleId(ctx)
	case pregnancytest.FieldTenantId:
		return m.OldTenantId(ctx)
	case pregnancytest.FieldTenantName:
		return m.OldTenantName(ctx)
	case pregnancytest.FieldFarmId:
		return m.OldFarmId(ctx)
	case pregnancytest.FieldFarmName:
		return m.OldFarmName(ctx)
	case pregnancytest.FieldShedId:
		return m.OldShedId(ctx)
	case pregnancytest.FieldShedName:
		return m.OldShedName(ctx)
	case pregnancytest.FieldName:
		return m.OldName(ctx)
	case pregnancytest.FieldEarNumber:
		return m.OldEarNumber(ctx)
	case pregnancytest.FieldTimes:
		return m.OldTimes(ctx)
	case pregnancytest.FieldBreedingAt:
		return m.OldBreedingAt(ctx)
	case pregnancytest.FieldTestAt:
		return m.OldTestAt(ctx)
	case pregnancytest.FieldPregnancyTestTypeId:
		return m.OldPregnancyTestTypeId(ctx)
	case pregnancytest.FieldPregnancyTestTypeName:
		return m.OldPregnancyTestTypeName(ctx)
	case pregnancytest.FieldPregnancyTestMethodId:
		return m.OldPregnancyTestMethodId(ctx)
	case pregnancytest.FieldPregnancyTestMethodName:
		return m.OldPregnancyTestMethodName(ctx)
	case pregnancytest.FieldPregnancyTestResultId:
		return m.OldPregnancyTestResultId(ctx)
	case pregnancytest.FieldPregnancyTestResultName:
		return m.OldPregnancyTestResultName(ctx)
	case pregnancytest.FieldUserName:
		return m.OldUserName(ctx)
	case pregnancytest.FieldRemarks:
		return m.OldRemarks(ctx)
	case pregnancytest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pregnancytest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pregnancytest.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTest field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytest.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCattleId(v)
		return nil
	case pregnancytest.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case pregnancytest.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case pregnancytest.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case pregnancytest.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case pregnancytest.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedId(v)
		return nil
	case pregnancytest.FieldShedName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedName(v)
		return nil
	case pregnancytest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pregnancytest.FieldEarNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEarNumber(v)
		return nil
	case pregnancytest.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimes(v)
		return nil
	case pregnancytest.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreedingAt(v)
		return nil
	case pregnancytest.FieldTestAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestAt(v)
		return nil
	case pregnancytest.FieldPregnancyTestTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestTypeId(v)
		return nil
	case pregnancytest.FieldPregnancyTestTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestTypeName(v)
		return nil
	case pregnancytest.FieldPregnancyTestMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestMethodId(v)
		return nil
	case pregnancytest.FieldPregnancyTestMethodName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestMethodName(v)
		return nil
	case pregnancytest.FieldPregnancyTestResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestResultId(v)
		return nil
	case pregnancytest.FieldPregnancyTestResultName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPregnancyTestResultName(v)
		return nil
	case pregnancytest.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case pregnancytest.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case pregnancytest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pregnancytest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pregnancytest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestMutation) AddedFields() []string {
	var fields []string
	if m.addcattleId != nil {
		fields = append(fields, pregnancytest.FieldCattleId)
	}
	if m.addtenantId != nil {
		fields = append(fields, pregnancytest.FieldTenantId)
	}
	if m.addfarmId != nil {
		fields = append(fields, pregnancytest.FieldFarmId)
	}
	if m.addshedId != nil {
		fields = append(fields, pregnancytest.FieldShedId)
	}
	if m.addtimes != nil {
		fields = append(fields, pregnancytest.FieldTimes)
	}
	if m.addbreedingAt != nil {
		fields = append(fields, pregnancytest.FieldBreedingAt)
	}
	if m.addtestAt != nil {
		fields = append(fields, pregnancytest.FieldTestAt)
	}
	if m.addpregnancyTestTypeId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestTypeId)
	}
	if m.addpregnancyTestMethodId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestMethodId)
	}
	if m.addpregnancyTestResultId != nil {
		fields = append(fields, pregnancytest.FieldPregnancyTestResultId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, pregnancytest.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, pregnancytest.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, pregnancytest.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pregnancytest.FieldCattleId:
		return m.AddedCattleId()
	case pregnancytest.FieldTenantId:
		return m.AddedTenantId()
	case pregnancytest.FieldFarmId:
		return m.AddedFarmId()
	case pregnancytest.FieldShedId:
		return m.AddedShedId()
	case pregnancytest.FieldTimes:
		return m.AddedTimes()
	case pregnancytest.FieldBreedingAt:
		return m.AddedBreedingAt()
	case pregnancytest.FieldTestAt:
		return m.AddedTestAt()
	case pregnancytest.FieldPregnancyTestTypeId:
		return m.AddedPregnancyTestTypeId()
	case pregnancytest.FieldPregnancyTestMethodId:
		return m.AddedPregnancyTestMethodId()
	case pregnancytest.FieldPregnancyTestResultId:
		return m.AddedPregnancyTestResultId()
	case pregnancytest.FieldCreatedAt:
		return m.AddedCreatedAt()
	case pregnancytest.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case pregnancytest.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pregnancytest.FieldCattleId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCattleId(v)
		return nil
	case pregnancytest.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case pregnancytest.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case pregnancytest.FieldShedId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedId(v)
		return nil
	case pregnancytest.FieldTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimes(v)
		return nil
	case pregnancytest.FieldBreedingAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBreedingAt(v)
		return nil
	case pregnancytest.FieldTestAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTestAt(v)
		return nil
	case pregnancytest.FieldPregnancyTestTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyTestTypeId(v)
		return nil
	case pregnancytest.FieldPregnancyTestMethodId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyTestMethodId(v)
		return nil
	case pregnancytest.FieldPregnancyTestResultId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPregnancyTestResultId(v)
		return nil
	case pregnancytest.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case pregnancytest.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case pregnancytest.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pregnancytest.FieldName) {
		fields = append(fields, pregnancytest.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestMutation) ClearField(name string) error {
	switch name {
	case pregnancytest.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestMutation) ResetField(name string) error {
	switch name {
	case pregnancytest.FieldCattleId:
		m.ResetCattleId()
		return nil
	case pregnancytest.FieldTenantId:
		m.ResetTenantId()
		return nil
	case pregnancytest.FieldTenantName:
		m.ResetTenantName()
		return nil
	case pregnancytest.FieldFarmId:
		m.ResetFarmId()
		return nil
	case pregnancytest.FieldFarmName:
		m.ResetFarmName()
		return nil
	case pregnancytest.FieldShedId:
		m.ResetShedId()
		return nil
	case pregnancytest.FieldShedName:
		m.ResetShedName()
		return nil
	case pregnancytest.FieldName:
		m.ResetName()
		return nil
	case pregnancytest.FieldEarNumber:
		m.ResetEarNumber()
		return nil
	case pregnancytest.FieldTimes:
		m.ResetTimes()
		return nil
	case pregnancytest.FieldBreedingAt:
		m.ResetBreedingAt()
		return nil
	case pregnancytest.FieldTestAt:
		m.ResetTestAt()
		return nil
	case pregnancytest.FieldPregnancyTestTypeId:
		m.ResetPregnancyTestTypeId()
		return nil
	case pregnancytest.FieldPregnancyTestTypeName:
		m.ResetPregnancyTestTypeName()
		return nil
	case pregnancytest.FieldPregnancyTestMethodId:
		m.ResetPregnancyTestMethodId()
		return nil
	case pregnancytest.FieldPregnancyTestMethodName:
		m.ResetPregnancyTestMethodName()
		return nil
	case pregnancytest.FieldPregnancyTestResultId:
		m.ResetPregnancyTestResultId()
		return nil
	case pregnancytest.FieldPregnancyTestResultName:
		m.ResetPregnancyTestResultName()
		return nil
	case pregnancytest.FieldUserName:
		m.ResetUserName()
		return nil
	case pregnancytest.FieldRemarks:
		m.ResetRemarks()
		return nil
	case pregnancytest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pregnancytest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pregnancytest.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTest unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTest edge %s", name)
}

// PregnancyTestMethodMutation represents an operation that mutate the PregnancyTestMethods
// nodes in the graph.
type PregnancyTestMethodMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PregnancyTestMethod, error)
}

var _ ent.Mutation = (*PregnancyTestMethodMutation)(nil)

// pregnancytestmethodOption allows to manage the mutation configuration using functional options.
type pregnancytestmethodOption func(*PregnancyTestMethodMutation)

// newPregnancyTestMethodMutation creates new mutation for $n.Name.
func newPregnancyTestMethodMutation(c config, op Op, opts ...pregnancytestmethodOption) *PregnancyTestMethodMutation {
	m := &PregnancyTestMethodMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTestMethod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestMethodID sets the id field of the mutation.
func withPregnancyTestMethodID(id int64) pregnancytestmethodOption {
	return func(m *PregnancyTestMethodMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTestMethod
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTestMethod, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTestMethod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTestMethod sets the old PregnancyTestMethod of the mutation.
func withPregnancyTestMethod(node *PregnancyTestMethod) pregnancytestmethodOption {
	return func(m *PregnancyTestMethodMutation) {
		m.oldValue = func(context.Context) (*PregnancyTestMethod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestMethodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestMethodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestMethodMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PregnancyTestMethodMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestMethodMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTestMethod.
// If the PregnancyTestMethod object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestMethodMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestMethodMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *PregnancyTestMethodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTestMethod).
func (m *PregnancyTestMethodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestMethodMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, pregnancytestmethod.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestMethodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytestmethod.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestMethodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytestmethod.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTestMethod field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMethodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytestmethod.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestMethod field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestMethodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestMethodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestMethodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PregnancyTestMethod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestMethodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestMethodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestMethodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PregnancyTestMethod nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestMethodMutation) ResetField(name string) error {
	switch name {
	case pregnancytestmethod.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestMethod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestMethodMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestMethodMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestMethodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestMethodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestMethodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestMethodMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestMethodMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestMethod unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestMethodMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestMethod edge %s", name)
}

// PregnancyTestResultMutation represents an operation that mutate the PregnancyTestResults
// nodes in the graph.
type PregnancyTestResultMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PregnancyTestResult, error)
}

var _ ent.Mutation = (*PregnancyTestResultMutation)(nil)

// pregnancytestresultOption allows to manage the mutation configuration using functional options.
type pregnancytestresultOption func(*PregnancyTestResultMutation)

// newPregnancyTestResultMutation creates new mutation for $n.Name.
func newPregnancyTestResultMutation(c config, op Op, opts ...pregnancytestresultOption) *PregnancyTestResultMutation {
	m := &PregnancyTestResultMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTestResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestResultID sets the id field of the mutation.
func withPregnancyTestResultID(id int64) pregnancytestresultOption {
	return func(m *PregnancyTestResultMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTestResult
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTestResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTestResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTestResult sets the old PregnancyTestResult of the mutation.
func withPregnancyTestResult(node *PregnancyTestResult) pregnancytestresultOption {
	return func(m *PregnancyTestResultMutation) {
		m.oldValue = func(context.Context) (*PregnancyTestResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestResultMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PregnancyTestResultMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestResultMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTestResult.
// If the PregnancyTestResult object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestResultMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestResultMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *PregnancyTestResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTestResult).
func (m *PregnancyTestResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestResultMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, pregnancytestresult.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytestresult.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytestresult.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTestResult field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytestresult.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PregnancyTestResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PregnancyTestResult nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestResultMutation) ResetField(name string) error {
	switch name {
	case pregnancytestresult.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestResult unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestResult edge %s", name)
}

// PregnancyTestTypeMutation represents an operation that mutate the PregnancyTestTypes
// nodes in the graph.
type PregnancyTestTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PregnancyTestType, error)
}

var _ ent.Mutation = (*PregnancyTestTypeMutation)(nil)

// pregnancytesttypeOption allows to manage the mutation configuration using functional options.
type pregnancytesttypeOption func(*PregnancyTestTypeMutation)

// newPregnancyTestTypeMutation creates new mutation for $n.Name.
func newPregnancyTestTypeMutation(c config, op Op, opts ...pregnancytesttypeOption) *PregnancyTestTypeMutation {
	m := &PregnancyTestTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePregnancyTestType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPregnancyTestTypeID sets the id field of the mutation.
func withPregnancyTestTypeID(id int64) pregnancytesttypeOption {
	return func(m *PregnancyTestTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PregnancyTestType
		)
		m.oldValue = func(ctx context.Context) (*PregnancyTestType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PregnancyTestType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPregnancyTestType sets the old PregnancyTestType of the mutation.
func withPregnancyTestType(node *PregnancyTestType) pregnancytesttypeOption {
	return func(m *PregnancyTestTypeMutation) {
		m.oldValue = func(context.Context) (*PregnancyTestType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PregnancyTestTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PregnancyTestTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PregnancyTestTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *PregnancyTestTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PregnancyTestTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PregnancyTestType.
// If the PregnancyTestType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PregnancyTestTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PregnancyTestTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *PregnancyTestTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PregnancyTestType).
func (m *PregnancyTestTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PregnancyTestTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, pregnancytesttype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PregnancyTestTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pregnancytesttype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PregnancyTestTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pregnancytesttype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PregnancyTestType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pregnancytesttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PregnancyTestTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PregnancyTestTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PregnancyTestTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PregnancyTestType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PregnancyTestTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PregnancyTestTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PregnancyTestTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PregnancyTestType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PregnancyTestTypeMutation) ResetField(name string) error {
	switch name {
	case pregnancytesttype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PregnancyTestType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PregnancyTestTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PregnancyTestTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PregnancyTestTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PregnancyTestTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PregnancyTestTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PregnancyTestTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PregnancyTestTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PregnancyTestTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PregnancyTestType edge %s", name)
}

// RationMutation represents an operation that mutate the Rations
// nodes in the graph.
type RationMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	name           *string
	code           *string
	status         *int
	addstatus      *int
	createDate     *int64
	addcreateDate  *int64
	adjustDate     *int64
	addadjustDate  *int64
	disableDate    *int64
	adddisableDate *int64
	cost           *int64
	addcost        *int64
	tenantId       *int64
	addtenantId    *int64
	tenantName     *string
	remarks        *string
	createdAt      *int64
	addcreatedAt   *int64
	updatedAt      *int64
	addupdatedAt   *int64
	deleted        *int
	adddeleted     *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Ration, error)
}

var _ ent.Mutation = (*RationMutation)(nil)

// rationOption allows to manage the mutation configuration using functional options.
type rationOption func(*RationMutation)

// newRationMutation creates new mutation for $n.Name.
func newRationMutation(c config, op Op, opts ...rationOption) *RationMutation {
	m := &RationMutation{
		config:        c,
		op:            op,
		typ:           TypeRation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRationID sets the id field of the mutation.
func withRationID(id int64) rationOption {
	return func(m *RationMutation) {
		var (
			err   error
			once  sync.Once
			value *Ration
		)
		m.oldValue = func(ctx context.Context) (*Ration, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRation sets the old Ration of the mutation.
func withRation(node *Ration) rationOption {
	return func(m *RationMutation) {
		m.oldValue = func(context.Context) (*Ration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RationMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *RationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *RationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *RationMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the status field.
func (m *RationMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the status value in the mutation.
func (m *RationMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old status value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to status.
func (m *RationMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the status field in this mutation.
func (m *RationMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus reset all changes of the "status" field.
func (m *RationMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreateDate sets the createDate field.
func (m *RationMutation) SetCreateDate(i int64) {
	m.createDate = &i
	m.addcreateDate = nil
}

// CreateDate returns the createDate value in the mutation.
func (m *RationMutation) CreateDate() (r int64, exists bool) {
	v := m.createDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateDate returns the old createDate value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldCreateDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateDate: %w", err)
	}
	return oldValue.CreateDate, nil
}

// AddCreateDate adds i to createDate.
func (m *RationMutation) AddCreateDate(i int64) {
	if m.addcreateDate != nil {
		*m.addcreateDate += i
	} else {
		m.addcreateDate = &i
	}
}

// AddedCreateDate returns the value that was added to the createDate field in this mutation.
func (m *RationMutation) AddedCreateDate() (r int64, exists bool) {
	v := m.addcreateDate
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateDate reset all changes of the "createDate" field.
func (m *RationMutation) ResetCreateDate() {
	m.createDate = nil
	m.addcreateDate = nil
}

// SetAdjustDate sets the adjustDate field.
func (m *RationMutation) SetAdjustDate(i int64) {
	m.adjustDate = &i
	m.addadjustDate = nil
}

// AdjustDate returns the adjustDate value in the mutation.
func (m *RationMutation) AdjustDate() (r int64, exists bool) {
	v := m.adjustDate
	if v == nil {
		return
	}
	return *v, true
}

// OldAdjustDate returns the old adjustDate value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldAdjustDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdjustDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdjustDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdjustDate: %w", err)
	}
	return oldValue.AdjustDate, nil
}

// AddAdjustDate adds i to adjustDate.
func (m *RationMutation) AddAdjustDate(i int64) {
	if m.addadjustDate != nil {
		*m.addadjustDate += i
	} else {
		m.addadjustDate = &i
	}
}

// AddedAdjustDate returns the value that was added to the adjustDate field in this mutation.
func (m *RationMutation) AddedAdjustDate() (r int64, exists bool) {
	v := m.addadjustDate
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdjustDate reset all changes of the "adjustDate" field.
func (m *RationMutation) ResetAdjustDate() {
	m.adjustDate = nil
	m.addadjustDate = nil
}

// SetDisableDate sets the disableDate field.
func (m *RationMutation) SetDisableDate(i int64) {
	m.disableDate = &i
	m.adddisableDate = nil
}

// DisableDate returns the disableDate value in the mutation.
func (m *RationMutation) DisableDate() (r int64, exists bool) {
	v := m.disableDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDisableDate returns the old disableDate value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldDisableDate(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisableDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisableDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisableDate: %w", err)
	}
	return oldValue.DisableDate, nil
}

// AddDisableDate adds i to disableDate.
func (m *RationMutation) AddDisableDate(i int64) {
	if m.adddisableDate != nil {
		*m.adddisableDate += i
	} else {
		m.adddisableDate = &i
	}
}

// AddedDisableDate returns the value that was added to the disableDate field in this mutation.
func (m *RationMutation) AddedDisableDate() (r int64, exists bool) {
	v := m.adddisableDate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisableDate reset all changes of the "disableDate" field.
func (m *RationMutation) ResetDisableDate() {
	m.disableDate = nil
	m.adddisableDate = nil
}

// SetCost sets the cost field.
func (m *RationMutation) SetCost(i int64) {
	m.cost = &i
	m.addcost = nil
}

// Cost returns the cost value in the mutation.
func (m *RationMutation) Cost() (r int64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old cost value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCost is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds i to cost.
func (m *RationMutation) AddCost(i int64) {
	if m.addcost != nil {
		*m.addcost += i
	} else {
		m.addcost = &i
	}
}

// AddedCost returns the value that was added to the cost field in this mutation.
func (m *RationMutation) AddedCost() (r int64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost reset all changes of the "cost" field.
func (m *RationMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetTenantId sets the tenantId field.
func (m *RationMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *RationMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *RationMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *RationMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *RationMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *RationMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *RationMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *RationMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *RationMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *RationMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *RationMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *RationMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *RationMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *RationMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *RationMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *RationMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *RationMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *RationMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *RationMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *RationMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *RationMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *RationMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *RationMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Ration.
// If the Ration object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RationMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *RationMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *RationMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *RationMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *RationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ration).
func (m *RationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.name != nil {
		fields = append(fields, ration.FieldName)
	}
	if m.code != nil {
		fields = append(fields, ration.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, ration.FieldStatus)
	}
	if m.createDate != nil {
		fields = append(fields, ration.FieldCreateDate)
	}
	if m.adjustDate != nil {
		fields = append(fields, ration.FieldAdjustDate)
	}
	if m.disableDate != nil {
		fields = append(fields, ration.FieldDisableDate)
	}
	if m.cost != nil {
		fields = append(fields, ration.FieldCost)
	}
	if m.tenantId != nil {
		fields = append(fields, ration.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, ration.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, ration.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, ration.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, ration.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, ration.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ration.FieldName:
		return m.Name()
	case ration.FieldCode:
		return m.Code()
	case ration.FieldStatus:
		return m.Status()
	case ration.FieldCreateDate:
		return m.CreateDate()
	case ration.FieldAdjustDate:
		return m.AdjustDate()
	case ration.FieldDisableDate:
		return m.DisableDate()
	case ration.FieldCost:
		return m.Cost()
	case ration.FieldTenantId:
		return m.TenantId()
	case ration.FieldTenantName:
		return m.TenantName()
	case ration.FieldRemarks:
		return m.Remarks()
	case ration.FieldCreatedAt:
		return m.CreatedAt()
	case ration.FieldUpdatedAt:
		return m.UpdatedAt()
	case ration.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ration.FieldName:
		return m.OldName(ctx)
	case ration.FieldCode:
		return m.OldCode(ctx)
	case ration.FieldStatus:
		return m.OldStatus(ctx)
	case ration.FieldCreateDate:
		return m.OldCreateDate(ctx)
	case ration.FieldAdjustDate:
		return m.OldAdjustDate(ctx)
	case ration.FieldDisableDate:
		return m.OldDisableDate(ctx)
	case ration.FieldCost:
		return m.OldCost(ctx)
	case ration.FieldTenantId:
		return m.OldTenantId(ctx)
	case ration.FieldTenantName:
		return m.OldTenantName(ctx)
	case ration.FieldRemarks:
		return m.OldRemarks(ctx)
	case ration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ration.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Ration field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ration.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case ration.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ration.FieldCreateDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateDate(v)
		return nil
	case ration.FieldAdjustDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdjustDate(v)
		return nil
	case ration.FieldDisableDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisableDate(v)
		return nil
	case ration.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case ration.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case ration.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case ration.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case ration.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ration.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ration.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Ration field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RationMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, ration.FieldStatus)
	}
	if m.addcreateDate != nil {
		fields = append(fields, ration.FieldCreateDate)
	}
	if m.addadjustDate != nil {
		fields = append(fields, ration.FieldAdjustDate)
	}
	if m.adddisableDate != nil {
		fields = append(fields, ration.FieldDisableDate)
	}
	if m.addcost != nil {
		fields = append(fields, ration.FieldCost)
	}
	if m.addtenantId != nil {
		fields = append(fields, ration.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, ration.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, ration.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, ration.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ration.FieldStatus:
		return m.AddedStatus()
	case ration.FieldCreateDate:
		return m.AddedCreateDate()
	case ration.FieldAdjustDate:
		return m.AddedAdjustDate()
	case ration.FieldDisableDate:
		return m.AddedDisableDate()
	case ration.FieldCost:
		return m.AddedCost()
	case ration.FieldTenantId:
		return m.AddedTenantId()
	case ration.FieldCreatedAt:
		return m.AddedCreatedAt()
	case ration.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case ration.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ration.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case ration.FieldCreateDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateDate(v)
		return nil
	case ration.FieldAdjustDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdjustDate(v)
		return nil
	case ration.FieldDisableDate:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisableDate(v)
		return nil
	case ration.FieldCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case ration.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case ration.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case ration.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case ration.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Ration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ration nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RationMutation) ResetField(name string) error {
	switch name {
	case ration.FieldName:
		m.ResetName()
		return nil
	case ration.FieldCode:
		m.ResetCode()
		return nil
	case ration.FieldStatus:
		m.ResetStatus()
		return nil
	case ration.FieldCreateDate:
		m.ResetCreateDate()
		return nil
	case ration.FieldAdjustDate:
		m.ResetAdjustDate()
		return nil
	case ration.FieldDisableDate:
		m.ResetDisableDate()
		return nil
	case ration.FieldCost:
		m.ResetCost()
		return nil
	case ration.FieldTenantId:
		m.ResetTenantId()
		return nil
	case ration.FieldTenantName:
		m.ResetTenantName()
		return nil
	case ration.FieldRemarks:
		m.ResetRemarks()
		return nil
	case ration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ration.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Ration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ration unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ration edge %s", name)
}

// ReproductionParametersMutation represents an operation that mutate the ReproductionParametersSlice
// nodes in the graph.
type ReproductionParametersMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	value         *int64
	addvalue      *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ReproductionParameters, error)
}

var _ ent.Mutation = (*ReproductionParametersMutation)(nil)

// reproductionparametersOption allows to manage the mutation configuration using functional options.
type reproductionparametersOption func(*ReproductionParametersMutation)

// newReproductionParametersMutation creates new mutation for $n.Name.
func newReproductionParametersMutation(c config, op Op, opts ...reproductionparametersOption) *ReproductionParametersMutation {
	m := &ReproductionParametersMutation{
		config:        c,
		op:            op,
		typ:           TypeReproductionParameters,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReproductionParametersID sets the id field of the mutation.
func withReproductionParametersID(id int64) reproductionparametersOption {
	return func(m *ReproductionParametersMutation) {
		var (
			err   error
			once  sync.Once
			value *ReproductionParameters
		)
		m.oldValue = func(ctx context.Context) (*ReproductionParameters, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReproductionParameters.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReproductionParameters sets the old ReproductionParameters of the mutation.
func withReproductionParameters(node *ReproductionParameters) reproductionparametersOption {
	return func(m *ReproductionParametersMutation) {
		m.oldValue = func(context.Context) (*ReproductionParameters, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReproductionParametersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReproductionParametersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReproductionParametersMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ReproductionParametersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ReproductionParametersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ReproductionParametersMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *ReproductionParametersMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *ReproductionParametersMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *ReproductionParametersMutation) ResetCode() {
	m.code = nil
}

// SetValue sets the value field.
func (m *ReproductionParametersMutation) SetValue(i int64) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value value in the mutation.
func (m *ReproductionParametersMutation) Value() (r int64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old value value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldValue(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to value.
func (m *ReproductionParametersMutation) AddValue(i int64) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the value field in this mutation.
func (m *ReproductionParametersMutation) AddedValue() (r int64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue reset all changes of the "value" field.
func (m *ReproductionParametersMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetTenantId sets the tenantId field.
func (m *ReproductionParametersMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *ReproductionParametersMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *ReproductionParametersMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *ReproductionParametersMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *ReproductionParametersMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *ReproductionParametersMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *ReproductionParametersMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *ReproductionParametersMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *ReproductionParametersMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ReproductionParametersMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ReproductionParametersMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ReproductionParametersMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ReproductionParametersMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ReproductionParametersMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ReproductionParametersMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ReproductionParametersMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ReproductionParametersMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ReproductionParametersMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ReproductionParametersMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ReproductionParametersMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ReproductionParametersMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ReproductionParametersMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ReproductionParametersMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the ReproductionParameters.
// If the ReproductionParameters object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductionParametersMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ReproductionParametersMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ReproductionParametersMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ReproductionParametersMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ReproductionParametersMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReproductionParameters).
func (m *ReproductionParametersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReproductionParametersMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, reproductionparameters.FieldName)
	}
	if m.code != nil {
		fields = append(fields, reproductionparameters.FieldCode)
	}
	if m.value != nil {
		fields = append(fields, reproductionparameters.FieldValue)
	}
	if m.tenantId != nil {
		fields = append(fields, reproductionparameters.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, reproductionparameters.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, reproductionparameters.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, reproductionparameters.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, reproductionparameters.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, reproductionparameters.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReproductionParametersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reproductionparameters.FieldName:
		return m.Name()
	case reproductionparameters.FieldCode:
		return m.Code()
	case reproductionparameters.FieldValue:
		return m.Value()
	case reproductionparameters.FieldTenantId:
		return m.TenantId()
	case reproductionparameters.FieldTenantName:
		return m.TenantName()
	case reproductionparameters.FieldRemarks:
		return m.Remarks()
	case reproductionparameters.FieldCreatedAt:
		return m.CreatedAt()
	case reproductionparameters.FieldUpdatedAt:
		return m.UpdatedAt()
	case reproductionparameters.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReproductionParametersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reproductionparameters.FieldName:
		return m.OldName(ctx)
	case reproductionparameters.FieldCode:
		return m.OldCode(ctx)
	case reproductionparameters.FieldValue:
		return m.OldValue(ctx)
	case reproductionparameters.FieldTenantId:
		return m.OldTenantId(ctx)
	case reproductionparameters.FieldTenantName:
		return m.OldTenantName(ctx)
	case reproductionparameters.FieldRemarks:
		return m.OldRemarks(ctx)
	case reproductionparameters.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reproductionparameters.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reproductionparameters.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown ReproductionParameters field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReproductionParametersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reproductionparameters.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case reproductionparameters.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case reproductionparameters.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case reproductionparameters.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case reproductionparameters.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case reproductionparameters.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case reproductionparameters.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reproductionparameters.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reproductionparameters.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ReproductionParameters field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReproductionParametersMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, reproductionparameters.FieldValue)
	}
	if m.addtenantId != nil {
		fields = append(fields, reproductionparameters.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, reproductionparameters.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, reproductionparameters.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, reproductionparameters.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReproductionParametersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reproductionparameters.FieldValue:
		return m.AddedValue()
	case reproductionparameters.FieldTenantId:
		return m.AddedTenantId()
	case reproductionparameters.FieldCreatedAt:
		return m.AddedCreatedAt()
	case reproductionparameters.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case reproductionparameters.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReproductionParametersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reproductionparameters.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case reproductionparameters.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case reproductionparameters.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case reproductionparameters.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case reproductionparameters.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ReproductionParameters numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReproductionParametersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReproductionParametersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReproductionParametersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReproductionParameters nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReproductionParametersMutation) ResetField(name string) error {
	switch name {
	case reproductionparameters.FieldName:
		m.ResetName()
		return nil
	case reproductionparameters.FieldCode:
		m.ResetCode()
		return nil
	case reproductionparameters.FieldValue:
		m.ResetValue()
		return nil
	case reproductionparameters.FieldTenantId:
		m.ResetTenantId()
		return nil
	case reproductionparameters.FieldTenantName:
		m.ResetTenantName()
		return nil
	case reproductionparameters.FieldRemarks:
		m.ResetRemarks()
		return nil
	case reproductionparameters.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reproductionparameters.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reproductionparameters.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown ReproductionParameters field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReproductionParametersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReproductionParametersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReproductionParametersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReproductionParametersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReproductionParametersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReproductionParametersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReproductionParametersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReproductionParameters unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReproductionParametersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReproductionParameters edge %s", name)
}

// ReproductiveStateMutation represents an operation that mutate the ReproductiveStates
// nodes in the graph.
type ReproductiveStateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ReproductiveState, error)
}

var _ ent.Mutation = (*ReproductiveStateMutation)(nil)

// reproductivestateOption allows to manage the mutation configuration using functional options.
type reproductivestateOption func(*ReproductiveStateMutation)

// newReproductiveStateMutation creates new mutation for $n.Name.
func newReproductiveStateMutation(c config, op Op, opts ...reproductivestateOption) *ReproductiveStateMutation {
	m := &ReproductiveStateMutation{
		config:        c,
		op:            op,
		typ:           TypeReproductiveState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReproductiveStateID sets the id field of the mutation.
func withReproductiveStateID(id int64) reproductivestateOption {
	return func(m *ReproductiveStateMutation) {
		var (
			err   error
			once  sync.Once
			value *ReproductiveState
		)
		m.oldValue = func(ctx context.Context) (*ReproductiveState, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReproductiveState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReproductiveState sets the old ReproductiveState of the mutation.
func withReproductiveState(node *ReproductiveState) reproductivestateOption {
	return func(m *ReproductiveStateMutation) {
		m.oldValue = func(context.Context) (*ReproductiveState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReproductiveStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReproductiveStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ReproductiveStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ReproductiveStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ReproductiveStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ReproductiveState.
// If the ReproductiveState object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ReproductiveStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ReproductiveStateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *ReproductiveStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReproductiveState).
func (m *ReproductiveStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ReproductiveStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, reproductivestate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ReproductiveStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reproductivestate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ReproductiveStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reproductivestate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ReproductiveState field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReproductiveStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reproductivestate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ReproductiveState field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ReproductiveStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ReproductiveStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ReproductiveStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReproductiveState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ReproductiveStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ReproductiveStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReproductiveStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReproductiveState nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ReproductiveStateMutation) ResetField(name string) error {
	switch name {
	case reproductivestate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ReproductiveState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ReproductiveStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ReproductiveStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ReproductiveStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ReproductiveStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ReproductiveStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ReproductiveStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ReproductiveStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReproductiveState unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ReproductiveStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReproductiveState edge %s", name)
}

// SemenFrozenTypeMutation represents an operation that mutate the SemenFrozenTypes
// nodes in the graph.
type SemenFrozenTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SemenFrozenType, error)
}

var _ ent.Mutation = (*SemenFrozenTypeMutation)(nil)

// semenfrozentypeOption allows to manage the mutation configuration using functional options.
type semenfrozentypeOption func(*SemenFrozenTypeMutation)

// newSemenFrozenTypeMutation creates new mutation for $n.Name.
func newSemenFrozenTypeMutation(c config, op Op, opts ...semenfrozentypeOption) *SemenFrozenTypeMutation {
	m := &SemenFrozenTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSemenFrozenType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSemenFrozenTypeID sets the id field of the mutation.
func withSemenFrozenTypeID(id int64) semenfrozentypeOption {
	return func(m *SemenFrozenTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SemenFrozenType
		)
		m.oldValue = func(ctx context.Context) (*SemenFrozenType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SemenFrozenType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSemenFrozenType sets the old SemenFrozenType of the mutation.
func withSemenFrozenType(node *SemenFrozenType) semenfrozentypeOption {
	return func(m *SemenFrozenTypeMutation) {
		m.oldValue = func(context.Context) (*SemenFrozenType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SemenFrozenTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SemenFrozenTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SemenFrozenTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *SemenFrozenTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *SemenFrozenTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the SemenFrozenType.
// If the SemenFrozenType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SemenFrozenTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *SemenFrozenTypeMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *SemenFrozenTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SemenFrozenType).
func (m *SemenFrozenTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SemenFrozenTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, semenfrozentype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SemenFrozenTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case semenfrozentype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SemenFrozenTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case semenfrozentype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown SemenFrozenType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SemenFrozenTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case semenfrozentype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown SemenFrozenType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SemenFrozenTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SemenFrozenTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SemenFrozenTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SemenFrozenType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SemenFrozenTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SemenFrozenTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SemenFrozenTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SemenFrozenType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SemenFrozenTypeMutation) ResetField(name string) error {
	switch name {
	case semenfrozentype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown SemenFrozenType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SemenFrozenTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SemenFrozenTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SemenFrozenTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SemenFrozenTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SemenFrozenTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SemenFrozenTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SemenFrozenTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SemenFrozenType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SemenFrozenTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SemenFrozenType edge %s", name)
}

// ShedMutation represents an operation that mutate the Sheds
// nodes in the graph.
type ShedMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	name          *string
	shedCateId    *int64
	addshedCateId *int64
	shedCateName  *string
	shedTypeId    *int
	addshedTypeId *int
	shedTypeName  *string
	square        *int64
	addsquare     *int64
	length        *int64
	addlength     *int64
	width         *int64
	addwidth      *int64
	height        *int64
	addheight     *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	userId        *int
	adduserId     *int
	userName      *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Shed, error)
}

var _ ent.Mutation = (*ShedMutation)(nil)

// shedOption allows to manage the mutation configuration using functional options.
type shedOption func(*ShedMutation)

// newShedMutation creates new mutation for $n.Name.
func newShedMutation(c config, op Op, opts ...shedOption) *ShedMutation {
	m := &ShedMutation{
		config:        c,
		op:            op,
		typ:           TypeShed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedID sets the id field of the mutation.
func withShedID(id int64) shedOption {
	return func(m *ShedMutation) {
		var (
			err   error
			once  sync.Once
			value *Shed
		)
		m.oldValue = func(ctx context.Context) (*Shed, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShed sets the old Shed of the mutation.
func withShed(node *Shed) shedOption {
	return func(m *ShedMutation) {
		m.oldValue = func(context.Context) (*Shed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFarmId sets the farmId field.
func (m *ShedMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *ShedMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *ShedMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *ShedMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *ShedMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
}

// SetFarmName sets the farmName field.
func (m *ShedMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *ShedMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *ShedMutation) ResetFarmName() {
	m.farmName = nil
}

// SetName sets the name field.
func (m *ShedMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ShedMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ShedMutation) ResetName() {
	m.name = nil
}

// SetShedCateId sets the shedCateId field.
func (m *ShedMutation) SetShedCateId(i int64) {
	m.shedCateId = &i
	m.addshedCateId = nil
}

// ShedCateId returns the shedCateId value in the mutation.
func (m *ShedMutation) ShedCateId() (r int64, exists bool) {
	v := m.shedCateId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedCateId returns the old shedCateId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedCateId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedCateId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedCateId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedCateId: %w", err)
	}
	return oldValue.ShedCateId, nil
}

// AddShedCateId adds i to shedCateId.
func (m *ShedMutation) AddShedCateId(i int64) {
	if m.addshedCateId != nil {
		*m.addshedCateId += i
	} else {
		m.addshedCateId = &i
	}
}

// AddedShedCateId returns the value that was added to the shedCateId field in this mutation.
func (m *ShedMutation) AddedShedCateId() (r int64, exists bool) {
	v := m.addshedCateId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedCateId reset all changes of the "shedCateId" field.
func (m *ShedMutation) ResetShedCateId() {
	m.shedCateId = nil
	m.addshedCateId = nil
}

// SetShedCateName sets the shedCateName field.
func (m *ShedMutation) SetShedCateName(s string) {
	m.shedCateName = &s
}

// ShedCateName returns the shedCateName value in the mutation.
func (m *ShedMutation) ShedCateName() (r string, exists bool) {
	v := m.shedCateName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedCateName returns the old shedCateName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedCateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedCateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedCateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedCateName: %w", err)
	}
	return oldValue.ShedCateName, nil
}

// ResetShedCateName reset all changes of the "shedCateName" field.
func (m *ShedMutation) ResetShedCateName() {
	m.shedCateName = nil
}

// SetShedTypeId sets the shedTypeId field.
func (m *ShedMutation) SetShedTypeId(i int) {
	m.shedTypeId = &i
	m.addshedTypeId = nil
}

// ShedTypeId returns the shedTypeId value in the mutation.
func (m *ShedMutation) ShedTypeId() (r int, exists bool) {
	v := m.shedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeId returns the old shedTypeId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedTypeId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeId: %w", err)
	}
	return oldValue.ShedTypeId, nil
}

// AddShedTypeId adds i to shedTypeId.
func (m *ShedMutation) AddShedTypeId(i int) {
	if m.addshedTypeId != nil {
		*m.addshedTypeId += i
	} else {
		m.addshedTypeId = &i
	}
}

// AddedShedTypeId returns the value that was added to the shedTypeId field in this mutation.
func (m *ShedMutation) AddedShedTypeId() (r int, exists bool) {
	v := m.addshedTypeId
	if v == nil {
		return
	}
	return *v, true
}

// ResetShedTypeId reset all changes of the "shedTypeId" field.
func (m *ShedMutation) ResetShedTypeId() {
	m.shedTypeId = nil
	m.addshedTypeId = nil
}

// SetShedTypeName sets the shedTypeName field.
func (m *ShedMutation) SetShedTypeName(s string) {
	m.shedTypeName = &s
}

// ShedTypeName returns the shedTypeName value in the mutation.
func (m *ShedMutation) ShedTypeName() (r string, exists bool) {
	v := m.shedTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldShedTypeName returns the old shedTypeName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldShedTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShedTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShedTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShedTypeName: %w", err)
	}
	return oldValue.ShedTypeName, nil
}

// ResetShedTypeName reset all changes of the "shedTypeName" field.
func (m *ShedMutation) ResetShedTypeName() {
	m.shedTypeName = nil
}

// SetSquare sets the square field.
func (m *ShedMutation) SetSquare(i int64) {
	m.square = &i
	m.addsquare = nil
}

// Square returns the square value in the mutation.
func (m *ShedMutation) Square() (r int64, exists bool) {
	v := m.square
	if v == nil {
		return
	}
	return *v, true
}

// OldSquare returns the old square value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldSquare(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSquare is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSquare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSquare: %w", err)
	}
	return oldValue.Square, nil
}

// AddSquare adds i to square.
func (m *ShedMutation) AddSquare(i int64) {
	if m.addsquare != nil {
		*m.addsquare += i
	} else {
		m.addsquare = &i
	}
}

// AddedSquare returns the value that was added to the square field in this mutation.
func (m *ShedMutation) AddedSquare() (r int64, exists bool) {
	v := m.addsquare
	if v == nil {
		return
	}
	return *v, true
}

// ResetSquare reset all changes of the "square" field.
func (m *ShedMutation) ResetSquare() {
	m.square = nil
	m.addsquare = nil
}

// SetLength sets the length field.
func (m *ShedMutation) SetLength(i int64) {
	m.length = &i
	m.addlength = nil
}

// Length returns the length value in the mutation.
func (m *ShedMutation) Length() (r int64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old length value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldLength(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLength is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds i to length.
func (m *ShedMutation) AddLength(i int64) {
	if m.addlength != nil {
		*m.addlength += i
	} else {
		m.addlength = &i
	}
}

// AddedLength returns the value that was added to the length field in this mutation.
func (m *ShedMutation) AddedLength() (r int64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ResetLength reset all changes of the "length" field.
func (m *ShedMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
}

// SetWidth sets the width field.
func (m *ShedMutation) SetWidth(i int64) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the width value in the mutation.
func (m *ShedMutation) Width() (r int64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old width value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldWidth(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWidth is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to width.
func (m *ShedMutation) AddWidth(i int64) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the width field in this mutation.
func (m *ShedMutation) AddedWidth() (r int64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth reset all changes of the "width" field.
func (m *ShedMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the height field.
func (m *ShedMutation) SetHeight(i int64) {
	m.height = &i
	m.addheight = nil
}

// Height returns the height value in the mutation.
func (m *ShedMutation) Height() (r int64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old height value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to height.
func (m *ShedMutation) AddHeight(i int64) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the height field in this mutation.
func (m *ShedMutation) AddedHeight() (r int64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight reset all changes of the "height" field.
func (m *ShedMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetTenantId sets the tenantId field.
func (m *ShedMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *ShedMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *ShedMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *ShedMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *ShedMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *ShedMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *ShedMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *ShedMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *ShedMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ShedMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ShedMutation) ResetRemarks() {
	m.remarks = nil
}

// SetUserId sets the userId field.
func (m *ShedMutation) SetUserId(i int) {
	m.userId = &i
	m.adduserId = nil
}

// UserId returns the userId value in the mutation.
func (m *ShedMutation) UserId() (r int, exists bool) {
	v := m.userId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old userId value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldUserId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// AddUserId adds i to userId.
func (m *ShedMutation) AddUserId(i int) {
	if m.adduserId != nil {
		*m.adduserId += i
	} else {
		m.adduserId = &i
	}
}

// AddedUserId returns the value that was added to the userId field in this mutation.
func (m *ShedMutation) AddedUserId() (r int, exists bool) {
	v := m.adduserId
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserId reset all changes of the "userId" field.
func (m *ShedMutation) ResetUserId() {
	m.userId = nil
	m.adduserId = nil
}

// SetUserName sets the userName field.
func (m *ShedMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *ShedMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *ShedMutation) ResetUserName() {
	m.userName = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ShedMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ShedMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ShedMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ShedMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ShedMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ShedMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ShedMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ShedMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ShedMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ShedMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ShedMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ShedMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Shed.
// If the Shed object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ShedMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ShedMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ShedMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ShedMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Shed).
func (m *ShedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.farmId != nil {
		fields = append(fields, shed.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, shed.FieldFarmName)
	}
	if m.name != nil {
		fields = append(fields, shed.FieldName)
	}
	if m.shedCateId != nil {
		fields = append(fields, shed.FieldShedCateId)
	}
	if m.shedCateName != nil {
		fields = append(fields, shed.FieldShedCateName)
	}
	if m.shedTypeId != nil {
		fields = append(fields, shed.FieldShedTypeId)
	}
	if m.shedTypeName != nil {
		fields = append(fields, shed.FieldShedTypeName)
	}
	if m.square != nil {
		fields = append(fields, shed.FieldSquare)
	}
	if m.length != nil {
		fields = append(fields, shed.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, shed.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, shed.FieldHeight)
	}
	if m.tenantId != nil {
		fields = append(fields, shed.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, shed.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, shed.FieldRemarks)
	}
	if m.userId != nil {
		fields = append(fields, shed.FieldUserId)
	}
	if m.userName != nil {
		fields = append(fields, shed.FieldUserName)
	}
	if m.createdAt != nil {
		fields = append(fields, shed.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, shed.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, shed.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shed.FieldFarmId:
		return m.FarmId()
	case shed.FieldFarmName:
		return m.FarmName()
	case shed.FieldName:
		return m.Name()
	case shed.FieldShedCateId:
		return m.ShedCateId()
	case shed.FieldShedCateName:
		return m.ShedCateName()
	case shed.FieldShedTypeId:
		return m.ShedTypeId()
	case shed.FieldShedTypeName:
		return m.ShedTypeName()
	case shed.FieldSquare:
		return m.Square()
	case shed.FieldLength:
		return m.Length()
	case shed.FieldWidth:
		return m.Width()
	case shed.FieldHeight:
		return m.Height()
	case shed.FieldTenantId:
		return m.TenantId()
	case shed.FieldTenantName:
		return m.TenantName()
	case shed.FieldRemarks:
		return m.Remarks()
	case shed.FieldUserId:
		return m.UserId()
	case shed.FieldUserName:
		return m.UserName()
	case shed.FieldCreatedAt:
		return m.CreatedAt()
	case shed.FieldUpdatedAt:
		return m.UpdatedAt()
	case shed.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shed.FieldFarmId:
		return m.OldFarmId(ctx)
	case shed.FieldFarmName:
		return m.OldFarmName(ctx)
	case shed.FieldName:
		return m.OldName(ctx)
	case shed.FieldShedCateId:
		return m.OldShedCateId(ctx)
	case shed.FieldShedCateName:
		return m.OldShedCateName(ctx)
	case shed.FieldShedTypeId:
		return m.OldShedTypeId(ctx)
	case shed.FieldShedTypeName:
		return m.OldShedTypeName(ctx)
	case shed.FieldSquare:
		return m.OldSquare(ctx)
	case shed.FieldLength:
		return m.OldLength(ctx)
	case shed.FieldWidth:
		return m.OldWidth(ctx)
	case shed.FieldHeight:
		return m.OldHeight(ctx)
	case shed.FieldTenantId:
		return m.OldTenantId(ctx)
	case shed.FieldTenantName:
		return m.OldTenantName(ctx)
	case shed.FieldRemarks:
		return m.OldRemarks(ctx)
	case shed.FieldUserId:
		return m.OldUserId(ctx)
	case shed.FieldUserName:
		return m.OldUserName(ctx)
	case shed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shed.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown Shed field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shed.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case shed.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case shed.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shed.FieldShedCateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedCateId(v)
		return nil
	case shed.FieldShedCateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedCateName(v)
		return nil
	case shed.FieldShedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeId(v)
		return nil
	case shed.FieldShedTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShedTypeName(v)
		return nil
	case shed.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSquare(v)
		return nil
	case shed.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case shed.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case shed.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case shed.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case shed.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case shed.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case shed.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case shed.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case shed.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shed.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shed.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Shed field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedMutation) AddedFields() []string {
	var fields []string
	if m.addfarmId != nil {
		fields = append(fields, shed.FieldFarmId)
	}
	if m.addshedCateId != nil {
		fields = append(fields, shed.FieldShedCateId)
	}
	if m.addshedTypeId != nil {
		fields = append(fields, shed.FieldShedTypeId)
	}
	if m.addsquare != nil {
		fields = append(fields, shed.FieldSquare)
	}
	if m.addlength != nil {
		fields = append(fields, shed.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, shed.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, shed.FieldHeight)
	}
	if m.addtenantId != nil {
		fields = append(fields, shed.FieldTenantId)
	}
	if m.adduserId != nil {
		fields = append(fields, shed.FieldUserId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, shed.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, shed.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, shed.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shed.FieldFarmId:
		return m.AddedFarmId()
	case shed.FieldShedCateId:
		return m.AddedShedCateId()
	case shed.FieldShedTypeId:
		return m.AddedShedTypeId()
	case shed.FieldSquare:
		return m.AddedSquare()
	case shed.FieldLength:
		return m.AddedLength()
	case shed.FieldWidth:
		return m.AddedWidth()
	case shed.FieldHeight:
		return m.AddedHeight()
	case shed.FieldTenantId:
		return m.AddedTenantId()
	case shed.FieldUserId:
		return m.AddedUserId()
	case shed.FieldCreatedAt:
		return m.AddedCreatedAt()
	case shed.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case shed.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shed.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case shed.FieldShedCateId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedCateId(v)
		return nil
	case shed.FieldShedTypeId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShedTypeId(v)
		return nil
	case shed.FieldSquare:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSquare(v)
		return nil
	case shed.FieldLength:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case shed.FieldWidth:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case shed.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case shed.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case shed.FieldUserId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserId(v)
		return nil
	case shed.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case shed.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case shed.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown Shed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Shed nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedMutation) ResetField(name string) error {
	switch name {
	case shed.FieldFarmId:
		m.ResetFarmId()
		return nil
	case shed.FieldFarmName:
		m.ResetFarmName()
		return nil
	case shed.FieldName:
		m.ResetName()
		return nil
	case shed.FieldShedCateId:
		m.ResetShedCateId()
		return nil
	case shed.FieldShedCateName:
		m.ResetShedCateName()
		return nil
	case shed.FieldShedTypeId:
		m.ResetShedTypeId()
		return nil
	case shed.FieldShedTypeName:
		m.ResetShedTypeName()
		return nil
	case shed.FieldSquare:
		m.ResetSquare()
		return nil
	case shed.FieldLength:
		m.ResetLength()
		return nil
	case shed.FieldWidth:
		m.ResetWidth()
		return nil
	case shed.FieldHeight:
		m.ResetHeight()
		return nil
	case shed.FieldTenantId:
		m.ResetTenantId()
		return nil
	case shed.FieldTenantName:
		m.ResetTenantName()
		return nil
	case shed.FieldRemarks:
		m.ResetRemarks()
		return nil
	case shed.FieldUserId:
		m.ResetUserId()
		return nil
	case shed.FieldUserName:
		m.ResetUserName()
		return nil
	case shed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shed.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown Shed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Shed unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Shed edge %s", name)
}

// ShedCategoryMutation represents an operation that mutate the ShedCategories
// nodes in the graph.
type ShedCategoryMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShedCategory, error)
}

var _ ent.Mutation = (*ShedCategoryMutation)(nil)

// shedcategoryOption allows to manage the mutation configuration using functional options.
type shedcategoryOption func(*ShedCategoryMutation)

// newShedCategoryMutation creates new mutation for $n.Name.
func newShedCategoryMutation(c config, op Op, opts ...shedcategoryOption) *ShedCategoryMutation {
	m := &ShedCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeShedCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedCategoryID sets the id field of the mutation.
func withShedCategoryID(id int64) shedcategoryOption {
	return func(m *ShedCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ShedCategory
		)
		m.oldValue = func(ctx context.Context) (*ShedCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShedCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShedCategory sets the old ShedCategory of the mutation.
func withShedCategory(node *ShedCategory) shedcategoryOption {
	return func(m *ShedCategoryMutation) {
		m.oldValue = func(context.Context) (*ShedCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedCategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ShedCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ShedCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ShedCategory.
// If the ShedCategory object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ShedCategoryMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *ShedCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShedCategory).
func (m *ShedCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedCategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, shedcategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shedcategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shedcategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ShedCategory field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shedcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ShedCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShedCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShedCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedCategoryMutation) ResetField(name string) error {
	switch name {
	case shedcategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ShedCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShedCategory unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShedCategory edge %s", name)
}

// ShedSettingMutation represents an operation that mutate the ShedSettings
// nodes in the graph.
type ShedSettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	_type         *string
	seats         *int64
	addseats      *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShedSetting, error)
}

var _ ent.Mutation = (*ShedSettingMutation)(nil)

// shedsettingOption allows to manage the mutation configuration using functional options.
type shedsettingOption func(*ShedSettingMutation)

// newShedSettingMutation creates new mutation for $n.Name.
func newShedSettingMutation(c config, op Op, opts ...shedsettingOption) *ShedSettingMutation {
	m := &ShedSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeShedSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedSettingID sets the id field of the mutation.
func withShedSettingID(id int64) shedsettingOption {
	return func(m *ShedSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *ShedSetting
		)
		m.oldValue = func(ctx context.Context) (*ShedSetting, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShedSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShedSetting sets the old ShedSetting of the mutation.
func withShedSetting(node *ShedSetting) shedsettingOption {
	return func(m *ShedSettingMutation) {
		m.oldValue = func(context.Context) (*ShedSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedSettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ShedSettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ShedSettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ShedSettingMutation) ResetName() {
	m.name = nil
}

// SetType sets the type field.
func (m *ShedSettingMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *ShedSettingMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *ShedSettingMutation) ResetType() {
	m._type = nil
}

// SetSeats sets the seats field.
func (m *ShedSettingMutation) SetSeats(i int64) {
	m.seats = &i
	m.addseats = nil
}

// Seats returns the seats value in the mutation.
func (m *ShedSettingMutation) Seats() (r int64, exists bool) {
	v := m.seats
	if v == nil {
		return
	}
	return *v, true
}

// OldSeats returns the old seats value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldSeats(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSeats is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSeats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeats: %w", err)
	}
	return oldValue.Seats, nil
}

// AddSeats adds i to seats.
func (m *ShedSettingMutation) AddSeats(i int64) {
	if m.addseats != nil {
		*m.addseats += i
	} else {
		m.addseats = &i
	}
}

// AddedSeats returns the value that was added to the seats field in this mutation.
func (m *ShedSettingMutation) AddedSeats() (r int64, exists bool) {
	v := m.addseats
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeats reset all changes of the "seats" field.
func (m *ShedSettingMutation) ResetSeats() {
	m.seats = nil
	m.addseats = nil
}

// SetTenantId sets the tenantId field.
func (m *ShedSettingMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *ShedSettingMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *ShedSettingMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *ShedSettingMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *ShedSettingMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *ShedSettingMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *ShedSettingMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *ShedSettingMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *ShedSettingMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ShedSettingMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ShedSettingMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ShedSettingMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ShedSettingMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ShedSettingMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ShedSettingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ShedSettingMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ShedSettingMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ShedSettingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ShedSettingMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ShedSettingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ShedSettingMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ShedSettingMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ShedSettingMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the ShedSetting.
// If the ShedSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedSettingMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ShedSettingMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ShedSettingMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ShedSettingMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ShedSettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShedSetting).
func (m *ShedSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedSettingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, shedsetting.FieldName)
	}
	if m._type != nil {
		fields = append(fields, shedsetting.FieldType)
	}
	if m.seats != nil {
		fields = append(fields, shedsetting.FieldSeats)
	}
	if m.tenantId != nil {
		fields = append(fields, shedsetting.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, shedsetting.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, shedsetting.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, shedsetting.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, shedsetting.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, shedsetting.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shedsetting.FieldName:
		return m.Name()
	case shedsetting.FieldType:
		return m.GetType()
	case shedsetting.FieldSeats:
		return m.Seats()
	case shedsetting.FieldTenantId:
		return m.TenantId()
	case shedsetting.FieldTenantName:
		return m.TenantName()
	case shedsetting.FieldRemarks:
		return m.Remarks()
	case shedsetting.FieldCreatedAt:
		return m.CreatedAt()
	case shedsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case shedsetting.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shedsetting.FieldName:
		return m.OldName(ctx)
	case shedsetting.FieldType:
		return m.OldType(ctx)
	case shedsetting.FieldSeats:
		return m.OldSeats(ctx)
	case shedsetting.FieldTenantId:
		return m.OldTenantId(ctx)
	case shedsetting.FieldTenantName:
		return m.OldTenantName(ctx)
	case shedsetting.FieldRemarks:
		return m.OldRemarks(ctx)
	case shedsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shedsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shedsetting.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown ShedSetting field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shedsetting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shedsetting.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case shedsetting.FieldSeats:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeats(v)
		return nil
	case shedsetting.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case shedsetting.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case shedsetting.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case shedsetting.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shedsetting.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shedsetting.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ShedSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedSettingMutation) AddedFields() []string {
	var fields []string
	if m.addseats != nil {
		fields = append(fields, shedsetting.FieldSeats)
	}
	if m.addtenantId != nil {
		fields = append(fields, shedsetting.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, shedsetting.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, shedsetting.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, shedsetting.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shedsetting.FieldSeats:
		return m.AddedSeats()
	case shedsetting.FieldTenantId:
		return m.AddedTenantId()
	case shedsetting.FieldCreatedAt:
		return m.AddedCreatedAt()
	case shedsetting.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case shedsetting.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shedsetting.FieldSeats:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeats(v)
		return nil
	case shedsetting.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case shedsetting.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case shedsetting.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case shedsetting.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ShedSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShedSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedSettingMutation) ResetField(name string) error {
	switch name {
	case shedsetting.FieldName:
		m.ResetName()
		return nil
	case shedsetting.FieldType:
		m.ResetType()
		return nil
	case shedsetting.FieldSeats:
		m.ResetSeats()
		return nil
	case shedsetting.FieldTenantId:
		m.ResetTenantId()
		return nil
	case shedsetting.FieldTenantName:
		m.ResetTenantName()
		return nil
	case shedsetting.FieldRemarks:
		m.ResetRemarks()
		return nil
	case shedsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shedsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shedsetting.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown ShedSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShedSetting unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShedSetting edge %s", name)
}

// ShedTransMutation represents an operation that mutate the ShedTransSlice
// nodes in the graph.
type ShedTransMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShedTrans, error)
}

var _ ent.Mutation = (*ShedTransMutation)(nil)

// shedtransOption allows to manage the mutation configuration using functional options.
type shedtransOption func(*ShedTransMutation)

// newShedTransMutation creates new mutation for $n.Name.
func newShedTransMutation(c config, op Op, opts ...shedtransOption) *ShedTransMutation {
	m := &ShedTransMutation{
		config:        c,
		op:            op,
		typ:           TypeShedTrans,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedTransID sets the id field of the mutation.
func withShedTransID(id int64) shedtransOption {
	return func(m *ShedTransMutation) {
		var (
			err   error
			once  sync.Once
			value *ShedTrans
		)
		m.oldValue = func(ctx context.Context) (*ShedTrans, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShedTrans.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShedTrans sets the old ShedTrans of the mutation.
func withShedTrans(node *ShedTrans) shedtransOption {
	return func(m *ShedTransMutation) {
		m.oldValue = func(context.Context) (*ShedTrans, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedTransMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedTransMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedTransMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *ShedTransMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShedTrans).
func (m *ShedTransMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedTransMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedTransMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedTransMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ShedTrans field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedTransMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShedTrans field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedTransMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedTransMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedTransMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ShedTrans numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedTransMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedTransMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedTransMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShedTrans nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedTransMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ShedTrans field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedTransMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedTransMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedTransMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedTransMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedTransMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedTransMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedTransMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShedTrans unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedTransMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShedTrans edge %s", name)
}

// ShedTypeMutation represents an operation that mutate the ShedTypes
// nodes in the graph.
type ShedTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	_order        *int
	add_order     *int
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ShedType, error)
}

var _ ent.Mutation = (*ShedTypeMutation)(nil)

// shedtypeOption allows to manage the mutation configuration using functional options.
type shedtypeOption func(*ShedTypeMutation)

// newShedTypeMutation creates new mutation for $n.Name.
func newShedTypeMutation(c config, op Op, opts ...shedtypeOption) *ShedTypeMutation {
	m := &ShedTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShedType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShedTypeID sets the id field of the mutation.
func withShedTypeID(id int64) shedtypeOption {
	return func(m *ShedTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShedType
		)
		m.oldValue = func(ctx context.Context) (*ShedType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShedType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShedType sets the old ShedType of the mutation.
func withShedType(node *ShedType) shedtypeOption {
	return func(m *ShedTypeMutation) {
		m.oldValue = func(context.Context) (*ShedType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShedTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShedTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ShedTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *ShedTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *ShedTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *ShedTypeMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *ShedTypeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *ShedTypeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *ShedTypeMutation) ResetCode() {
	m.code = nil
}

// SetTenantId sets the tenantId field.
func (m *ShedTypeMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *ShedTypeMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *ShedTypeMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *ShedTypeMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *ShedTypeMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *ShedTypeMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *ShedTypeMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *ShedTypeMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetOrder sets the order field.
func (m *ShedTypeMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the order value in the mutation.
func (m *ShedTypeMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old order value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrder is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to order.
func (m *ShedTypeMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the order field in this mutation.
func (m *ShedTypeMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder reset all changes of the "order" field.
func (m *ShedTypeMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetRemarks sets the remarks field.
func (m *ShedTypeMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *ShedTypeMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *ShedTypeMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *ShedTypeMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *ShedTypeMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *ShedTypeMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *ShedTypeMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *ShedTypeMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *ShedTypeMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *ShedTypeMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *ShedTypeMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *ShedTypeMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *ShedTypeMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *ShedTypeMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *ShedTypeMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the ShedType.
// If the ShedType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ShedTypeMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *ShedTypeMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *ShedTypeMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *ShedTypeMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *ShedTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ShedType).
func (m *ShedTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ShedTypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, shedtype.FieldName)
	}
	if m.code != nil {
		fields = append(fields, shedtype.FieldCode)
	}
	if m.tenantId != nil {
		fields = append(fields, shedtype.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, shedtype.FieldTenantName)
	}
	if m._order != nil {
		fields = append(fields, shedtype.FieldOrder)
	}
	if m.remarks != nil {
		fields = append(fields, shedtype.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, shedtype.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, shedtype.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, shedtype.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ShedTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shedtype.FieldName:
		return m.Name()
	case shedtype.FieldCode:
		return m.Code()
	case shedtype.FieldTenantId:
		return m.TenantId()
	case shedtype.FieldTenantName:
		return m.TenantName()
	case shedtype.FieldOrder:
		return m.Order()
	case shedtype.FieldRemarks:
		return m.Remarks()
	case shedtype.FieldCreatedAt:
		return m.CreatedAt()
	case shedtype.FieldUpdatedAt:
		return m.UpdatedAt()
	case shedtype.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ShedTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shedtype.FieldName:
		return m.OldName(ctx)
	case shedtype.FieldCode:
		return m.OldCode(ctx)
	case shedtype.FieldTenantId:
		return m.OldTenantId(ctx)
	case shedtype.FieldTenantName:
		return m.OldTenantName(ctx)
	case shedtype.FieldOrder:
		return m.OldOrder(ctx)
	case shedtype.FieldRemarks:
		return m.OldRemarks(ctx)
	case shedtype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shedtype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shedtype.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown ShedType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shedtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case shedtype.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case shedtype.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case shedtype.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case shedtype.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case shedtype.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case shedtype.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shedtype.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shedtype.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ShedType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ShedTypeMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, shedtype.FieldTenantId)
	}
	if m.add_order != nil {
		fields = append(fields, shedtype.FieldOrder)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, shedtype.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, shedtype.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, shedtype.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ShedTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shedtype.FieldTenantId:
		return m.AddedTenantId()
	case shedtype.FieldOrder:
		return m.AddedOrder()
	case shedtype.FieldCreatedAt:
		return m.AddedCreatedAt()
	case shedtype.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case shedtype.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ShedTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shedtype.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case shedtype.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	case shedtype.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case shedtype.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case shedtype.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown ShedType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ShedTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ShedTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShedTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShedType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ShedTypeMutation) ResetField(name string) error {
	switch name {
	case shedtype.FieldName:
		m.ResetName()
		return nil
	case shedtype.FieldCode:
		m.ResetCode()
		return nil
	case shedtype.FieldTenantId:
		m.ResetTenantId()
		return nil
	case shedtype.FieldTenantName:
		m.ResetTenantName()
		return nil
	case shedtype.FieldOrder:
		m.ResetOrder()
		return nil
	case shedtype.FieldRemarks:
		m.ResetRemarks()
		return nil
	case shedtype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shedtype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shedtype.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown ShedType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ShedTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ShedTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ShedTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ShedTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ShedTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ShedTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ShedTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ShedType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ShedTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ShedType edge %s", name)
}

// TenantMutation represents an operation that mutate the Tenants
// nodes in the graph.
type TenantMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	company       *string
	name          *string
	code          *string
	enabled       *int
	addenabled    *int
	region        *string
	address       *string
	userName      *string
	phone         *string
	remarks       *string
	deleted       *int
	adddeleted    *int
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tenant, error)
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows to manage the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for $n.Name.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the id field of the mutation.
func withTenantID(id int64) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TenantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCompany sets the company field.
func (m *TenantMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the company value in the mutation.
func (m *TenantMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old company value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompany is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany reset all changes of the "company" field.
func (m *TenantMutation) ResetCompany() {
	m.company = nil
}

// SetName sets the name field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *TenantMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *TenantMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *TenantMutation) ResetCode() {
	m.code = nil
}

// SetEnabled sets the enabled field.
func (m *TenantMutation) SetEnabled(i int) {
	m.enabled = &i
	m.addenabled = nil
}

// Enabled returns the enabled value in the mutation.
func (m *TenantMutation) Enabled() (r int, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old enabled value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldEnabled(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEnabled is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// AddEnabled adds i to enabled.
func (m *TenantMutation) AddEnabled(i int) {
	if m.addenabled != nil {
		*m.addenabled += i
	} else {
		m.addenabled = &i
	}
}

// AddedEnabled returns the value that was added to the enabled field in this mutation.
func (m *TenantMutation) AddedEnabled() (r int, exists bool) {
	v := m.addenabled
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnabled reset all changes of the "enabled" field.
func (m *TenantMutation) ResetEnabled() {
	m.enabled = nil
	m.addenabled = nil
}

// SetRegion sets the region field.
func (m *TenantMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the region value in the mutation.
func (m *TenantMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old region value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegion is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion reset all changes of the "region" field.
func (m *TenantMutation) ResetRegion() {
	m.region = nil
}

// SetAddress sets the address field.
func (m *TenantMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *TenantMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress reset all changes of the "address" field.
func (m *TenantMutation) ResetAddress() {
	m.address = nil
}

// SetUserName sets the userName field.
func (m *TenantMutation) SetUserName(s string) {
	m.userName = &s
}

// UserName returns the userName value in the mutation.
func (m *TenantMutation) UserName() (r string, exists bool) {
	v := m.userName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old userName value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "userName" field.
func (m *TenantMutation) ResetUserName() {
	m.userName = nil
}

// SetPhone sets the phone field.
func (m *TenantMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *TenantMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone reset all changes of the "phone" field.
func (m *TenantMutation) ResetPhone() {
	m.phone = nil
}

// SetRemarks sets the remarks field.
func (m *TenantMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *TenantMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *TenantMutation) ResetRemarks() {
	m.remarks = nil
}

// SetDeleted sets the deleted field.
func (m *TenantMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *TenantMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *TenantMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *TenantMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *TenantMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// SetCreatedAt sets the createdAt field.
func (m *TenantMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *TenantMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *TenantMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *TenantMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *TenantMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *TenantMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the Tenant.
// If the Tenant object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *TenantMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *TenantMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.company != nil {
		fields = append(fields, tenant.FieldCompany)
	}
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.code != nil {
		fields = append(fields, tenant.FieldCode)
	}
	if m.enabled != nil {
		fields = append(fields, tenant.FieldEnabled)
	}
	if m.region != nil {
		fields = append(fields, tenant.FieldRegion)
	}
	if m.address != nil {
		fields = append(fields, tenant.FieldAddress)
	}
	if m.userName != nil {
		fields = append(fields, tenant.FieldUserName)
	}
	if m.phone != nil {
		fields = append(fields, tenant.FieldPhone)
	}
	if m.remarks != nil {
		fields = append(fields, tenant.FieldRemarks)
	}
	if m.deleted != nil {
		fields = append(fields, tenant.FieldDeleted)
	}
	if m.createdAt != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCompany:
		return m.Company()
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldCode:
		return m.Code()
	case tenant.FieldEnabled:
		return m.Enabled()
	case tenant.FieldRegion:
		return m.Region()
	case tenant.FieldAddress:
		return m.Address()
	case tenant.FieldUserName:
		return m.UserName()
	case tenant.FieldPhone:
		return m.Phone()
	case tenant.FieldRemarks:
		return m.Remarks()
	case tenant.FieldDeleted:
		return m.Deleted()
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCompany:
		return m.OldCompany(ctx)
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldCode:
		return m.OldCode(ctx)
	case tenant.FieldEnabled:
		return m.OldEnabled(ctx)
	case tenant.FieldRegion:
		return m.OldRegion(ctx)
	case tenant.FieldAddress:
		return m.OldAddress(ctx)
	case tenant.FieldUserName:
		return m.OldUserName(ctx)
	case tenant.FieldPhone:
		return m.OldPhone(ctx)
	case tenant.FieldRemarks:
		return m.OldRemarks(ctx)
	case tenant.FieldDeleted:
		return m.OldDeleted(ctx)
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tenant.FieldEnabled:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case tenant.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case tenant.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case tenant.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case tenant.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case tenant.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case tenant.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	if m.addenabled != nil {
		fields = append(fields, tenant.FieldEnabled)
	}
	if m.adddeleted != nil {
		fields = append(fields, tenant.FieldDeleted)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldEnabled:
		return m.AddedEnabled()
	case tenant.FieldDeleted:
		return m.AddedDeleted()
	case tenant.FieldCreatedAt:
		return m.AddedCreatedAt()
	case tenant.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldEnabled:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnabled(v)
		return nil
	case tenant.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	case tenant.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TenantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCompany:
		m.ResetCompany()
		return nil
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldCode:
		m.ResetCode()
		return nil
	case tenant.FieldEnabled:
		m.ResetEnabled()
		return nil
	case tenant.FieldRegion:
		m.ResetRegion()
		return nil
	case tenant.FieldAddress:
		m.ResetAddress()
		return nil
	case tenant.FieldUserName:
		m.ResetUserName()
		return nil
	case tenant.FieldPhone:
		m.ResetPhone()
		return nil
	case tenant.FieldRemarks:
		m.ResetRemarks()
		return nil
	case tenant.FieldDeleted:
		m.ResetDeleted()
		return nil
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TreatmentResultMutation represents an operation that mutate the TreatmentResults
// nodes in the graph.
type TreatmentResultMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TreatmentResult, error)
}

var _ ent.Mutation = (*TreatmentResultMutation)(nil)

// treatmentresultOption allows to manage the mutation configuration using functional options.
type treatmentresultOption func(*TreatmentResultMutation)

// newTreatmentResultMutation creates new mutation for $n.Name.
func newTreatmentResultMutation(c config, op Op, opts ...treatmentresultOption) *TreatmentResultMutation {
	m := &TreatmentResultMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatmentResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentResultID sets the id field of the mutation.
func withTreatmentResultID(id int64) treatmentresultOption {
	return func(m *TreatmentResultMutation) {
		var (
			err   error
			once  sync.Once
			value *TreatmentResult
		)
		m.oldValue = func(ctx context.Context) (*TreatmentResult, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreatmentResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatmentResult sets the old TreatmentResult of the mutation.
func withTreatmentResult(node *TreatmentResult) treatmentresultOption {
	return func(m *TreatmentResultMutation) {
		m.oldValue = func(context.Context) (*TreatmentResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TreatmentResultMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *TreatmentResultMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TreatmentResultMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the TreatmentResult.
// If the TreatmentResult object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentResultMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TreatmentResultMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *TreatmentResultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TreatmentResult).
func (m *TreatmentResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TreatmentResultMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, treatmentresult.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TreatmentResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatmentresult.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TreatmentResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatmentresult.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TreatmentResult field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatmentresult.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TreatmentResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TreatmentResultMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TreatmentResultMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TreatmentResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TreatmentResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TreatmentResult nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TreatmentResultMutation) ResetField(name string) error {
	switch name {
	case treatmentresult.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TreatmentResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TreatmentResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TreatmentResultMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TreatmentResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TreatmentResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TreatmentResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TreatmentResultMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TreatmentResultMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TreatmentResult unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TreatmentResultMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TreatmentResult edge %s", name)
}

// TreatmentStateMutation represents an operation that mutate the TreatmentStates
// nodes in the graph.
type TreatmentStateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TreatmentState, error)
}

var _ ent.Mutation = (*TreatmentStateMutation)(nil)

// treatmentstateOption allows to manage the mutation configuration using functional options.
type treatmentstateOption func(*TreatmentStateMutation)

// newTreatmentStateMutation creates new mutation for $n.Name.
func newTreatmentStateMutation(c config, op Op, opts ...treatmentstateOption) *TreatmentStateMutation {
	m := &TreatmentStateMutation{
		config:        c,
		op:            op,
		typ:           TypeTreatmentState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreatmentStateID sets the id field of the mutation.
func withTreatmentStateID(id int64) treatmentstateOption {
	return func(m *TreatmentStateMutation) {
		var (
			err   error
			once  sync.Once
			value *TreatmentState
		)
		m.oldValue = func(ctx context.Context) (*TreatmentState, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreatmentState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreatmentState sets the old TreatmentState of the mutation.
func withTreatmentState(node *TreatmentState) treatmentstateOption {
	return func(m *TreatmentStateMutation) {
		m.oldValue = func(context.Context) (*TreatmentState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreatmentStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreatmentStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TreatmentStateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *TreatmentStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *TreatmentStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the TreatmentState.
// If the TreatmentState object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TreatmentStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *TreatmentStateMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *TreatmentStateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TreatmentState).
func (m *TreatmentStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TreatmentStateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, treatmentstate.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TreatmentStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treatmentstate.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TreatmentStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treatmentstate.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TreatmentState field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treatmentstate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TreatmentState field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TreatmentStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TreatmentStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TreatmentStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TreatmentState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TreatmentStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TreatmentStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreatmentStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TreatmentState nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TreatmentStateMutation) ResetField(name string) error {
	switch name {
	case treatmentstate.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TreatmentState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TreatmentStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TreatmentStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TreatmentStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TreatmentStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TreatmentStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TreatmentStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TreatmentStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TreatmentState unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TreatmentStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TreatmentState edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	level         *int
	addlevel      *int
	farmId        *int64
	addfarmId     *int64
	farmName      *string
	positionId    *int64
	addpositionId *int64
	positionName  *string
	dutyName      *string
	name          *string
	gender        *int
	addgender     *int
	age           *int
	addage        *int
	education     *string
	major         *string
	jobTitle      *string
	phone         *string
	idCard        *string
	address       *string
	onJobState    *int
	addonJobState *int
	joinedAt      *int64
	addjoinedAt   *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	password      *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLevel sets the level field.
func (m *UserMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the level value in the mutation.
func (m *UserMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old level value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to level.
func (m *UserMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the level field in this mutation.
func (m *UserMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel reset all changes of the "level" field.
func (m *UserMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetFarmId sets the farmId field.
func (m *UserMutation) SetFarmId(i int64) {
	m.farmId = &i
	m.addfarmId = nil
}

// FarmId returns the farmId value in the mutation.
func (m *UserMutation) FarmId() (r int64, exists bool) {
	v := m.farmId
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmId returns the old farmId value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldFarmId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmId: %w", err)
	}
	return oldValue.FarmId, nil
}

// AddFarmId adds i to farmId.
func (m *UserMutation) AddFarmId(i int64) {
	if m.addfarmId != nil {
		*m.addfarmId += i
	} else {
		m.addfarmId = &i
	}
}

// AddedFarmId returns the value that was added to the farmId field in this mutation.
func (m *UserMutation) AddedFarmId() (r int64, exists bool) {
	v := m.addfarmId
	if v == nil {
		return
	}
	return *v, true
}

// ClearFarmId clears the value of farmId.
func (m *UserMutation) ClearFarmId() {
	m.farmId = nil
	m.addfarmId = nil
	m.clearedFields[user.FieldFarmId] = struct{}{}
}

// FarmIdCleared returns if the field farmId was cleared in this mutation.
func (m *UserMutation) FarmIdCleared() bool {
	_, ok := m.clearedFields[user.FieldFarmId]
	return ok
}

// ResetFarmId reset all changes of the "farmId" field.
func (m *UserMutation) ResetFarmId() {
	m.farmId = nil
	m.addfarmId = nil
	delete(m.clearedFields, user.FieldFarmId)
}

// SetFarmName sets the farmName field.
func (m *UserMutation) SetFarmName(s string) {
	m.farmName = &s
}

// FarmName returns the farmName value in the mutation.
func (m *UserMutation) FarmName() (r string, exists bool) {
	v := m.farmName
	if v == nil {
		return
	}
	return *v, true
}

// OldFarmName returns the old farmName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldFarmName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFarmName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFarmName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFarmName: %w", err)
	}
	return oldValue.FarmName, nil
}

// ClearFarmName clears the value of farmName.
func (m *UserMutation) ClearFarmName() {
	m.farmName = nil
	m.clearedFields[user.FieldFarmName] = struct{}{}
}

// FarmNameCleared returns if the field farmName was cleared in this mutation.
func (m *UserMutation) FarmNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFarmName]
	return ok
}

// ResetFarmName reset all changes of the "farmName" field.
func (m *UserMutation) ResetFarmName() {
	m.farmName = nil
	delete(m.clearedFields, user.FieldFarmName)
}

// SetPositionId sets the positionId field.
func (m *UserMutation) SetPositionId(i int64) {
	m.positionId = &i
	m.addpositionId = nil
}

// PositionId returns the positionId value in the mutation.
func (m *UserMutation) PositionId() (r int64, exists bool) {
	v := m.positionId
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionId returns the old positionId value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPositionId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionId: %w", err)
	}
	return oldValue.PositionId, nil
}

// AddPositionId adds i to positionId.
func (m *UserMutation) AddPositionId(i int64) {
	if m.addpositionId != nil {
		*m.addpositionId += i
	} else {
		m.addpositionId = &i
	}
}

// AddedPositionId returns the value that was added to the positionId field in this mutation.
func (m *UserMutation) AddedPositionId() (r int64, exists bool) {
	v := m.addpositionId
	if v == nil {
		return
	}
	return *v, true
}

// ClearPositionId clears the value of positionId.
func (m *UserMutation) ClearPositionId() {
	m.positionId = nil
	m.addpositionId = nil
	m.clearedFields[user.FieldPositionId] = struct{}{}
}

// PositionIdCleared returns if the field positionId was cleared in this mutation.
func (m *UserMutation) PositionIdCleared() bool {
	_, ok := m.clearedFields[user.FieldPositionId]
	return ok
}

// ResetPositionId reset all changes of the "positionId" field.
func (m *UserMutation) ResetPositionId() {
	m.positionId = nil
	m.addpositionId = nil
	delete(m.clearedFields, user.FieldPositionId)
}

// SetPositionName sets the positionName field.
func (m *UserMutation) SetPositionName(s string) {
	m.positionName = &s
}

// PositionName returns the positionName value in the mutation.
func (m *UserMutation) PositionName() (r string, exists bool) {
	v := m.positionName
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionName returns the old positionName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPositionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositionName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionName: %w", err)
	}
	return oldValue.PositionName, nil
}

// ClearPositionName clears the value of positionName.
func (m *UserMutation) ClearPositionName() {
	m.positionName = nil
	m.clearedFields[user.FieldPositionName] = struct{}{}
}

// PositionNameCleared returns if the field positionName was cleared in this mutation.
func (m *UserMutation) PositionNameCleared() bool {
	_, ok := m.clearedFields[user.FieldPositionName]
	return ok
}

// ResetPositionName reset all changes of the "positionName" field.
func (m *UserMutation) ResetPositionName() {
	m.positionName = nil
	delete(m.clearedFields, user.FieldPositionName)
}

// SetDutyName sets the dutyName field.
func (m *UserMutation) SetDutyName(s string) {
	m.dutyName = &s
}

// DutyName returns the dutyName value in the mutation.
func (m *UserMutation) DutyName() (r string, exists bool) {
	v := m.dutyName
	if v == nil {
		return
	}
	return *v, true
}

// OldDutyName returns the old dutyName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDutyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDutyName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDutyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDutyName: %w", err)
	}
	return oldValue.DutyName, nil
}

// ClearDutyName clears the value of dutyName.
func (m *UserMutation) ClearDutyName() {
	m.dutyName = nil
	m.clearedFields[user.FieldDutyName] = struct{}{}
}

// DutyNameCleared returns if the field dutyName was cleared in this mutation.
func (m *UserMutation) DutyNameCleared() bool {
	_, ok := m.clearedFields[user.FieldDutyName]
	return ok
}

// ResetDutyName reset all changes of the "dutyName" field.
func (m *UserMutation) ResetDutyName() {
	m.dutyName = nil
	delete(m.clearedFields, user.FieldDutyName)
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetGender sets the gender field.
func (m *UserMutation) SetGender(i int) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the gender value in the mutation.
func (m *UserMutation) Gender() (r int, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to gender.
func (m *UserMutation) AddGender(i int) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the gender field in this mutation.
func (m *UserMutation) AddedGender() (r int, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ClearGender clears the value of gender.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.addgender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the field gender was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender reset all changes of the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetAge sets the age field.
func (m *UserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the age value in the mutation.
func (m *UserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old age value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to age.
func (m *UserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the age field in this mutation.
func (m *UserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of age.
func (m *UserMutation) ClearAge() {
	m.age = nil
	m.addage = nil
	m.clearedFields[user.FieldAge] = struct{}{}
}

// AgeCleared returns if the field age was cleared in this mutation.
func (m *UserMutation) AgeCleared() bool {
	_, ok := m.clearedFields[user.FieldAge]
	return ok
}

// ResetAge reset all changes of the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
	delete(m.clearedFields, user.FieldAge)
}

// SetEducation sets the education field.
func (m *UserMutation) SetEducation(s string) {
	m.education = &s
}

// Education returns the education value in the mutation.
func (m *UserMutation) Education() (r string, exists bool) {
	v := m.education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old education value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEducation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ClearEducation clears the value of education.
func (m *UserMutation) ClearEducation() {
	m.education = nil
	m.clearedFields[user.FieldEducation] = struct{}{}
}

// EducationCleared returns if the field education was cleared in this mutation.
func (m *UserMutation) EducationCleared() bool {
	_, ok := m.clearedFields[user.FieldEducation]
	return ok
}

// ResetEducation reset all changes of the "education" field.
func (m *UserMutation) ResetEducation() {
	m.education = nil
	delete(m.clearedFields, user.FieldEducation)
}

// SetMajor sets the major field.
func (m *UserMutation) SetMajor(s string) {
	m.major = &s
}

// Major returns the major value in the mutation.
func (m *UserMutation) Major() (r string, exists bool) {
	v := m.major
	if v == nil {
		return
	}
	return *v, true
}

// OldMajor returns the old major value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldMajor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMajor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMajor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMajor: %w", err)
	}
	return oldValue.Major, nil
}

// ClearMajor clears the value of major.
func (m *UserMutation) ClearMajor() {
	m.major = nil
	m.clearedFields[user.FieldMajor] = struct{}{}
}

// MajorCleared returns if the field major was cleared in this mutation.
func (m *UserMutation) MajorCleared() bool {
	_, ok := m.clearedFields[user.FieldMajor]
	return ok
}

// ResetMajor reset all changes of the "major" field.
func (m *UserMutation) ResetMajor() {
	m.major = nil
	delete(m.clearedFields, user.FieldMajor)
}

// SetJobTitle sets the jobTitle field.
func (m *UserMutation) SetJobTitle(s string) {
	m.jobTitle = &s
}

// JobTitle returns the jobTitle value in the mutation.
func (m *UserMutation) JobTitle() (r string, exists bool) {
	v := m.jobTitle
	if v == nil {
		return
	}
	return *v, true
}

// OldJobTitle returns the old jobTitle value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldJobTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJobTitle is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJobTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobTitle: %w", err)
	}
	return oldValue.JobTitle, nil
}

// ClearJobTitle clears the value of jobTitle.
func (m *UserMutation) ClearJobTitle() {
	m.jobTitle = nil
	m.clearedFields[user.FieldJobTitle] = struct{}{}
}

// JobTitleCleared returns if the field jobTitle was cleared in this mutation.
func (m *UserMutation) JobTitleCleared() bool {
	_, ok := m.clearedFields[user.FieldJobTitle]
	return ok
}

// ResetJobTitle reset all changes of the "jobTitle" field.
func (m *UserMutation) ResetJobTitle() {
	m.jobTitle = nil
	delete(m.clearedFields, user.FieldJobTitle)
}

// SetPhone sets the phone field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of phone.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the field phone was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone reset all changes of the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetIdCard sets the idCard field.
func (m *UserMutation) SetIdCard(s string) {
	m.idCard = &s
}

// IdCard returns the idCard value in the mutation.
func (m *UserMutation) IdCard() (r string, exists bool) {
	v := m.idCard
	if v == nil {
		return
	}
	return *v, true
}

// OldIdCard returns the old idCard value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldIdCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIdCard is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIdCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdCard: %w", err)
	}
	return oldValue.IdCard, nil
}

// ClearIdCard clears the value of idCard.
func (m *UserMutation) ClearIdCard() {
	m.idCard = nil
	m.clearedFields[user.FieldIdCard] = struct{}{}
}

// IdCardCleared returns if the field idCard was cleared in this mutation.
func (m *UserMutation) IdCardCleared() bool {
	_, ok := m.clearedFields[user.FieldIdCard]
	return ok
}

// ResetIdCard reset all changes of the "idCard" field.
func (m *UserMutation) ResetIdCard() {
	m.idCard = nil
	delete(m.clearedFields, user.FieldIdCard)
}

// SetAddress sets the address field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the address value in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old address value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of address.
func (m *UserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[user.FieldAddress] = struct{}{}
}

// AddressCleared returns if the field address was cleared in this mutation.
func (m *UserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[user.FieldAddress]
	return ok
}

// ResetAddress reset all changes of the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, user.FieldAddress)
}

// SetOnJobState sets the onJobState field.
func (m *UserMutation) SetOnJobState(i int) {
	m.onJobState = &i
	m.addonJobState = nil
}

// OnJobState returns the onJobState value in the mutation.
func (m *UserMutation) OnJobState() (r int, exists bool) {
	v := m.onJobState
	if v == nil {
		return
	}
	return *v, true
}

// OldOnJobState returns the old onJobState value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldOnJobState(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnJobState is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnJobState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnJobState: %w", err)
	}
	return oldValue.OnJobState, nil
}

// AddOnJobState adds i to onJobState.
func (m *UserMutation) AddOnJobState(i int) {
	if m.addonJobState != nil {
		*m.addonJobState += i
	} else {
		m.addonJobState = &i
	}
}

// AddedOnJobState returns the value that was added to the onJobState field in this mutation.
func (m *UserMutation) AddedOnJobState() (r int, exists bool) {
	v := m.addonJobState
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnJobState reset all changes of the "onJobState" field.
func (m *UserMutation) ResetOnJobState() {
	m.onJobState = nil
	m.addonJobState = nil
}

// SetJoinedAt sets the joinedAt field.
func (m *UserMutation) SetJoinedAt(i int64) {
	m.joinedAt = &i
	m.addjoinedAt = nil
}

// JoinedAt returns the joinedAt value in the mutation.
func (m *UserMutation) JoinedAt() (r int64, exists bool) {
	v := m.joinedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old joinedAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldJoinedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldJoinedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// AddJoinedAt adds i to joinedAt.
func (m *UserMutation) AddJoinedAt(i int64) {
	if m.addjoinedAt != nil {
		*m.addjoinedAt += i
	} else {
		m.addjoinedAt = &i
	}
}

// AddedJoinedAt returns the value that was added to the joinedAt field in this mutation.
func (m *UserMutation) AddedJoinedAt() (r int64, exists bool) {
	v := m.addjoinedAt
	if v == nil {
		return
	}
	return *v, true
}

// ClearJoinedAt clears the value of joinedAt.
func (m *UserMutation) ClearJoinedAt() {
	m.joinedAt = nil
	m.addjoinedAt = nil
	m.clearedFields[user.FieldJoinedAt] = struct{}{}
}

// JoinedAtCleared returns if the field joinedAt was cleared in this mutation.
func (m *UserMutation) JoinedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldJoinedAt]
	return ok
}

// ResetJoinedAt reset all changes of the "joinedAt" field.
func (m *UserMutation) ResetJoinedAt() {
	m.joinedAt = nil
	m.addjoinedAt = nil
	delete(m.clearedFields, user.FieldJoinedAt)
}

// SetTenantId sets the tenantId field.
func (m *UserMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *UserMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *UserMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *UserMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantId clears the value of tenantId.
func (m *UserMutation) ClearTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
	m.clearedFields[user.FieldTenantId] = struct{}{}
}

// TenantIdCleared returns if the field tenantId was cleared in this mutation.
func (m *UserMutation) TenantIdCleared() bool {
	_, ok := m.clearedFields[user.FieldTenantId]
	return ok
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *UserMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
	delete(m.clearedFields, user.FieldTenantId)
}

// SetTenantName sets the tenantName field.
func (m *UserMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *UserMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ClearTenantName clears the value of tenantName.
func (m *UserMutation) ClearTenantName() {
	m.tenantName = nil
	m.clearedFields[user.FieldTenantName] = struct{}{}
}

// TenantNameCleared returns if the field tenantName was cleared in this mutation.
func (m *UserMutation) TenantNameCleared() bool {
	_, ok := m.clearedFields[user.FieldTenantName]
	return ok
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *UserMutation) ResetTenantName() {
	m.tenantName = nil
	delete(m.clearedFields, user.FieldTenantName)
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRemarks sets the remarks field.
func (m *UserMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *UserMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ClearRemarks clears the value of remarks.
func (m *UserMutation) ClearRemarks() {
	m.remarks = nil
	m.clearedFields[user.FieldRemarks] = struct{}{}
}

// RemarksCleared returns if the field remarks was cleared in this mutation.
func (m *UserMutation) RemarksCleared() bool {
	_, ok := m.clearedFields[user.FieldRemarks]
	return ok
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *UserMutation) ResetRemarks() {
	m.remarks = nil
	delete(m.clearedFields, user.FieldRemarks)
}

// SetCreatedAt sets the createdAt field.
func (m *UserMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *UserMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *UserMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *UserMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *UserMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *UserMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *UserMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *UserMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *UserMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *UserMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *UserMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *UserMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *UserMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.level != nil {
		fields = append(fields, user.FieldLevel)
	}
	if m.farmId != nil {
		fields = append(fields, user.FieldFarmId)
	}
	if m.farmName != nil {
		fields = append(fields, user.FieldFarmName)
	}
	if m.positionId != nil {
		fields = append(fields, user.FieldPositionId)
	}
	if m.positionName != nil {
		fields = append(fields, user.FieldPositionName)
	}
	if m.dutyName != nil {
		fields = append(fields, user.FieldDutyName)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.education != nil {
		fields = append(fields, user.FieldEducation)
	}
	if m.major != nil {
		fields = append(fields, user.FieldMajor)
	}
	if m.jobTitle != nil {
		fields = append(fields, user.FieldJobTitle)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.idCard != nil {
		fields = append(fields, user.FieldIdCard)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.onJobState != nil {
		fields = append(fields, user.FieldOnJobState)
	}
	if m.joinedAt != nil {
		fields = append(fields, user.FieldJoinedAt)
	}
	if m.tenantId != nil {
		fields = append(fields, user.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, user.FieldTenantName)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.remarks != nil {
		fields = append(fields, user.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, user.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLevel:
		return m.Level()
	case user.FieldFarmId:
		return m.FarmId()
	case user.FieldFarmName:
		return m.FarmName()
	case user.FieldPositionId:
		return m.PositionId()
	case user.FieldPositionName:
		return m.PositionName()
	case user.FieldDutyName:
		return m.DutyName()
	case user.FieldName:
		return m.Name()
	case user.FieldGender:
		return m.Gender()
	case user.FieldAge:
		return m.Age()
	case user.FieldEducation:
		return m.Education()
	case user.FieldMajor:
		return m.Major()
	case user.FieldJobTitle:
		return m.JobTitle()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldIdCard:
		return m.IdCard()
	case user.FieldAddress:
		return m.Address()
	case user.FieldOnJobState:
		return m.OnJobState()
	case user.FieldJoinedAt:
		return m.JoinedAt()
	case user.FieldTenantId:
		return m.TenantId()
	case user.FieldTenantName:
		return m.TenantName()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRemarks:
		return m.Remarks()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldLevel:
		return m.OldLevel(ctx)
	case user.FieldFarmId:
		return m.OldFarmId(ctx)
	case user.FieldFarmName:
		return m.OldFarmName(ctx)
	case user.FieldPositionId:
		return m.OldPositionId(ctx)
	case user.FieldPositionName:
		return m.OldPositionName(ctx)
	case user.FieldDutyName:
		return m.OldDutyName(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldEducation:
		return m.OldEducation(ctx)
	case user.FieldMajor:
		return m.OldMajor(ctx)
	case user.FieldJobTitle:
		return m.OldJobTitle(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldIdCard:
		return m.OldIdCard(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldOnJobState:
		return m.OldOnJobState(ctx)
	case user.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	case user.FieldTenantId:
		return m.OldTenantId(ctx)
	case user.FieldTenantName:
		return m.OldTenantName(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRemarks:
		return m.OldRemarks(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case user.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmId(v)
		return nil
	case user.FieldFarmName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFarmName(v)
		return nil
	case user.FieldPositionId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionId(v)
		return nil
	case user.FieldPositionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionName(v)
		return nil
	case user.FieldDutyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDutyName(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case user.FieldMajor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMajor(v)
		return nil
	case user.FieldJobTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobTitle(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldIdCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdCard(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldOnJobState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnJobState(v)
		return nil
	case user.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	case user.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case user.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, user.FieldLevel)
	}
	if m.addfarmId != nil {
		fields = append(fields, user.FieldFarmId)
	}
	if m.addpositionId != nil {
		fields = append(fields, user.FieldPositionId)
	}
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.addonJobState != nil {
		fields = append(fields, user.FieldOnJobState)
	}
	if m.addjoinedAt != nil {
		fields = append(fields, user.FieldJoinedAt)
	}
	if m.addtenantId != nil {
		fields = append(fields, user.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, user.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLevel:
		return m.AddedLevel()
	case user.FieldFarmId:
		return m.AddedFarmId()
	case user.FieldPositionId:
		return m.AddedPositionId()
	case user.FieldGender:
		return m.AddedGender()
	case user.FieldAge:
		return m.AddedAge()
	case user.FieldOnJobState:
		return m.AddedOnJobState()
	case user.FieldJoinedAt:
		return m.AddedJoinedAt()
	case user.FieldTenantId:
		return m.AddedTenantId()
	case user.FieldCreatedAt:
		return m.AddedCreatedAt()
	case user.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case user.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case user.FieldFarmId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFarmId(v)
		return nil
	case user.FieldPositionId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionId(v)
		return nil
	case user.FieldGender:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case user.FieldOnJobState:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnJobState(v)
		return nil
	case user.FieldJoinedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJoinedAt(v)
		return nil
	case user.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case user.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFarmId) {
		fields = append(fields, user.FieldFarmId)
	}
	if m.FieldCleared(user.FieldFarmName) {
		fields = append(fields, user.FieldFarmName)
	}
	if m.FieldCleared(user.FieldPositionId) {
		fields = append(fields, user.FieldPositionId)
	}
	if m.FieldCleared(user.FieldPositionName) {
		fields = append(fields, user.FieldPositionName)
	}
	if m.FieldCleared(user.FieldDutyName) {
		fields = append(fields, user.FieldDutyName)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldAge) {
		fields = append(fields, user.FieldAge)
	}
	if m.FieldCleared(user.FieldEducation) {
		fields = append(fields, user.FieldEducation)
	}
	if m.FieldCleared(user.FieldMajor) {
		fields = append(fields, user.FieldMajor)
	}
	if m.FieldCleared(user.FieldJobTitle) {
		fields = append(fields, user.FieldJobTitle)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldIdCard) {
		fields = append(fields, user.FieldIdCard)
	}
	if m.FieldCleared(user.FieldAddress) {
		fields = append(fields, user.FieldAddress)
	}
	if m.FieldCleared(user.FieldJoinedAt) {
		fields = append(fields, user.FieldJoinedAt)
	}
	if m.FieldCleared(user.FieldTenantId) {
		fields = append(fields, user.FieldTenantId)
	}
	if m.FieldCleared(user.FieldTenantName) {
		fields = append(fields, user.FieldTenantName)
	}
	if m.FieldCleared(user.FieldRemarks) {
		fields = append(fields, user.FieldRemarks)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFarmId:
		m.ClearFarmId()
		return nil
	case user.FieldFarmName:
		m.ClearFarmName()
		return nil
	case user.FieldPositionId:
		m.ClearPositionId()
		return nil
	case user.FieldPositionName:
		m.ClearPositionName()
		return nil
	case user.FieldDutyName:
		m.ClearDutyName()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldAge:
		m.ClearAge()
		return nil
	case user.FieldEducation:
		m.ClearEducation()
		return nil
	case user.FieldMajor:
		m.ClearMajor()
		return nil
	case user.FieldJobTitle:
		m.ClearJobTitle()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldIdCard:
		m.ClearIdCard()
		return nil
	case user.FieldAddress:
		m.ClearAddress()
		return nil
	case user.FieldJoinedAt:
		m.ClearJoinedAt()
		return nil
	case user.FieldTenantId:
		m.ClearTenantId()
		return nil
	case user.FieldTenantName:
		m.ClearTenantName()
		return nil
	case user.FieldRemarks:
		m.ClearRemarks()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldLevel:
		m.ResetLevel()
		return nil
	case user.FieldFarmId:
		m.ResetFarmId()
		return nil
	case user.FieldFarmName:
		m.ResetFarmName()
		return nil
	case user.FieldPositionId:
		m.ResetPositionId()
		return nil
	case user.FieldPositionName:
		m.ResetPositionName()
		return nil
	case user.FieldDutyName:
		m.ResetDutyName()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldEducation:
		m.ResetEducation()
		return nil
	case user.FieldMajor:
		m.ResetMajor()
		return nil
	case user.FieldJobTitle:
		m.ResetJobTitle()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldIdCard:
		m.ResetIdCard()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldOnJobState:
		m.ResetOnJobState()
		return nil
	case user.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	case user.FieldTenantId:
		m.ResetTenantId()
		return nil
	case user.FieldTenantName:
		m.ResetTenantName()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRemarks:
		m.ResetRemarks()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// VeterinaryDrugsInfoMutation represents an operation that mutate the VeterinaryDrugsInfos
// nodes in the graph.
type VeterinaryDrugsInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	code          *string
	_type         *string
	stopAt        *int64
	addstopAt     *int64
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VeterinaryDrugsInfo, error)
}

var _ ent.Mutation = (*VeterinaryDrugsInfoMutation)(nil)

// veterinarydrugsinfoOption allows to manage the mutation configuration using functional options.
type veterinarydrugsinfoOption func(*VeterinaryDrugsInfoMutation)

// newVeterinaryDrugsInfoMutation creates new mutation for $n.Name.
func newVeterinaryDrugsInfoMutation(c config, op Op, opts ...veterinarydrugsinfoOption) *VeterinaryDrugsInfoMutation {
	m := &VeterinaryDrugsInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeVeterinaryDrugsInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVeterinaryDrugsInfoID sets the id field of the mutation.
func withVeterinaryDrugsInfoID(id int64) veterinarydrugsinfoOption {
	return func(m *VeterinaryDrugsInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *VeterinaryDrugsInfo
		)
		m.oldValue = func(ctx context.Context) (*VeterinaryDrugsInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VeterinaryDrugsInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVeterinaryDrugsInfo sets the old VeterinaryDrugsInfo of the mutation.
func withVeterinaryDrugsInfo(node *VeterinaryDrugsInfo) veterinarydrugsinfoOption {
	return func(m *VeterinaryDrugsInfoMutation) {
		m.oldValue = func(context.Context) (*VeterinaryDrugsInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VeterinaryDrugsInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VeterinaryDrugsInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *VeterinaryDrugsInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *VeterinaryDrugsInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *VeterinaryDrugsInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *VeterinaryDrugsInfoMutation) ResetName() {
	m.name = nil
}

// SetCode sets the code field.
func (m *VeterinaryDrugsInfoMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the code value in the mutation.
func (m *VeterinaryDrugsInfoMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old code value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode reset all changes of the "code" field.
func (m *VeterinaryDrugsInfoMutation) ResetCode() {
	m.code = nil
}

// SetType sets the type field.
func (m *VeterinaryDrugsInfoMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *VeterinaryDrugsInfoMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *VeterinaryDrugsInfoMutation) ResetType() {
	m._type = nil
}

// SetStopAt sets the stopAt field.
func (m *VeterinaryDrugsInfoMutation) SetStopAt(i int64) {
	m.stopAt = &i
	m.addstopAt = nil
}

// StopAt returns the stopAt value in the mutation.
func (m *VeterinaryDrugsInfoMutation) StopAt() (r int64, exists bool) {
	v := m.stopAt
	if v == nil {
		return
	}
	return *v, true
}

// OldStopAt returns the old stopAt value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldStopAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStopAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStopAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopAt: %w", err)
	}
	return oldValue.StopAt, nil
}

// AddStopAt adds i to stopAt.
func (m *VeterinaryDrugsInfoMutation) AddStopAt(i int64) {
	if m.addstopAt != nil {
		*m.addstopAt += i
	} else {
		m.addstopAt = &i
	}
}

// AddedStopAt returns the value that was added to the stopAt field in this mutation.
func (m *VeterinaryDrugsInfoMutation) AddedStopAt() (r int64, exists bool) {
	v := m.addstopAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetStopAt reset all changes of the "stopAt" field.
func (m *VeterinaryDrugsInfoMutation) ResetStopAt() {
	m.stopAt = nil
	m.addstopAt = nil
}

// SetTenantId sets the tenantId field.
func (m *VeterinaryDrugsInfoMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *VeterinaryDrugsInfoMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *VeterinaryDrugsInfoMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *VeterinaryDrugsInfoMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *VeterinaryDrugsInfoMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *VeterinaryDrugsInfoMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *VeterinaryDrugsInfoMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *VeterinaryDrugsInfoMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *VeterinaryDrugsInfoMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *VeterinaryDrugsInfoMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *VeterinaryDrugsInfoMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *VeterinaryDrugsInfoMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *VeterinaryDrugsInfoMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *VeterinaryDrugsInfoMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *VeterinaryDrugsInfoMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *VeterinaryDrugsInfoMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *VeterinaryDrugsInfoMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *VeterinaryDrugsInfoMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *VeterinaryDrugsInfoMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *VeterinaryDrugsInfoMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *VeterinaryDrugsInfoMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *VeterinaryDrugsInfoMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *VeterinaryDrugsInfoMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the VeterinaryDrugsInfo.
// If the VeterinaryDrugsInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *VeterinaryDrugsInfoMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *VeterinaryDrugsInfoMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *VeterinaryDrugsInfoMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *VeterinaryDrugsInfoMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *VeterinaryDrugsInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VeterinaryDrugsInfo).
func (m *VeterinaryDrugsInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *VeterinaryDrugsInfoMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, veterinarydrugsinfo.FieldName)
	}
	if m.code != nil {
		fields = append(fields, veterinarydrugsinfo.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, veterinarydrugsinfo.FieldType)
	}
	if m.stopAt != nil {
		fields = append(fields, veterinarydrugsinfo.FieldStopAt)
	}
	if m.tenantId != nil {
		fields = append(fields, veterinarydrugsinfo.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, veterinarydrugsinfo.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, veterinarydrugsinfo.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, veterinarydrugsinfo.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, veterinarydrugsinfo.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, veterinarydrugsinfo.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *VeterinaryDrugsInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case veterinarydrugsinfo.FieldName:
		return m.Name()
	case veterinarydrugsinfo.FieldCode:
		return m.Code()
	case veterinarydrugsinfo.FieldType:
		return m.GetType()
	case veterinarydrugsinfo.FieldStopAt:
		return m.StopAt()
	case veterinarydrugsinfo.FieldTenantId:
		return m.TenantId()
	case veterinarydrugsinfo.FieldTenantName:
		return m.TenantName()
	case veterinarydrugsinfo.FieldRemarks:
		return m.Remarks()
	case veterinarydrugsinfo.FieldCreatedAt:
		return m.CreatedAt()
	case veterinarydrugsinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case veterinarydrugsinfo.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *VeterinaryDrugsInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case veterinarydrugsinfo.FieldName:
		return m.OldName(ctx)
	case veterinarydrugsinfo.FieldCode:
		return m.OldCode(ctx)
	case veterinarydrugsinfo.FieldType:
		return m.OldType(ctx)
	case veterinarydrugsinfo.FieldStopAt:
		return m.OldStopAt(ctx)
	case veterinarydrugsinfo.FieldTenantId:
		return m.OldTenantId(ctx)
	case veterinarydrugsinfo.FieldTenantName:
		return m.OldTenantName(ctx)
	case veterinarydrugsinfo.FieldRemarks:
		return m.OldRemarks(ctx)
	case veterinarydrugsinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case veterinarydrugsinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case veterinarydrugsinfo.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown VeterinaryDrugsInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VeterinaryDrugsInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case veterinarydrugsinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case veterinarydrugsinfo.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case veterinarydrugsinfo.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case veterinarydrugsinfo.FieldStopAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopAt(v)
		return nil
	case veterinarydrugsinfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case veterinarydrugsinfo.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case veterinarydrugsinfo.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case veterinarydrugsinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case veterinarydrugsinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case veterinarydrugsinfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown VeterinaryDrugsInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *VeterinaryDrugsInfoMutation) AddedFields() []string {
	var fields []string
	if m.addstopAt != nil {
		fields = append(fields, veterinarydrugsinfo.FieldStopAt)
	}
	if m.addtenantId != nil {
		fields = append(fields, veterinarydrugsinfo.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, veterinarydrugsinfo.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, veterinarydrugsinfo.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, veterinarydrugsinfo.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *VeterinaryDrugsInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case veterinarydrugsinfo.FieldStopAt:
		return m.AddedStopAt()
	case veterinarydrugsinfo.FieldTenantId:
		return m.AddedTenantId()
	case veterinarydrugsinfo.FieldCreatedAt:
		return m.AddedCreatedAt()
	case veterinarydrugsinfo.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case veterinarydrugsinfo.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *VeterinaryDrugsInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case veterinarydrugsinfo.FieldStopAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStopAt(v)
		return nil
	case veterinarydrugsinfo.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case veterinarydrugsinfo.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case veterinarydrugsinfo.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case veterinarydrugsinfo.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown VeterinaryDrugsInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *VeterinaryDrugsInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *VeterinaryDrugsInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *VeterinaryDrugsInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VeterinaryDrugsInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *VeterinaryDrugsInfoMutation) ResetField(name string) error {
	switch name {
	case veterinarydrugsinfo.FieldName:
		m.ResetName()
		return nil
	case veterinarydrugsinfo.FieldCode:
		m.ResetCode()
		return nil
	case veterinarydrugsinfo.FieldType:
		m.ResetType()
		return nil
	case veterinarydrugsinfo.FieldStopAt:
		m.ResetStopAt()
		return nil
	case veterinarydrugsinfo.FieldTenantId:
		m.ResetTenantId()
		return nil
	case veterinarydrugsinfo.FieldTenantName:
		m.ResetTenantName()
		return nil
	case veterinarydrugsinfo.FieldRemarks:
		m.ResetRemarks()
		return nil
	case veterinarydrugsinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case veterinarydrugsinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case veterinarydrugsinfo.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown VeterinaryDrugsInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *VeterinaryDrugsInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *VeterinaryDrugsInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *VeterinaryDrugsInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *VeterinaryDrugsInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *VeterinaryDrugsInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *VeterinaryDrugsInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *VeterinaryDrugsInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VeterinaryDrugsInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *VeterinaryDrugsInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VeterinaryDrugsInfo edge %s", name)
}

// WarehouseSettingMutation represents an operation that mutate the WarehouseSettings
// nodes in the graph.
type WarehouseSettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	_type         *string
	tenantId      *int64
	addtenantId   *int64
	tenantName    *string
	remarks       *string
	createdAt     *int64
	addcreatedAt  *int64
	updatedAt     *int64
	addupdatedAt  *int64
	deleted       *int
	adddeleted    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WarehouseSetting, error)
}

var _ ent.Mutation = (*WarehouseSettingMutation)(nil)

// warehousesettingOption allows to manage the mutation configuration using functional options.
type warehousesettingOption func(*WarehouseSettingMutation)

// newWarehouseSettingMutation creates new mutation for $n.Name.
func newWarehouseSettingMutation(c config, op Op, opts ...warehousesettingOption) *WarehouseSettingMutation {
	m := &WarehouseSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeWarehouseSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWarehouseSettingID sets the id field of the mutation.
func withWarehouseSettingID(id int64) warehousesettingOption {
	return func(m *WarehouseSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *WarehouseSetting
		)
		m.oldValue = func(ctx context.Context) (*WarehouseSetting, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WarehouseSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWarehouseSetting sets the old WarehouseSetting of the mutation.
func withWarehouseSetting(node *WarehouseSetting) warehousesettingOption {
	return func(m *WarehouseSettingMutation) {
		m.oldValue = func(context.Context) (*WarehouseSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WarehouseSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WarehouseSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WarehouseSettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *WarehouseSettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WarehouseSettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WarehouseSettingMutation) ResetName() {
	m.name = nil
}

// SetType sets the type field.
func (m *WarehouseSettingMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the type value in the mutation.
func (m *WarehouseSettingMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType reset all changes of the "type" field.
func (m *WarehouseSettingMutation) ResetType() {
	m._type = nil
}

// SetTenantId sets the tenantId field.
func (m *WarehouseSettingMutation) SetTenantId(i int64) {
	m.tenantId = &i
	m.addtenantId = nil
}

// TenantId returns the tenantId value in the mutation.
func (m *WarehouseSettingMutation) TenantId() (r int64, exists bool) {
	v := m.tenantId
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantId returns the old tenantId value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldTenantId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantId is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantId: %w", err)
	}
	return oldValue.TenantId, nil
}

// AddTenantId adds i to tenantId.
func (m *WarehouseSettingMutation) AddTenantId(i int64) {
	if m.addtenantId != nil {
		*m.addtenantId += i
	} else {
		m.addtenantId = &i
	}
}

// AddedTenantId returns the value that was added to the tenantId field in this mutation.
func (m *WarehouseSettingMutation) AddedTenantId() (r int64, exists bool) {
	v := m.addtenantId
	if v == nil {
		return
	}
	return *v, true
}

// ResetTenantId reset all changes of the "tenantId" field.
func (m *WarehouseSettingMutation) ResetTenantId() {
	m.tenantId = nil
	m.addtenantId = nil
}

// SetTenantName sets the tenantName field.
func (m *WarehouseSettingMutation) SetTenantName(s string) {
	m.tenantName = &s
}

// TenantName returns the tenantName value in the mutation.
func (m *WarehouseSettingMutation) TenantName() (r string, exists bool) {
	v := m.tenantName
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old tenantName value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTenantName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName reset all changes of the "tenantName" field.
func (m *WarehouseSettingMutation) ResetTenantName() {
	m.tenantName = nil
}

// SetRemarks sets the remarks field.
func (m *WarehouseSettingMutation) SetRemarks(s string) {
	m.remarks = &s
}

// Remarks returns the remarks value in the mutation.
func (m *WarehouseSettingMutation) Remarks() (r string, exists bool) {
	v := m.remarks
	if v == nil {
		return
	}
	return *v, true
}

// OldRemarks returns the old remarks value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldRemarks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemarks is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemarks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemarks: %w", err)
	}
	return oldValue.Remarks, nil
}

// ResetRemarks reset all changes of the "remarks" field.
func (m *WarehouseSettingMutation) ResetRemarks() {
	m.remarks = nil
}

// SetCreatedAt sets the createdAt field.
func (m *WarehouseSettingMutation) SetCreatedAt(i int64) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the createdAt value in the mutation.
func (m *WarehouseSettingMutation) CreatedAt() (r int64, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old createdAt value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to createdAt.
func (m *WarehouseSettingMutation) AddCreatedAt(i int64) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the createdAt field in this mutation.
func (m *WarehouseSettingMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the "createdAt" field.
func (m *WarehouseSettingMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// SetUpdatedAt sets the updatedAt field.
func (m *WarehouseSettingMutation) SetUpdatedAt(i int64) {
	m.updatedAt = &i
	m.addupdatedAt = nil
}

// UpdatedAt returns the updatedAt value in the mutation.
func (m *WarehouseSettingMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updatedAt value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to updatedAt.
func (m *WarehouseSettingMutation) AddUpdatedAt(i int64) {
	if m.addupdatedAt != nil {
		*m.addupdatedAt += i
	} else {
		m.addupdatedAt = &i
	}
}

// AddedUpdatedAt returns the value that was added to the updatedAt field in this mutation.
func (m *WarehouseSettingMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the "updatedAt" field.
func (m *WarehouseSettingMutation) ResetUpdatedAt() {
	m.updatedAt = nil
	m.addupdatedAt = nil
}

// SetDeleted sets the deleted field.
func (m *WarehouseSettingMutation) SetDeleted(i int) {
	m.deleted = &i
	m.adddeleted = nil
}

// Deleted returns the deleted value in the mutation.
func (m *WarehouseSettingMutation) Deleted() (r int, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old deleted value of the WarehouseSetting.
// If the WarehouseSetting object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WarehouseSettingMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleted is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to deleted.
func (m *WarehouseSettingMutation) AddDeleted(i int) {
	if m.adddeleted != nil {
		*m.adddeleted += i
	} else {
		m.adddeleted = &i
	}
}

// AddedDeleted returns the value that was added to the deleted field in this mutation.
func (m *WarehouseSettingMutation) AddedDeleted() (r int, exists bool) {
	v := m.adddeleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted reset all changes of the "deleted" field.
func (m *WarehouseSettingMutation) ResetDeleted() {
	m.deleted = nil
	m.adddeleted = nil
}

// Op returns the operation name.
func (m *WarehouseSettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WarehouseSetting).
func (m *WarehouseSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WarehouseSettingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, warehousesetting.FieldName)
	}
	if m._type != nil {
		fields = append(fields, warehousesetting.FieldType)
	}
	if m.tenantId != nil {
		fields = append(fields, warehousesetting.FieldTenantId)
	}
	if m.tenantName != nil {
		fields = append(fields, warehousesetting.FieldTenantName)
	}
	if m.remarks != nil {
		fields = append(fields, warehousesetting.FieldRemarks)
	}
	if m.createdAt != nil {
		fields = append(fields, warehousesetting.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, warehousesetting.FieldUpdatedAt)
	}
	if m.deleted != nil {
		fields = append(fields, warehousesetting.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WarehouseSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case warehousesetting.FieldName:
		return m.Name()
	case warehousesetting.FieldType:
		return m.GetType()
	case warehousesetting.FieldTenantId:
		return m.TenantId()
	case warehousesetting.FieldTenantName:
		return m.TenantName()
	case warehousesetting.FieldRemarks:
		return m.Remarks()
	case warehousesetting.FieldCreatedAt:
		return m.CreatedAt()
	case warehousesetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case warehousesetting.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WarehouseSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case warehousesetting.FieldName:
		return m.OldName(ctx)
	case warehousesetting.FieldType:
		return m.OldType(ctx)
	case warehousesetting.FieldTenantId:
		return m.OldTenantId(ctx)
	case warehousesetting.FieldTenantName:
		return m.OldTenantName(ctx)
	case warehousesetting.FieldRemarks:
		return m.OldRemarks(ctx)
	case warehousesetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case warehousesetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case warehousesetting.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown WarehouseSetting field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WarehouseSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case warehousesetting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case warehousesetting.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case warehousesetting.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantId(v)
		return nil
	case warehousesetting.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case warehousesetting.FieldRemarks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemarks(v)
		return nil
	case warehousesetting.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case warehousesetting.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case warehousesetting.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown WarehouseSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WarehouseSettingMutation) AddedFields() []string {
	var fields []string
	if m.addtenantId != nil {
		fields = append(fields, warehousesetting.FieldTenantId)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, warehousesetting.FieldCreatedAt)
	}
	if m.addupdatedAt != nil {
		fields = append(fields, warehousesetting.FieldUpdatedAt)
	}
	if m.adddeleted != nil {
		fields = append(fields, warehousesetting.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WarehouseSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case warehousesetting.FieldTenantId:
		return m.AddedTenantId()
	case warehousesetting.FieldCreatedAt:
		return m.AddedCreatedAt()
	case warehousesetting.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case warehousesetting.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WarehouseSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case warehousesetting.FieldTenantId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantId(v)
		return nil
	case warehousesetting.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case warehousesetting.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case warehousesetting.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown WarehouseSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WarehouseSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WarehouseSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WarehouseSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WarehouseSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WarehouseSettingMutation) ResetField(name string) error {
	switch name {
	case warehousesetting.FieldName:
		m.ResetName()
		return nil
	case warehousesetting.FieldType:
		m.ResetType()
		return nil
	case warehousesetting.FieldTenantId:
		m.ResetTenantId()
		return nil
	case warehousesetting.FieldTenantName:
		m.ResetTenantName()
		return nil
	case warehousesetting.FieldRemarks:
		m.ResetRemarks()
		return nil
	case warehousesetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case warehousesetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case warehousesetting.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown WarehouseSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WarehouseSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WarehouseSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WarehouseSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WarehouseSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WarehouseSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WarehouseSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WarehouseSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WarehouseSetting unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WarehouseSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WarehouseSetting edge %s", name)
}

// WhereaboutsMutation represents an operation that mutate the WhereaboutsSlice
// nodes in the graph.
type WhereaboutsMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Whereabouts, error)
}

var _ ent.Mutation = (*WhereaboutsMutation)(nil)

// whereaboutsOption allows to manage the mutation configuration using functional options.
type whereaboutsOption func(*WhereaboutsMutation)

// newWhereaboutsMutation creates new mutation for $n.Name.
func newWhereaboutsMutation(c config, op Op, opts ...whereaboutsOption) *WhereaboutsMutation {
	m := &WhereaboutsMutation{
		config:        c,
		op:            op,
		typ:           TypeWhereabouts,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWhereaboutsID sets the id field of the mutation.
func withWhereaboutsID(id int64) whereaboutsOption {
	return func(m *WhereaboutsMutation) {
		var (
			err   error
			once  sync.Once
			value *Whereabouts
		)
		m.oldValue = func(ctx context.Context) (*Whereabouts, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Whereabouts.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWhereabouts sets the old Whereabouts of the mutation.
func withWhereabouts(node *Whereabouts) whereaboutsOption {
	return func(m *WhereaboutsMutation) {
		m.oldValue = func(context.Context) (*Whereabouts, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WhereaboutsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WhereaboutsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WhereaboutsMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *WhereaboutsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WhereaboutsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Whereabouts.
// If the Whereabouts object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WhereaboutsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WhereaboutsMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *WhereaboutsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Whereabouts).
func (m *WhereaboutsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WhereaboutsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, whereabouts.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WhereaboutsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case whereabouts.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WhereaboutsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case whereabouts.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Whereabouts field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WhereaboutsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case whereabouts.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Whereabouts field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WhereaboutsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WhereaboutsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WhereaboutsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Whereabouts numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WhereaboutsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WhereaboutsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WhereaboutsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Whereabouts nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WhereaboutsMutation) ResetField(name string) error {
	switch name {
	case whereabouts.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Whereabouts field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WhereaboutsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WhereaboutsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WhereaboutsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WhereaboutsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WhereaboutsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WhereaboutsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WhereaboutsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Whereabouts unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WhereaboutsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Whereabouts edge %s", name)
}

// WindDirectionMutation represents an operation that mutate the WindDirections
// nodes in the graph.
type WindDirectionMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*WindDirection, error)
}

var _ ent.Mutation = (*WindDirectionMutation)(nil)

// winddirectionOption allows to manage the mutation configuration using functional options.
type winddirectionOption func(*WindDirectionMutation)

// newWindDirectionMutation creates new mutation for $n.Name.
func newWindDirectionMutation(c config, op Op, opts ...winddirectionOption) *WindDirectionMutation {
	m := &WindDirectionMutation{
		config:        c,
		op:            op,
		typ:           TypeWindDirection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWindDirectionID sets the id field of the mutation.
func withWindDirectionID(id int64) winddirectionOption {
	return func(m *WindDirectionMutation) {
		var (
			err   error
			once  sync.Once
			value *WindDirection
		)
		m.oldValue = func(ctx context.Context) (*WindDirection, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WindDirection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWindDirection sets the old WindDirection of the mutation.
func withWindDirection(node *WindDirection) winddirectionOption {
	return func(m *WindDirectionMutation) {
		m.oldValue = func(context.Context) (*WindDirection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WindDirectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WindDirectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *WindDirectionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *WindDirectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *WindDirectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the WindDirection.
// If the WindDirection object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *WindDirectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *WindDirectionMutation) ResetName() {
	m.name = nil
}

// Op returns the operation name.
func (m *WindDirectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WindDirection).
func (m *WindDirectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *WindDirectionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, winddirection.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *WindDirectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case winddirection.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *WindDirectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case winddirection.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown WindDirection field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WindDirectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case winddirection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown WindDirection field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *WindDirectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *WindDirectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *WindDirectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WindDirection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *WindDirectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *WindDirectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *WindDirectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WindDirection nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *WindDirectionMutation) ResetField(name string) error {
	switch name {
	case winddirection.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown WindDirection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *WindDirectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *WindDirectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *WindDirectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *WindDirectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *WindDirectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *WindDirectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *WindDirectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown WindDirection unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *WindDirectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown WindDirection edge %s", name)
}
